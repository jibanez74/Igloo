import type { InferOutput } from "valibot";
export declare const COMMON_OPTIONS: import("valibot").StrictObjectSchema<{
    readonly rootFontSize: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").NumberSchema<undefined>, import("valibot").DescriptionAction<number, "The root font size in pixels.">]>, undefined>;
    readonly detectComponentClasses: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").BooleanSchema<undefined>, import("valibot").DescriptionAction<boolean, "Whether to automatically detect custom component classes from the tailwindcss config.">]>, false>;
    readonly tsconfig: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "The path to the tsconfig file. Is used to resolve path aliases in the tsconfig.">]>, undefined>;
    readonly tailwindConfig: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "The path to the tailwind config file. If not specified, the plugin will try to find it automatically or falls back to the default configuration.">]>, undefined>;
    readonly messageStyle: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").UnionSchema<[import("valibot").LiteralSchema<"visual", undefined>, import("valibot").LiteralSchema<"compact", undefined>, import("valibot").LiteralSchema<"raw", undefined>], undefined>, import("valibot").DescriptionAction<"visual" | "compact" | "raw", "How linting messages are displayed.">]>, "visual" | "compact">;
    readonly entryPoint: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "The path to the css entry point of the project. If not specified, the plugin will fall back to the default tailwind classes.">]>, undefined>;
    readonly tags: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Template literal tag for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]], "List of matchers that will automatically be matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Template literal tag that should get linted.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]])[], "List of template literal tags that should get linted.">]>, never[]>;
    readonly variables: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Variable name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]], "List of matchers that will automatically be matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Variable name for which children get linted.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]])[], "List of variable names which values should get linted.">]>, [string, {
        match: import("../types/rule.js").MatcherType.String;
    }[]][]>;
    readonly attributes: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Attribute name that for which children get linted.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Attribute name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]], "List of matchers that will automatically be matched.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]])[], "List of attribute names that should get linted.">]>, (string | [string, ({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
    })[]])[]>;
    readonly callees: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Callee name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]], "List of matchers that will automatically be matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Callee name for which children get linted.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
        match: import("../types/rule.js").MatcherType.String;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]])[], "List of function names which arguments should get linted.">]>, ([string, {
        match: import("../types/rule.js").MatcherType.String;
    }[]] | [string, {
        match: import("../types/rule.js").MatcherType.ObjectKey;
    }[]] | [string, {
        match: import("../types/rule.js").MatcherType.ObjectValue;
        pathPattern: string;
    }[]])[]>;
}, undefined>;
export type CommonOptions = InferOutput<typeof COMMON_OPTIONS>;
//# sourceMappingURL=descriptions.d.ts.map