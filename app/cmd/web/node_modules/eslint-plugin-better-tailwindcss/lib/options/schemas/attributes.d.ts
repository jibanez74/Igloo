import type { InferOutput } from "valibot";
export declare const ATTRIBUTE_MATCHER_CONFIG: import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Attribute name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
}, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]], "List of matchers that will automatically be matched.">]>;
export type AttributeMatchers = InferOutput<typeof ATTRIBUTE_MATCHER_CONFIG>;
export declare const ATTRIBUTE_NAME_CONFIG: import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Attribute name that for which children get linted.">]>;
export type AttributeName = InferOutput<typeof ATTRIBUTE_NAME_CONFIG>;
export declare const ATTRIBUTES_SCHEMA: import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Attribute name that for which children get linted.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Attribute name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
}, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]], "List of matchers that will automatically be matched.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]])[], "List of attribute names that should get linted.">]>;
export type Attributes = InferOutput<typeof ATTRIBUTES_SCHEMA>;
export declare const ATTRIBUTES_OPTION_SCHEMA: import("valibot").StrictObjectSchema<{
    readonly attributes: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Attribute name that for which children get linted.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Attribute name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]], "List of matchers that will automatically be matched.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]])[], "List of attribute names that should get linted.">]>, (string | [string, ({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
    })[]])[]>;
}, undefined>;
export type AttributesOptions = InferOutput<typeof ATTRIBUTES_OPTION_SCHEMA>;
//# sourceMappingURL=attributes.d.ts.map