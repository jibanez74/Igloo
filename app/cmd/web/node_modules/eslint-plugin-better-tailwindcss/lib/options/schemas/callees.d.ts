import type { InferOutput } from "valibot";
declare const CALLEE_MATCHER_SCHEMA: import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Callee name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
}, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]], "List of matchers that will automatically be matched.">]>;
export type CalleeMatchers = InferOutput<typeof CALLEE_MATCHER_SCHEMA>;
declare const CALLEE_NAME_SCHEMA: import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Callee name for which children get linted.">]>;
export type CalleeName = InferOutput<typeof CALLEE_NAME_SCHEMA>;
export declare const CALLEES_SCHEMA: import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Callee name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
}, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]], "List of matchers that will automatically be matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Callee name for which children get linted.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]])[], "List of function names which arguments should get linted.">]>;
export type Callees = InferOutput<typeof CALLEES_SCHEMA>;
export declare const CALLEES_OPTION_SCHEMA: import("valibot").StrictObjectSchema<{
    readonly callees: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Callee name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]], "List of matchers that will automatically be matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Callee name for which children get linted.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]])[], "List of function names which arguments should get linted.">]>, ([string, {
        match: import("../../types/rule.js").MatcherType.String;
    }[]] | [string, {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
    }[]] | [string, {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern: string;
    }[]])[]>;
}, undefined>;
export type CalleesOptions = InferOutput<typeof CALLEES_OPTION_SCHEMA>;
export {};
//# sourceMappingURL=callees.d.ts.map