import type { InferOutput } from "valibot";
declare const TAG_MATCHER_CONFIG: import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Template literal tag for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
}, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]], "List of matchers that will automatically be matched.">]>;
export type TagMatchers = InferOutput<typeof TAG_MATCHER_CONFIG>;
declare const TAG_NAME_CONFIG: import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Template literal tag that should get linted.">]>;
export type TagName = InferOutput<typeof TAG_NAME_CONFIG>;
export declare const TAGS_SCHEMA: import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Template literal tag for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
}, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]], "List of matchers that will automatically be matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Template literal tag that should get linted.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]])[], "List of template literal tags that should get linted.">]>;
export type Tags = InferOutput<typeof TAGS_SCHEMA>;
export declare const TAGS_OPTIONS_SCHEMA: import("valibot").StrictObjectSchema<{
    readonly tags: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Template literal tag for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]], "List of matchers that will automatically be matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Template literal tag that should get linted.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]])[], "List of template literal tags that should get linted.">]>, never[]>;
}, undefined>;
export type TagsOptions = InferOutput<typeof TAGS_OPTIONS_SCHEMA>;
export {};
//# sourceMappingURL=tags.d.ts.map