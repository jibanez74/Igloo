import type { InferOutput } from "valibot";
export declare const VARIABLE_MATCHER_CONFIG: import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Variable name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
}, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]], "List of matchers that will automatically be matched.">]>;
export type VariableMatchers = InferOutput<typeof VARIABLE_MATCHER_CONFIG>;
export declare const VARIABLE_NAME_CONFIG: import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Variable name for which children get linted.">]>;
export type VariableName = InferOutput<typeof VARIABLE_NAME_CONFIG>;
export declare const VARIABLES_SCHEMA: import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Variable name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
}, undefined>, import("valibot").StrictObjectSchema<{
    readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
    readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
}, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]], "List of matchers that will automatically be matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Variable name for which children get linted.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
    match: import("../../types/rule.js").MatcherType.String;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectKey;
    pathPattern?: string | undefined;
} | {
    match: import("../../types/rule.js").MatcherType.ObjectValue;
    pathPattern?: string | undefined;
})[]])[], "List of variable names which values should get linted.">]>;
export type Variables = InferOutput<typeof VARIABLES_SCHEMA>;
export declare const VARIABLES_OPTION_SCHEMA: import("valibot").StrictObjectSchema<{
    readonly variables: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").TupleSchema<[import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Variable name for which children get linted if matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").ArraySchema<import("valibot").UnionSchema<[import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.String, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.String, "Matcher type that will be applied.">]>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectKey, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectKey, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object key and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>, import("valibot").StrictObjectSchema<{
        readonly match: import("valibot").SchemaWithPipe<readonly [import("valibot").LiteralSchema<import("../../types/rule.js").MatcherType.ObjectValue, undefined>, import("valibot").DescriptionAction<import("../../types/rule.js").MatcherType.ObjectValue, "Matcher type that will be applied.">]>;
        readonly pathPattern: import("valibot").OptionalSchema<import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Regular expression that filters the object value and matches the content for further processing in a group.">]>, undefined>;
    }, undefined>], undefined>, undefined>, import("valibot").DescriptionAction<({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[], "List of matchers that will be applied.">]>], undefined>, import("valibot").DescriptionAction<[string, ({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]], "List of matchers that will automatically be matched.">]>, import("valibot").SchemaWithPipe<readonly [import("valibot").StringSchema<undefined>, import("valibot").DescriptionAction<string, "Variable name for which children get linted.">]>], undefined>, undefined>, import("valibot").DescriptionAction<(string | [string, ({
        match: import("../../types/rule.js").MatcherType.String;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectKey;
        pathPattern?: string | undefined;
    } | {
        match: import("../../types/rule.js").MatcherType.ObjectValue;
        pathPattern?: string | undefined;
    })[]])[], "List of variable names which values should get linted.">]>, [string, {
        match: import("../../types/rule.js").MatcherType.String;
    }[]][]>;
}, undefined>;
export type VariablesOptions = InferOutput<typeof VARIABLES_OPTION_SCHEMA>;
//# sourceMappingURL=variables.d.ts.map