{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/core/compat.ts", "../../../src/core/symbols.ts", "../../../src/core/constants.ts", "../../../src/core/node.ts", "../../../src/core/literals.ts", "../../../src/core/string.ts", "../../../src/core/keys.ts", "../../../src/core/reference.ts", "../../../src/core/utils/error.ts", "../../../src/core/utils/get-object-flag.ts", "../../../src/core/base-primitives.ts", "../../../src/core/errors.ts", "../../../src/core/opaque-reference.ts", "../../../src/core/constructors.ts", "../../../src/core/special-reference.ts", "../../../src/core/stream.ts", "../../../src/core/utils/iterator-to-sequence.ts", "../../../src/core/utils/promise-to-result.ts", "../../../src/core/context/parser.ts", "../../../src/core/context/async-parser.ts", "../../../src/core/plugin.ts", "../../../src/core/utils/typed-array.ts", "../../../src/core/context/deserializer.ts", "../../../src/core/function-string.ts", "../../../src/core/utils/get-identifier.ts", "../../../src/core/utils/is-valid-identifier.ts", "../../../src/core/context/serializer.ts", "../../../src/core/context/sync-parser.ts", "../../../src/core/cross/index.ts", "../../../src/core/Serializer.ts", "../../../src/core/tree/index.ts"],
  "sourcesContent": ["export { Feature } from './core/compat';\nexport type {\n  AsyncParsePluginContext,\n  AsyncParserContextOptions,\n} from './core/context/async-parser';\nexport type {\n  BaseDeserializerContextOptions,\n  CrossDeserializerContextOptions,\n  DeserializePluginContext,\n  VanillaDeserializerContextOptions,\n} from './core/context/deserializer';\nexport type { BaseParserContextOptions } from './core/context/parser';\nexport type {\n  BaseSerializerContextOptions,\n  CrossContextOptions,\n  CrossSerializerContextOptions,\n  SerializePluginContext,\n  VanillaSerializerContextOptions,\n} from './core/context/serializer';\nexport type {\n  StreamParsePluginContext,\n  StreamParserContextOptions,\n  SyncParsePluginContext,\n  SyncParserContextOptions,\n} from './core/context/sync-parser';\nexport * from './core/cross';\nexport * from './core/errors';\nexport { getCrossReferenceHeader } from './core/keys';\nexport { OpaqueReference } from './core/opaque-reference';\nexport * from './core/plugin';\nexport { createReference } from './core/reference';\nexport { default as Serializer } from './core/Serializer';\nexport { createStream } from './core/stream';\nexport type { Stream, StreamListener } from './core/stream';\nexport * from './core/tree';\nexport type { SerovalNode } from './core/types';\n", "/**\n * References\n * - https://compat-table.github.io/compat-table/es6/\n * - MDN\n */\n\nexport enum Feature {\n  AggregateError = 0x01,\n  // @deprecated\n  ArrowFunction = 0x02,\n  ErrorPrototypeStack = 0x04,\n  ObjectAssign = 0x08,\n  BigIntTypedArray = 0x10,\n  RegExp = 0x20,\n}\n\nexport const ALL_ENABLED =\n  Feature.AggregateError |\n  Feature.ArrowFunction |\n  Feature.ErrorPrototypeStack |\n  Feature.ObjectAssign |\n  Feature.BigIntTypedArray |\n  Feature.RegExp;\n", "export const SYM_ASYNC_ITERATOR: typeof Symbol.asyncIterator = Symbol.asyncIterator;\nexport const SYM_HAS_INSTANCE: typeof Symbol.hasInstance = Symbol.hasInstance;\nexport const SYM_IS_CONCAT_SPREADABLE: typeof Symbol.isConcatSpreadable = Symbol.isConcatSpreadable;\nexport const SYM_ITERATOR: typeof Symbol.iterator = Symbol.iterator;\nexport const SYM_MATCH: typeof Symbol.match = Symbol.match;\nexport const SYM_MATCH_ALL: typeof Symbol.matchAll = Symbol.matchAll;\nexport const SYM_REPLACE: typeof Symbol.replace = Symbol.replace;\nexport const SYM_SEARCH: typeof Symbol.search = Symbol.search;\nexport const SYM_SPECIES: typeof Symbol.species = Symbol.species;\nexport const SYM_SPLIT: typeof Symbol.split = Symbol.split;\nexport const SYM_TO_PRIMITIVE: typeof Symbol.toPrimitive = Symbol.toPrimitive;\nexport const SYM_TO_STRING_TAG: typeof Symbol.toStringTag = Symbol.toStringTag;\nexport const SYM_UNSCOPABLES: typeof Symbol.unscopables = Symbol.unscopables;\n\n// For the future\n\n// export const SYM_DISPOSE = Symbol.dispose;\n// export const SYM_ASYNC_DISPOSE = Symbol.asyncDispose;\n", "import {\n  SYM_ASYNC_ITERATOR,\n  SYM_HAS_INSTANCE,\n  SYM_IS_CONCAT_SPREADABLE,\n  SYM_ITERATOR,\n  SYM_MATCH,\n  SYM_MATCH_ALL,\n  SYM_REPLACE,\n  SYM_SEARCH,\n  SYM_SPECIES,\n  SYM_SPLIT,\n  SYM_TO_PRIMITIVE,\n  SYM_TO_STRING_TAG,\n  SYM_UNSCOPABLES,\n} from './symbols';\n\nexport const enum SerovalConstant {\n  Null = 0,\n  Undefined = 1,\n  True = 2,\n  False = 3,\n  NegZero = 4,\n  Inf = 5,\n  NegInf = 6,\n  Nan = 7,\n}\n\nexport const enum SerovalNodeType {\n  Number = 0,\n  String = 1,\n  Constant = 2,\n  BigInt = 3,\n  IndexedValue = 4,\n  Date = 5,\n  RegExp = 6,\n  Set = 7,\n  Map = 8,\n  Array = 9,\n  Object = 10,\n  NullConstructor = 11,\n  Promise = 12,\n  Error = 13,\n  AggregateError = 14,\n  TypedArray = 15,\n  BigIntTypedArray = 16,\n  WKSymbol = 17,\n  Reference = 18,\n  ArrayBuffer = 19,\n  DataView = 20,\n  Boxed = 21,\n  PromiseConstructor = 22,\n  PromiseSuccess = 23,\n  PromiseFailure = 24,\n  Plugin = 25,\n  SpecialReference = 26,\n  IteratorFactory = 27,\n  IteratorFactoryInstance = 28,\n  AsyncIteratorFactory = 29,\n  AsyncIteratorFactoryInstance = 30,\n  StreamConstructor = 31,\n  StreamNext = 32,\n  StreamThrow = 33,\n  StreamReturn = 34,\n}\n\nexport const enum SerovalObjectFlags {\n  None = 0,\n  NonExtensible = 1,\n  Sealed = 2,\n  Frozen = 3,\n}\n\nexport const enum Symbols {\n  AsyncIterator = 0,\n  HasInstance = 1,\n  IsConcatSpreadable = 2,\n  Iterator = 3,\n  Match = 4,\n  MatchAll = 5,\n  Replace = 6,\n  Search = 7,\n  Species = 8,\n  Split = 9,\n  ToPrimitive = 10,\n  ToStringTag = 11,\n  Unscopables = 12,\n}\n\nexport const SYMBOL_STRING: Record<Symbols, string> = {\n  [Symbols.AsyncIterator]: 'Symbol.asyncIterator',\n  [Symbols.HasInstance]: 'Symbol.hasInstance',\n  [Symbols.IsConcatSpreadable]: 'Symbol.isConcatSpreadable',\n  [Symbols.Iterator]: 'Symbol.iterator',\n  [Symbols.Match]: 'Symbol.match',\n  [Symbols.MatchAll]: 'Symbol.matchAll',\n  [Symbols.Replace]: 'Symbol.replace',\n  [Symbols.Search]: 'Symbol.search',\n  [Symbols.Species]: 'Symbol.species',\n  [Symbols.Split]: 'Symbol.split',\n  [Symbols.ToPrimitive]: 'Symbol.toPrimitive',\n  [Symbols.ToStringTag]: 'Symbol.toStringTag',\n  [Symbols.Unscopables]: 'Symbol.unscopables',\n};\n\nexport const INV_SYMBOL_REF = /* @__PURE__ */ {\n  [SYM_ASYNC_ITERATOR]: Symbols.AsyncIterator,\n  [SYM_HAS_INSTANCE]: Symbols.HasInstance,\n  [SYM_IS_CONCAT_SPREADABLE]: Symbols.IsConcatSpreadable,\n  [SYM_ITERATOR]: Symbols.Iterator,\n  [SYM_MATCH]: Symbols.Match,\n  [SYM_MATCH_ALL]: Symbols.MatchAll,\n  [SYM_REPLACE]: Symbols.Replace,\n  [SYM_SEARCH]: Symbols.Search,\n  [SYM_SPECIES]: Symbols.Species,\n  [SYM_SPLIT]: Symbols.Split,\n  [SYM_TO_PRIMITIVE]: Symbols.ToPrimitive,\n  [SYM_TO_STRING_TAG]: Symbols.ToStringTag,\n  [SYM_UNSCOPABLES]: Symbols.Unscopables,\n};\n\nexport type WellKnownSymbols = keyof typeof INV_SYMBOL_REF;\n\nexport const SYMBOL_REF: Record<Symbols, WellKnownSymbols> = {\n  [Symbols.AsyncIterator]: SYM_ASYNC_ITERATOR,\n  [Symbols.HasInstance]: SYM_HAS_INSTANCE,\n  [Symbols.IsConcatSpreadable]: SYM_IS_CONCAT_SPREADABLE,\n  [Symbols.Iterator]: SYM_ITERATOR,\n  [Symbols.Match]: SYM_MATCH,\n  [Symbols.MatchAll]: SYM_MATCH_ALL,\n  [Symbols.Replace]: SYM_REPLACE,\n  [Symbols.Search]: SYM_SEARCH,\n  [Symbols.Species]: SYM_SPECIES,\n  [Symbols.Split]: SYM_SPLIT,\n  [Symbols.ToPrimitive]: SYM_TO_PRIMITIVE,\n  [Symbols.ToStringTag]: SYM_TO_STRING_TAG,\n  [Symbols.Unscopables]: SYM_UNSCOPABLES,\n};\n\nexport const CONSTANT_STRING: Record<SerovalConstant, string> = {\n  [SerovalConstant.True]: '!0',\n  [SerovalConstant.False]: '!1',\n  [SerovalConstant.Undefined]: 'void 0',\n  [SerovalConstant.Null]: 'null',\n  [SerovalConstant.NegZero]: '-0',\n  [SerovalConstant.Inf]: '1/0',\n  [SerovalConstant.NegInf]: '-1/0',\n  [SerovalConstant.Nan]: '0/0',\n};\n\nexport const NIL = void 0;\n\nexport const CONSTANT_VAL: Record<SerovalConstant, unknown> = {\n  [SerovalConstant.True]: true,\n  [SerovalConstant.False]: false,\n  [SerovalConstant.Undefined]: NIL,\n  [SerovalConstant.Null]: null,\n  [SerovalConstant.NegZero]: -0,\n  [SerovalConstant.Inf]: Number.POSITIVE_INFINITY,\n  [SerovalConstant.NegInf]: Number.NEGATIVE_INFINITY,\n  [SerovalConstant.Nan]: Number.NaN,\n};\n\nexport const enum ErrorConstructorTag {\n  Error = 0,\n  EvalError = 1,\n  RangeError = 2,\n  ReferenceError = 3,\n  SyntaxError = 4,\n  TypeError = 5,\n  URIError = 6,\n}\n\nexport const ERROR_CONSTRUCTOR_STRING: Record<ErrorConstructorTag, string> = {\n  [ErrorConstructorTag.Error]: 'Error',\n  [ErrorConstructorTag.EvalError]: 'EvalError',\n  [ErrorConstructorTag.RangeError]: 'RangeError',\n  [ErrorConstructorTag.ReferenceError]: 'ReferenceError',\n  [ErrorConstructorTag.SyntaxError]: 'SyntaxError',\n  [ErrorConstructorTag.TypeError]: 'TypeError',\n  [ErrorConstructorTag.URIError]: 'URIError',\n};\n\ntype ErrorConstructors =\n  | ErrorConstructor\n  | EvalErrorConstructor\n  | RangeErrorConstructor\n  | ReferenceErrorConstructor\n  | SyntaxErrorConstructor\n  | TypeErrorConstructor\n  | URIErrorConstructor;\n\nexport const ERROR_CONSTRUCTOR: Record<ErrorConstructorTag, ErrorConstructors> =\n  {\n    [ErrorConstructorTag.Error]: Error,\n    [ErrorConstructorTag.EvalError]: EvalError,\n    [ErrorConstructorTag.RangeError]: RangeError,\n    [ErrorConstructorTag.ReferenceError]: ReferenceError,\n    [ErrorConstructorTag.SyntaxError]: SyntaxError,\n    [ErrorConstructorTag.TypeError]: TypeError,\n    [ErrorConstructorTag.URIError]: URIError,\n  };\n", "import type { SerovalNodeType } from './constants';\nimport type { SerovalNode } from './types';\n\ntype ExtractedNodeType<T extends SerovalNodeType> = Extract<\n  SerovalNode,\n  { t: T }\n>;\n\nexport function createSerovalNode<\n  T extends SerovalNodeType,\n  N extends ExtractedNodeType<T>,\n>(\n  t: T,\n  i: N['i'],\n  s: N['s'],\n  c: N['c'],\n  m: N['m'],\n  p: N['p'],\n  e: N['e'],\n  a: N['a'],\n  f: N['f'],\n  b: N['b'],\n  o: N['o'],\n  l: N['l'],\n): N {\n  return {\n    t,\n    i,\n    s,\n    c,\n    m,\n    p,\n    e,\n    a,\n    f,\n    b,\n    o,\n    l,\n  } as N;\n}\n", "import { NIL, SerovalConstant, SerovalNodeType } from './constants';\nimport { createSerovalNode } from './node';\nimport type { SerovalConstantNode } from './types';\n\nfunction createConstantNode(value: SerovalConstant): SerovalConstantNode {\n  return createSerovalNode(\n    SerovalNodeType.Constant,\n    NIL,\n    value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport const TRUE_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.True,\n);\nexport const FALSE_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.False,\n);\nexport const UNDEFINED_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.Undefined,\n);\nexport const NULL_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.Null,\n);\nexport const NEG_ZERO_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.NegZero,\n);\nexport const INFINITY_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.Inf,\n);\nexport const NEG_INFINITY_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.NegInf,\n);\nexport const NAN_NODE = /* @__PURE__ */ createConstantNode(SerovalConstant.Nan);\n", "import { NIL } from './constants';\n\nexport function serializeChar(str: string): string | undefined {\n  switch (str) {\n    case '\"':\n      return '\\\\\"';\n    case '\\\\':\n      return '\\\\\\\\';\n    case '\\n':\n      return '\\\\n';\n    case '\\r':\n      return '\\\\r';\n    case '\\b':\n      return '\\\\b';\n    case '\\t':\n      return '\\\\t';\n    case '\\f':\n      return '\\\\f';\n    case '<':\n      return '\\\\x3C';\n    case '\\u2028':\n      return '\\\\u2028';\n    case '\\u2029':\n      return '\\\\u2029';\n    default:\n      return NIL;\n  }\n}\n\n// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\n// Creates a JavaScript double quoted string and escapes all characters\n// not listed as DoubleStringCharacters on\n// Also includes \"<\" to escape \"</script>\" and \"\\\" to avoid invalid escapes in the output.\n// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\nexport function serializeString(str: string): string {\n  let result = '';\n  let lastPos = 0;\n  let replacement: string | undefined;\n  for (let i = 0, len = str.length; i < len; i++) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return result;\n}\n\nfunction deserializeReplacer(str: string): string {\n  switch (str) {\n    case '\\\\\\\\':\n      return '\\\\';\n    case '\\\\\"':\n      return '\"';\n    case '\\\\n':\n      return '\\n';\n    case '\\\\r':\n      return '\\r';\n    case '\\\\b':\n      return '\\b';\n    case '\\\\t':\n      return '\\t';\n    case '\\\\f':\n      return '\\f';\n    case '\\\\x3C':\n      return '\\x3C';\n    case '\\\\u2028':\n      return '\\u2028';\n    case '\\\\u2029':\n      return '\\u2029';\n    default:\n      return str;\n  }\n}\n\nexport function deserializeString(str: string): string {\n  return str.replace(\n    /(\\\\\\\\|\\\\\"|\\\\n|\\\\r|\\\\b|\\\\t|\\\\f|\\\\u2028|\\\\u2029|\\\\x3C)/g,\n    deserializeReplacer,\n  );\n}\n", "import { serializeString } from './string';\n\n// Used for mapping isomorphic references\nexport const REFERENCES_KEY = '__SEROVAL_REFS__';\n\nexport const GLOBAL_CONTEXT_REFERENCES = '$R';\n\nconst GLOBAL_CONTEXT_R = `self.${GLOBAL_CONTEXT_REFERENCES}`;\n\nexport function getCrossReferenceHeader(id?: string): string {\n  if (id == null) {\n    return `${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||[]`;\n  }\n  return `(${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||{})[\"${serializeString(\n    id,\n  )}\"]=[]`;\n}\n", "import {\n  SerovalMissingReferenceError,\n  SerovalMissingReferenceForIdError,\n} from '..';\nimport { REFERENCES_KEY } from './keys';\n\nconst REFERENCE = new Map<unknown, string>();\nconst INV_REFERENCE = new Map<string, unknown>();\n\nexport function createReference<T>(id: string, value: T): T {\n  REFERENCE.set(value, id);\n  INV_REFERENCE.set(id, value);\n  return value;\n}\n\nexport function hasReferenceID<T>(value: T): boolean {\n  return REFERENCE.has(value);\n}\n\nexport function hasReference(id: string): boolean {\n  return INV_REFERENCE.has(id);\n}\n\nexport function getReferenceID<T>(value: T): string {\n  if (hasReferenceID(value)) {\n    return REFERENCE.get(value)!;\n  }\n  throw new SerovalMissingReferenceError(value);\n}\n\nexport function getReference<T>(id: string): T {\n  if (hasReference(id)) {\n    return INV_REFERENCE.get(id) as T;\n  }\n  throw new SerovalMissingReferenceForIdError(id);\n}\n\nif (typeof globalThis !== 'undefined') {\n  Object.defineProperty(globalThis, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof window !== 'undefined') {\n  Object.defineProperty(window, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof self !== 'undefined') {\n  Object.defineProperty(self, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof global !== 'undefined') {\n  Object.defineProperty(global, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n}\n", "import { Feature } from '../compat';\nimport { ERROR_CONSTRUCTOR_STRING, ErrorConstructorTag } from '../constants';\n\ntype ErrorValue =\n  | Error\n  | AggregateError\n  | EvalError\n  | RangeError\n  | ReferenceError\n  | TypeError\n  | SyntaxError\n  | URIError;\n\nexport function getErrorConstructor(error: ErrorValue): ErrorConstructorTag {\n  if (error instanceof EvalError) {\n    return ErrorConstructorTag.EvalError;\n  }\n  if (error instanceof RangeError) {\n    return ErrorConstructorTag.RangeError;\n  }\n  if (error instanceof ReferenceError) {\n    return ErrorConstructorTag.ReferenceError;\n  }\n  if (error instanceof SyntaxError) {\n    return ErrorConstructorTag.SyntaxError;\n  }\n  if (error instanceof TypeError) {\n    return ErrorConstructorTag.TypeError;\n  }\n  if (error instanceof URIError) {\n    return ErrorConstructorTag.URIError;\n  }\n  return ErrorConstructorTag.Error;\n}\n\nfunction getInitialErrorOptions(\n  error: Error,\n): Record<string, unknown> | undefined {\n  const construct = ERROR_CONSTRUCTOR_STRING[getErrorConstructor(error)];\n  // Name has been modified\n  if (error.name !== construct) {\n    return { name: error.name };\n  }\n  if (error.constructor.name !== construct) {\n    // Otherwise, name is overriden because\n    // the Error class is extended\n    return { name: error.constructor.name };\n  }\n  return {};\n}\n\nexport function getErrorOptions(\n  error: Error,\n  features: number,\n): Record<string, unknown> | undefined {\n  let options = getInitialErrorOptions(error);\n  const names = Object.getOwnPropertyNames(error);\n  for (let i = 0, len = names.length, name: string; i < len; i++) {\n    name = names[i];\n    if (name !== 'name' && name !== 'message') {\n      if (name === 'stack') {\n        if (features & Feature.ErrorPrototypeStack) {\n          options = options || {};\n          options[name] = error[name as keyof Error];\n        }\n      } else {\n        options = options || {};\n        options[name] = error[name as keyof Error];\n      }\n    }\n  }\n  return options;\n}\n", "import { SerovalObjectFlags } from '../constants';\n\nexport function getObjectFlag(obj: unknown): SerovalObjectFlags {\n  if (Object.isFrozen(obj)) {\n    return SerovalObjectFlags.Frozen;\n  }\n  if (Object.isSealed(obj)) {\n    return SerovalObjectFlags.Sealed;\n  }\n  if (Object.isExtensible(obj)) {\n    return SerovalObjectFlags.None;\n  }\n  return SerovalObjectFlags.NonExtensible;\n}\n", "import type { WellKnownSymbols } from './constants';\nimport { INV_SYMBOL_REF, NIL, SerovalNodeType } from './constants';\nimport {\n  INFINITY_NODE,\n  NAN_NODE,\n  NEG_INFINITY_NODE,\n  NEG_ZERO_NODE,\n} from './literals';\nimport { createSerovalNode } from './node';\nimport { getReferenceID } from './reference';\nimport { serializeString } from './string';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalAsyncIteratorFactoryInstanceNode,\n  SerovalBigIntNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalConstantNode,\n  SerovalDataViewNode,\n  SerovalDateNode,\n  SerovalErrorNode,\n  SerovalIndexedValueNode,\n  SerovalIteratorFactoryInstanceNode,\n  SerovalNode,\n  SerovalNodeWithID,\n  SerovalNumberNode,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalSetNode,\n  SerovalStreamConstructorNode,\n  SerovalStreamNextNode,\n  SerovalStreamReturnNode,\n  SerovalStreamThrowNode,\n  SerovalStringNode,\n  SerovalTypedArrayNode,\n  SerovalWKSymbolNode,\n} from './types';\nimport { getErrorConstructor } from './utils/error';\nimport { getObjectFlag } from './utils/get-object-flag';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from './utils/typed-array';\n\nexport function createNumberNode(\n  value: number,\n): SerovalConstantNode | SerovalNumberNode {\n  switch (value) {\n    case Number.POSITIVE_INFINITY:\n      return INFINITY_NODE;\n    case Number.NEGATIVE_INFINITY:\n      return NEG_INFINITY_NODE;\n  }\n  if (value !== value) {\n    return NAN_NODE;\n  }\n  if (Object.is(value, -0)) {\n    return NEG_ZERO_NODE;\n  }\n  return createSerovalNode(\n    SerovalNodeType.Number,\n    NIL,\n    value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStringNode(value: string): SerovalStringNode {\n  return createSerovalNode(\n    SerovalNodeType.String,\n    NIL,\n    serializeString(value),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createBigIntNode(current: bigint): SerovalBigIntNode {\n  return createSerovalNode(\n    SerovalNodeType.BigInt,\n    NIL,\n    '' + current,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createIndexedValueNode(id: number): SerovalIndexedValueNode {\n  return createSerovalNode(\n    SerovalNodeType.IndexedValue,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createDateNode(id: number, current: Date): SerovalDateNode {\n  const timestamp = current.valueOf();\n  return createSerovalNode(\n    SerovalNodeType.Date,\n    id,\n    timestamp !== timestamp ? '' : current.toISOString(),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createRegExpNode(\n  id: number,\n  current: RegExp,\n): SerovalRegExpNode {\n  return createSerovalNode(\n    SerovalNodeType.RegExp,\n    id,\n    NIL,\n    serializeString(current.source),\n    current.flags,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createWKSymbolNode(\n  id: number,\n  current: WellKnownSymbols,\n): SerovalWKSymbolNode {\n  return createSerovalNode(\n    SerovalNodeType.WKSymbol,\n    id,\n    INV_SYMBOL_REF[current],\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createReferenceNode<T>(\n  id: number,\n  ref: T,\n): SerovalReferenceNode {\n  return createSerovalNode(\n    SerovalNodeType.Reference,\n    id,\n    serializeString(getReferenceID(ref)),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createPluginNode(\n  id: number,\n  tag: string,\n  value: unknown,\n): SerovalPluginNode {\n  return createSerovalNode(\n    SerovalNodeType.Plugin,\n    id,\n    value,\n    serializeString(tag),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createArrayNode(\n  id: number,\n  current: unknown[],\n  parsedItems: SerovalArrayNode['a'],\n): SerovalArrayNode {\n  return createSerovalNode(\n    SerovalNodeType.Array,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsedItems,\n    NIL,\n    NIL,\n    getObjectFlag(current),\n    NIL,\n  );\n}\n\nexport function createBoxedNode(\n  id: number,\n  boxed: SerovalNode,\n): SerovalBoxedNode {\n  return createSerovalNode(\n    SerovalNodeType.Boxed,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    boxed,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createTypedArrayNode(\n  id: number,\n  current: TypedArrayValue,\n  buffer: SerovalNode,\n): SerovalTypedArrayNode {\n  return createSerovalNode(\n    SerovalNodeType.TypedArray,\n    id,\n    NIL,\n    current.constructor.name,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n    current.length,\n  );\n}\n\nexport function createBigIntTypedArrayNode(\n  id: number,\n  current: BigIntTypedArrayValue,\n  buffer: SerovalNode,\n): SerovalBigIntTypedArrayNode {\n  return createSerovalNode(\n    SerovalNodeType.BigIntTypedArray,\n    id,\n    NIL,\n    current.constructor.name,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n    current.byteLength,\n  );\n}\n\nexport function createDataViewNode(\n  id: number,\n  current: DataView,\n  buffer: SerovalNode,\n): SerovalDataViewNode {\n  return createSerovalNode(\n    SerovalNodeType.DataView,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n    current.byteLength,\n  );\n}\n\nexport function createErrorNode(\n  id: number,\n  current: Error,\n  options: SerovalObjectRecordNode | undefined,\n): SerovalErrorNode {\n  return createSerovalNode(\n    SerovalNodeType.Error,\n    id,\n    getErrorConstructor(current),\n    NIL,\n    serializeString(current.message),\n    options,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createAggregateErrorNode(\n  id: number,\n  current: AggregateError,\n  options: SerovalObjectRecordNode | undefined,\n): SerovalAggregateErrorNode {\n  return createSerovalNode(\n    SerovalNodeType.AggregateError,\n    id,\n    getErrorConstructor(current),\n    NIL,\n    serializeString(current.message),\n    options,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createSetNode(\n  id: number,\n  items: SerovalNode[],\n): SerovalSetNode {\n  return createSerovalNode(\n    SerovalNodeType.Set,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    items,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createIteratorFactoryInstanceNode(\n  factory: SerovalNodeWithID,\n  items: SerovalNode,\n): SerovalIteratorFactoryInstanceNode {\n  return createSerovalNode(\n    SerovalNodeType.IteratorFactoryInstance,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [factory, items],\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createAsyncIteratorFactoryInstanceNode(\n  factory: SerovalNodeWithID,\n  items: SerovalNode,\n): SerovalAsyncIteratorFactoryInstanceNode {\n  return createSerovalNode(\n    SerovalNodeType.AsyncIteratorFactoryInstance,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [factory, items],\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamConstructorNode(\n  id: number,\n  factory: SerovalNodeWithID,\n  sequence: SerovalNode[],\n): SerovalStreamConstructorNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamConstructor,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    sequence,\n    factory,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamNextNode(\n  id: number,\n  parsed: SerovalNode,\n): SerovalStreamNextNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamNext,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamThrowNode(\n  id: number,\n  parsed: SerovalNode,\n): SerovalStreamThrowNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamThrow,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamReturnNode(\n  id: number,\n  parsed: SerovalNode,\n): SerovalStreamReturnNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamReturn,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n", "/// <reference types=\"pridepack/env\" />\n\nimport { serializeString } from './string';\nimport type { SerovalNode } from './types';\n\nconst { toString: objectToString } = /* @__PURE__ */ Object.prototype;\n\nconst enum StepErrorCodes {\n  Parse = 1,\n  Serialize = 2,\n  Deserialize = 3,\n}\n\nfunction getErrorMessageDev(type: string, cause: any): string {\n  if (cause instanceof Error) {\n    return `Seroval caught an error during the ${type} process.\n  \n${cause.name}\n${cause.message}\n\n- For more information, please check the \"cause\" property of this error.\n- If you believe this is an error in Seroval, please submit an issue at https://github.com/lxsmnsyc/seroval/issues/new`;\n  }\n  return `Seroval caught an error during the ${type} process.\n\n\"${objectToString.call(cause)}\"\n\nFor more information, please check the \"cause\" property of this error.`;\n}\n\nconst STEP_ERROR_CODES: Record<string, StepErrorCodes> = {\n  parsing: StepErrorCodes.Parse,\n  serialization: StepErrorCodes.Serialize,\n  deserialization: StepErrorCodes.Deserialize,\n};\n\nfunction getErrorMessageProd(type: string): string {\n  return `Seroval Error (step: ${STEP_ERROR_CODES[type]})`;\n}\n\nconst getErrorMessage = (type: string, cause: any) =>\n  import.meta.env.PROD\n    ? getErrorMessageProd(type)\n    : getErrorMessageDev(type, cause);\n\nexport class SerovalError extends Error {\n  constructor(\n    type: string,\n    public cause: any,\n  ) {\n    super(getErrorMessage(type, cause));\n  }\n}\n\nexport class SerovalParserError extends SerovalError {\n  constructor(cause: any) {\n    super('parsing', cause);\n  }\n}\n\nexport class SerovalSerializationError extends SerovalError {\n  constructor(cause: any) {\n    super('serialization', cause);\n  }\n}\n\nexport class SerovalDeserializationError extends SerovalError {\n  constructor(cause: any) {\n    super('deserialization', cause);\n  }\n}\n\nconst enum SpecificErrorCodes {\n  UnsupportedType = 1,\n  UnsupportedNode = 2,\n  MissingPlugin = 3,\n  MissingInstance = 4,\n  MissingReference = 5,\n  MissingReferenceForId = 6,\n  UnknownTypedArray = 7,\n  MalformedNode = 8,\n  ConflictedNodeId = 9,\n  DepthLimit = 10,\n}\n\nfunction getSpecificErrorMessage(code: SpecificErrorCodes): string {\n  return `Seroval Error (specific: ${code})`;\n}\n\nexport class SerovalUnsupportedTypeError extends Error {\n  constructor(public value: unknown) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.UnsupportedType)\n        : `The value ${objectToString.call(value)} of type \"${typeof value}\" cannot be parsed/serialized.\n      \nThere are few workarounds for this problem:\n- Transform the value in a way that it can be serialized.\n- If the reference is present on multiple runtimes (isomorphic), you can use the Reference API to map the references.`,\n    );\n  }\n}\n\nexport class SerovalUnsupportedNodeError extends Error {\n  constructor(node: SerovalNode) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.UnsupportedNode)\n        : 'Unsupported node type \"' + node.t + '\".',\n    );\n  }\n}\n\nexport class SerovalMissingPluginError extends Error {\n  constructor(tag: string) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.MissingPlugin)\n        : 'Missing plugin for tag \"' + tag + '\".',\n    );\n  }\n}\n\nexport class SerovalMissingInstanceError extends Error {\n  constructor(tag: string) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.MissingInstance)\n        : 'Missing \"' + tag + '\" instance.',\n    );\n  }\n}\n\nexport class SerovalMissingReferenceError extends Error {\n  constructor(public value: unknown) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.MissingReference)\n        : 'Missing reference for the value \"' +\n            objectToString.call(value) +\n            '\" of type \"' +\n            typeof value +\n            '\"',\n    );\n  }\n}\n\nexport class SerovalMissingReferenceForIdError extends Error {\n  constructor(id: string) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.MissingReferenceForId)\n        : 'Missing reference for id \"' + serializeString(id) + '\"',\n    );\n  }\n}\n\nexport class SerovalUnknownTypedArrayError extends Error {\n  constructor(name: string) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.UnknownTypedArray)\n        : 'Unknown TypedArray \"' + name + '\"',\n    );\n  }\n}\n\nexport class SerovalMalformedNodeError extends Error {\n  constructor(node: SerovalNode) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.MalformedNode)\n        : 'Malformed node type \"' + node.t + '\".',\n    );\n  }\n}\n\nexport class SerovalConflictedNodeIdError extends Error {\n  constructor(node: SerovalNode) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.ConflictedNodeId)\n        : 'Conflicted node id \"' + node.i + '\".',\n    );\n  }\n}\n\nexport class SerovalDepthLimitError extends Error {\n  constructor(limit: number) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.ConflictedNodeId)\n        : 'Depth limit of ' + limit + ' reached',\n    );\n  }\n}\n", "/**\n * An opaque reference allows hiding values from the serializer.\n */\nexport class OpaqueReference<V, R = undefined> {\n  constructor(\n    public readonly value: V,\n    public readonly replacement?: R,\n  ) {}\n}\n", "import type { Stream } from './stream';\n\ntype SpecialPromise = Promise<unknown> & { s?: 1 | 2; v?: unknown };\n\nexport interface PromiseConstructorResolver {\n  p: SpecialPromise;\n  s: (value: unknown) => void;\n  f: (value: unknown) => void;\n}\n\nexport const PROMISE_CONSTRUCTOR = (): PromiseConstructorResolver => {\n  const resolver = {\n    p: 0,\n    s: 0,\n    f: 0,\n  } as unknown as PromiseConstructorResolver;\n  resolver.p = new Promise((resolve, reject) => {\n    resolver.s = resolve;\n    resolver.f = reject;\n  });\n  return resolver;\n};\n\nexport const PROMISE_SUCCESS = (\n  resolver: PromiseConstructorResolver,\n  data: unknown,\n): void => {\n  resolver.s(data);\n  resolver.p.s = 1;\n  resolver.p.v = data;\n};\n\nexport const PROMISE_FAILURE = (\n  resolver: PromiseConstructorResolver,\n  data: unknown,\n): void => {\n  resolver.f(data);\n  resolver.p.s = 2;\n  resolver.p.v = data;\n};\n\nexport const SERIALIZED_PROMISE_CONSTRUCTOR =\n  /* @__PURE__ */ PROMISE_CONSTRUCTOR.toString();\nexport const SERIALIZED_PROMISE_SUCCESS =\n  /* @__PURE__ */ PROMISE_SUCCESS.toString();\nexport const SERIALIZED_PROMISE_FAILURE =\n  /* @__PURE__ */ PROMISE_FAILURE.toString();\n\ninterface StreamListener<T> {\n  next(value: T): void;\n  throw(value: unknown): void;\n  return(value: T): void;\n}\n\nexport const STREAM_CONSTRUCTOR = () => {\n  const buffer: unknown[] = [];\n  const listeners: StreamListener<unknown>[] = [];\n  let alive = true;\n  let success = false;\n  let count = 0;\n  const flush = (\n    value: unknown,\n    mode: keyof StreamListener<unknown>,\n    x?: number,\n  ) => {\n    for (x = 0; x < count; x++) {\n      if (listeners[x]) {\n        listeners[x][mode](value);\n      }\n    }\n  };\n  const up = (\n    listener: StreamListener<unknown>,\n    x?: number,\n    z?: number,\n    current?: unknown,\n  ) => {\n    for (x = 0, z = buffer.length; x < z; x++) {\n      current = buffer[x];\n      if (!alive && x === z - 1) {\n        listener[success ? 'return' : 'throw'](current);\n      } else {\n        listener.next(current);\n      }\n    }\n  };\n  const on = (listener: StreamListener<unknown>, temp?: number) => {\n    if (alive) {\n      temp = count++;\n      listeners[temp] = listener;\n    }\n    up(listener);\n    return () => {\n      if (alive) {\n        listeners[temp!] = listeners[count];\n        listeners[count--] = undefined as any;\n      }\n    };\n  };\n  return {\n    __SEROVAL_STREAM__: true,\n    on: (listener: StreamListener<unknown>) => on(listener),\n    next: (value: unknown) => {\n      if (alive) {\n        buffer.push(value);\n        flush(value, 'next');\n      }\n    },\n    throw: (value: unknown) => {\n      if (alive) {\n        buffer.push(value);\n        flush(value, 'throw');\n        alive = false;\n        success = false;\n        listeners.length = 0;\n      }\n    },\n    return: (value: unknown) => {\n      if (alive) {\n        buffer.push(value);\n        flush(value, 'return');\n        alive = false;\n        success = true;\n        listeners.length = 0;\n      }\n    },\n  };\n};\n\nexport const SERIALIZED_STREAM_CONSTRUCTOR =\n  /* @__PURE__ */ STREAM_CONSTRUCTOR.toString();\n\nexport interface Sequence {\n  v: unknown[];\n  t: number;\n  d: number;\n}\n\nexport const ITERATOR_CONSTRUCTOR =\n  (symbol: symbol) => (sequence: Sequence) => () => {\n    let index = 0;\n    const instance = {\n      [symbol]: () => instance,\n      next: () => {\n        if (index > sequence.d) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n        const currentIndex = index++;\n        const data = sequence.v[currentIndex];\n        if (currentIndex === sequence.t) {\n          throw data;\n        }\n        return {\n          done: currentIndex === sequence.d,\n          value: data,\n        };\n      },\n    };\n    return instance;\n  };\n\nexport const SERIALIZED_ITERATOR_CONSTRUCTOR =\n  /* @__PURE__ */ ITERATOR_CONSTRUCTOR.toString();\n\nexport const ASYNC_ITERATOR_CONSTRUCTOR =\n  (symbol: symbol, createPromise: typeof PROMISE_CONSTRUCTOR) =>\n  (stream: Stream<unknown>) =>\n  () => {\n    let count = 0;\n    let doneAt = -1;\n    let isThrow = false;\n    const buffer: unknown[] = [];\n    const pending: PromiseConstructorResolver[] = [];\n    const finalize = (i = 0, len = pending.length) => {\n      for (; i < len; i++) {\n        pending[i].s({\n          done: true,\n          value: undefined,\n        });\n      }\n    };\n    stream.on({\n      next: value => {\n        const temp = pending.shift();\n        if (temp) {\n          temp.s({ done: false, value });\n        }\n        buffer.push(value);\n      },\n      throw: value => {\n        const temp = pending.shift();\n        if (temp) {\n          temp.f(value);\n        }\n        finalize();\n        doneAt = buffer.length;\n        isThrow = true;\n        buffer.push(value);\n      },\n      return: value => {\n        const temp = pending.shift();\n        if (temp) {\n          temp.s({ done: true, value });\n        }\n        finalize();\n        doneAt = buffer.length;\n        buffer.push(value);\n      },\n    });\n\n    const instance = {\n      [symbol]: () => instance,\n      next: () => {\n        if (doneAt === -1) {\n          const index = count++;\n          if (index >= buffer.length) {\n            const temp = createPromise();\n            pending.push(temp);\n            return temp.p;\n          }\n          return {\n            done: false,\n            value: buffer[index],\n          };\n        }\n        if (count > doneAt) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n        const index = count++;\n        const value = buffer[index];\n        if (index !== doneAt) {\n          return {\n            done: false,\n            value,\n          };\n        }\n        if (isThrow) {\n          throw value;\n        }\n        return {\n          done: true,\n          value,\n        };\n      },\n    };\n\n    return instance;\n  };\n\nexport const SERIALIZED_ASYNC_ITERATOR_CONSTRUCTOR =\n  /* @__PURE__ */ ASYNC_ITERATOR_CONSTRUCTOR.toString();\n\nexport const ARRAY_BUFFER_CONSTRUCTOR = (b64: string) => {\n  const decoded = atob(b64);\n  const length = decoded.length;\n  const arr = new Uint8Array(length);\n  for (let i = 0; i < length; i++) {\n    arr[i] = decoded.charCodeAt(i);\n  }\n  return arr.buffer;\n};\n\nexport const SERIALIZED_ARRAY_BUFFER_CONSTRUCTOR =\n  /* @__PURE__ */ ARRAY_BUFFER_CONSTRUCTOR.toString();\n", "import {\n  SERIALIZED_ARRAY_BUFFER_CONSTRUCTOR,\n  SERIALIZED_PROMISE_CONSTRUCTOR,\n  SERIALIZED_PROMISE_FAILURE,\n  SERIALIZED_PROMISE_SUCCESS,\n  SERIALIZED_STREAM_CONSTRUCTOR,\n} from './constructors';\n\nexport const ITERATOR = {};\n\nexport const ASYNC_ITERATOR = {};\n\nexport const enum SpecialReference {\n  MapSentinel = 0,\n  PromiseConstructor = 1,\n  PromiseSuccess = 2,\n  PromiseFailure = 3,\n  StreamConstructor = 4,\n  ArrayBufferConstructor = 5,\n}\n\n/**\n * Placeholder references\n */\nexport const SPECIAL_REFS: Record<SpecialReference, unknown> = {\n  [SpecialReference.MapSentinel]: {},\n  [SpecialReference.PromiseConstructor]: {},\n  [SpecialReference.PromiseSuccess]: {},\n  [SpecialReference.PromiseFailure]: {},\n  [SpecialReference.StreamConstructor]: {},\n  [SpecialReference.ArrayBufferConstructor]: {},\n};\n\nexport const SPECIAL_REF_STRING: Record<SpecialReference, string> = {\n  [SpecialReference.MapSentinel]: '[]',\n  [SpecialReference.PromiseConstructor]: SERIALIZED_PROMISE_CONSTRUCTOR,\n  [SpecialReference.PromiseSuccess]: SERIALIZED_PROMISE_SUCCESS,\n  [SpecialReference.PromiseFailure]: SERIALIZED_PROMISE_FAILURE,\n  [SpecialReference.StreamConstructor]: SERIALIZED_STREAM_CONSTRUCTOR,\n  [SpecialReference.ArrayBufferConstructor]:\n    SERIALIZED_ARRAY_BUFFER_CONSTRUCTOR,\n};\n", "import {\n  ASYNC_ITERATOR_CONSTRUCTOR,\n  PROMISE_CONSTRUCTOR,\n  STREAM_CONSTRUCTOR,\n} from './constructors';\nimport { SYM_ASYNC_ITERATOR } from './symbols';\n\nexport interface StreamListener<T> {\n  next(value: T): void;\n  throw(value: unknown): void;\n  return(value: T): void;\n}\n\nexport interface Stream<T> {\n  __SEROVAL_STREAM__: true;\n\n  on(listener: StreamListener<T>): () => void;\n\n  next(value: T): void;\n  throw(value: unknown): void;\n  return(value: T): void;\n}\n\nexport function isStream<T>(value: object): value is Stream<T> {\n  return '__SEROVAL_STREAM__' in value;\n}\n\nexport function createStream<T>(): Stream<T> {\n  return STREAM_CONSTRUCTOR() as unknown as Stream<T>;\n}\n\nexport function createStreamFromAsyncIterable<T>(\n  iterable: AsyncIterable<T>,\n): Stream<T> {\n  const stream = createStream<T>();\n\n  const iterator = iterable[SYM_ASYNC_ITERATOR]();\n\n  async function push(): Promise<void> {\n    try {\n      const value = await iterator.next();\n      if (value.done) {\n        stream.return(value.value as T);\n      } else {\n        stream.next(value.value);\n        await push();\n      }\n    } catch (error) {\n      stream.throw(error);\n    }\n  }\n\n  push().catch(() => {\n    // no-op\n  });\n\n  return stream;\n}\n\nconst createAsyncIterable = ASYNC_ITERATOR_CONSTRUCTOR(\n  SYM_ASYNC_ITERATOR,\n  PROMISE_CONSTRUCTOR,\n);\n\nexport function streamToAsyncIterable<T>(\n  stream: Stream<T>,\n): () => AsyncIterableIterator<T> {\n  return createAsyncIterable(\n    stream,\n  ) as unknown as () => AsyncIterableIterator<T>;\n}\n", "import { ITERATOR_CONSTRUCTOR } from '../constructors';\nimport { SYM_ITERATOR } from '../symbols';\n\nexport interface Sequence {\n  v: unknown[];\n  t: number;\n  d: number;\n}\n\nexport function iteratorToSequence<T>(source: Iterable<T>): Sequence {\n  const values: unknown[] = [];\n  let throwsAt = -1;\n  let doneAt = -1;\n\n  const iterator = source[SYM_ITERATOR]();\n\n  while (true) {\n    try {\n      const value = iterator.next();\n      values.push(value.value);\n      if (value.done) {\n        doneAt = values.length - 1;\n        break;\n      }\n    } catch (error) {\n      throwsAt = values.length;\n      values.push(error);\n    }\n  }\n\n  return {\n    v: values,\n    t: throwsAt,\n    d: doneAt,\n  };\n}\n\nconst createIterator = ITERATOR_CONSTRUCTOR(SYM_ITERATOR);\n\nexport function sequenceToIterator<T>(\n  sequence: Sequence,\n): () => IterableIterator<T> {\n  return createIterator(sequence) as unknown as () => IterableIterator<T>;\n}\n", "export default async function promiseToResult(\n  current: Promise<unknown>,\n): Promise<[0 | 1, unknown]> {\n  try {\n    return [1, await current];\n  } catch (e) {\n    return [0, e];\n  }\n}\n", "import {\n  createIndexedValueNode,\n  createReferenceNode,\n  createWKSymbolNode,\n} from '../base-primitives';\nimport { ALL_ENABLED } from '../compat';\nimport type { WellKnownSymbols } from '../constants';\nimport { INV_SYMBOL_REF, NIL, SerovalNodeType } from '../constants';\nimport { SerovalUnsupportedTypeError } from '../errors';\nimport { createSerovalNode } from '../node';\nimport type { PluginAccessOptions, SerovalMode } from '../plugin';\nimport { hasReferenceID } from '../reference';\nimport {\n  ASYNC_ITERATOR,\n  ITERATOR,\n  SPECIAL_REFS,\n  SpecialReference,\n} from '../special-reference';\nimport { serializeString } from '../string';\nimport { SYM_ASYNC_ITERATOR, SYM_ITERATOR } from '../symbols';\nimport type {\n  SerovalArrayBufferNode,\n  SerovalAsyncIteratorFactoryNode,\n  SerovalIndexedValueNode,\n  SerovalIteratorFactoryNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordNode,\n  SerovalPromiseConstructorNode,\n  SerovalReferenceNode,\n  SerovalSpecialReferenceNode,\n  SerovalWKSymbolNode,\n} from '../types';\nimport { getObjectFlag } from '../utils/get-object-flag';\n\nexport interface BaseParserContextOptions extends PluginAccessOptions {\n  disabledFeatures?: number;\n  refs?: Map<unknown, number>;\n  depthLimit?: number;\n}\n\nexport const enum ParserNodeType {\n  Fresh = 0,\n  Indexed = 1,\n  Referenced = 2,\n}\n\nexport interface FreshNode {\n  type: ParserNodeType.Fresh;\n  value: number;\n}\n\nexport interface IndexedNode {\n  type: ParserNodeType.Indexed;\n  value: SerovalIndexedValueNode;\n}\n\nexport interface ReferencedNode {\n  type: ParserNodeType.Referenced;\n  value: SerovalReferenceNode;\n}\n\ntype ObjectNode = FreshNode | IndexedNode | ReferencedNode;\n\nexport interface BaseParserContext extends PluginAccessOptions {\n  readonly mode: SerovalMode;\n\n  marked: Set<number>;\n\n  refs: Map<unknown, number>;\n\n  features: number;\n\n  depthLimit: number;\n}\n\nexport function createBaseParserContext(\n  mode: SerovalMode,\n  options: BaseParserContextOptions,\n): BaseParserContext {\n  return {\n    plugins: options.plugins,\n    mode,\n    marked: new Set(),\n    features: ALL_ENABLED ^ (options.disabledFeatures || 0),\n    refs: options.refs || new Map(),\n    depthLimit: options.depthLimit || 1000,\n  };\n}\n\n/**\n * Ensures that the value (based on an identifier) has been visited by the parser.\n * @param ctx\n * @param id\n */\nexport function markParserRef(ctx: BaseParserContext, id: number): void {\n  ctx.marked.add(id);\n}\n\nexport function isParserRefMarked(ctx: BaseParserContext, id: number): boolean {\n  return ctx.marked.has(id);\n}\n\n/**\n * Creates an identifier for a value\n * @param ctx\n * @param current\n */\nexport function createIndexForValue<T>(\n  ctx: BaseParserContext,\n  current: T,\n): number {\n  const id = ctx.refs.size;\n  ctx.refs.set(current, id);\n  return id;\n}\n\nexport function getNodeForIndexedValue<T>(\n  ctx: BaseParserContext,\n  current: T,\n): FreshNode | IndexedNode {\n  const registeredId = ctx.refs.get(current);\n  if (registeredId != null) {\n    markParserRef(ctx, registeredId);\n    return {\n      type: ParserNodeType.Indexed,\n      value: createIndexedValueNode(registeredId),\n    };\n  }\n  return {\n    type: ParserNodeType.Fresh,\n    value: createIndexForValue(ctx, current),\n  };\n}\n\nexport function getReferenceNode<T>(\n  ctx: BaseParserContext,\n  current: T,\n): ObjectNode {\n  const indexed = getNodeForIndexedValue(ctx, current);\n  if (indexed.type === ParserNodeType.Indexed) {\n    return indexed;\n  }\n  // Special references are special ;)\n  if (hasReferenceID(current)) {\n    return {\n      type: ParserNodeType.Referenced,\n      value: createReferenceNode(indexed.value, current),\n    };\n  }\n  return indexed;\n}\n\n/**\n * Parsing methods\n */\nexport function parseWellKnownSymbol(\n  ctx: BaseParserContext,\n  current: symbol,\n): SerovalIndexedValueNode | SerovalWKSymbolNode | SerovalReferenceNode {\n  const ref = getReferenceNode(ctx, current);\n  if (ref.type !== ParserNodeType.Fresh) {\n    return ref.value;\n  }\n  if (current in INV_SYMBOL_REF) {\n    return createWKSymbolNode(ref.value, current as WellKnownSymbols);\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\n\nexport function parseSpecialReference(\n  ctx: BaseParserContext,\n  ref: SpecialReference,\n): SerovalIndexedValueNode | SerovalSpecialReferenceNode {\n  const result = getNodeForIndexedValue(ctx, SPECIAL_REFS[ref]);\n  if (result.type === ParserNodeType.Indexed) {\n    return result.value;\n  }\n  return createSerovalNode(\n    SerovalNodeType.SpecialReference,\n    result.value,\n    ref,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function parseIteratorFactory(\n  ctx: BaseParserContext,\n): SerovalIndexedValueNode | SerovalIteratorFactoryNode {\n  const result = getNodeForIndexedValue(ctx, ITERATOR);\n  if (result.type === ParserNodeType.Indexed) {\n    return result.value;\n  }\n  return createSerovalNode(\n    SerovalNodeType.IteratorFactory,\n    result.value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parseWellKnownSymbol(ctx, SYM_ITERATOR),\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function parseAsyncIteratorFactory(\n  ctx: BaseParserContext,\n): SerovalIndexedValueNode | SerovalAsyncIteratorFactoryNode {\n  const result = getNodeForIndexedValue(ctx, ASYNC_ITERATOR);\n  if (result.type === ParserNodeType.Indexed) {\n    return result.value;\n  }\n  return createSerovalNode(\n    SerovalNodeType.AsyncIteratorFactory,\n    result.value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [\n      parseSpecialReference(ctx, SpecialReference.PromiseConstructor),\n      parseWellKnownSymbol(ctx, SYM_ASYNC_ITERATOR),\n    ],\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createObjectNode(\n  id: number,\n  current: Record<string, unknown>,\n  empty: boolean,\n  record: SerovalObjectRecordNode,\n): SerovalObjectNode | SerovalNullConstructorNode {\n  return createSerovalNode(\n    empty ? SerovalNodeType.NullConstructor : SerovalNodeType.Object,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    record,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    getObjectFlag(current),\n    NIL,\n  );\n}\n\nexport function createMapNode(\n  ctx: BaseParserContext,\n  id: number,\n  k: SerovalNode[],\n  v: SerovalNode[],\n): SerovalMapNode {\n  return createSerovalNode(\n    SerovalNodeType.Map,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    { k, v },\n    NIL,\n    parseSpecialReference(ctx, SpecialReference.MapSentinel),\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createPromiseConstructorNode(\n  ctx: BaseParserContext,\n  id: number,\n  resolver: number,\n): SerovalPromiseConstructorNode {\n  return createSerovalNode(\n    SerovalNodeType.PromiseConstructor,\n    id,\n    resolver,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parseSpecialReference(ctx, SpecialReference.PromiseConstructor),\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createArrayBufferNode(\n  ctx: BaseParserContext,\n  id: number,\n  current: ArrayBuffer,\n): SerovalArrayBufferNode {\n  const bytes = new Uint8Array(current);\n  let result = '';\n  for (let i = 0, len = bytes.length; i < len; i++) {\n    result += String.fromCharCode(bytes[i]);\n  }\n  return createSerovalNode(\n    SerovalNodeType.ArrayBuffer,\n    id,\n    serializeString(btoa(result)),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parseSpecialReference(ctx, SpecialReference.ArrayBufferConstructor),\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n", "import {\n  createAggregateErrorNode,\n  createArrayNode,\n  createAsyncIteratorFactoryInstanceNode,\n  createBigIntNode,\n  createBigIntTypedArrayNode,\n  createBoxedNode,\n  createDataViewNode,\n  createDateNode,\n  createErrorNode,\n  createIteratorFactoryInstanceNode,\n  createNumberNode,\n  createPluginNode,\n  createRegExpNode,\n  createSetNode,\n  createStreamConstructorNode,\n  createStreamNextNode,\n  createStreamReturnNode,\n  createStreamThrowNode,\n  createStringNode,\n  createTypedArrayNode,\n} from '../base-primitives';\nimport { Feature } from '../compat';\nimport { NIL, SerovalNodeType } from '../constants';\nimport { SerovalParserError, SerovalUnsupportedTypeError } from '../errors';\nimport { FALSE_NODE, NULL_NODE, TRUE_NODE, UNDEFINED_NODE } from '../literals';\nimport { createSerovalNode } from '../node';\nimport { OpaqueReference } from '../opaque-reference';\nimport type { SerovalMode } from '../plugin';\nimport { SpecialReference } from '../special-reference';\nimport type { Stream } from '../stream';\nimport { createStreamFromAsyncIterable, isStream } from '../stream';\nimport { serializeString } from '../string';\nimport {\n  SYM_ASYNC_ITERATOR,\n  SYM_IS_CONCAT_SPREADABLE,\n  SYM_ITERATOR,\n  SYM_TO_STRING_TAG,\n} from '../symbols';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalErrorNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseNode,\n  SerovalSetNode,\n  SerovalStreamConstructorNode,\n  SerovalTypedArrayNode,\n} from '../types';\nimport { getErrorOptions } from '../utils/error';\nimport { iteratorToSequence } from '../utils/iterator-to-sequence';\nimport promiseToResult from '../utils/promise-to-result';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../utils/typed-array';\nimport type { BaseParserContext, BaseParserContextOptions } from './parser';\nimport {\n  createArrayBufferNode,\n  createBaseParserContext,\n  createMapNode,\n  createObjectNode,\n  getReferenceNode,\n  markParserRef,\n  parseAsyncIteratorFactory,\n  parseIteratorFactory,\n  ParserNodeType,\n  parseSpecialReference,\n  parseWellKnownSymbol,\n} from './parser';\n\ntype ObjectLikeNode =\n  | SerovalObjectNode\n  | SerovalNullConstructorNode\n  | SerovalPromiseNode;\n\nexport type AsyncParserContextOptions = BaseParserContextOptions;\n\nexport interface AsyncParserContext {\n  base: BaseParserContext;\n  child: AsyncParsePluginContext | undefined;\n}\n\nexport function createAsyncParserContext(\n  mode: SerovalMode,\n  options: AsyncParserContextOptions,\n): AsyncParserContext {\n  return {\n    base: createBaseParserContext(mode, options),\n    child: undefined,\n  };\n}\n\nexport class AsyncParsePluginContext {\n  constructor(\n    private _p: AsyncParserContext,\n    private depth: number,\n  ) {}\n\n  parse<T>(current: T): Promise<SerovalNode> {\n    return parseAsync(this._p, this.depth, current);\n  }\n}\n\nasync function parseItems(\n  ctx: AsyncParserContext,\n  depth: number,\n  current: unknown[],\n): Promise<(SerovalNode | 0)[]> {\n  const nodes: (SerovalNode | 0)[] = [];\n  for (let i = 0, len = current.length; i < len; i++) {\n    // For consistency in holes\n    if (i in current) {\n      nodes[i] = await parseAsync(ctx, depth, current[i]);\n    } else {\n      nodes[i] = 0;\n    }\n  }\n  return nodes;\n}\n\nasync function parseArray(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: unknown[],\n): Promise<SerovalArrayNode> {\n  return createArrayNode(id, current, await parseItems(ctx, depth, current));\n}\n\nasync function parseProperties(\n  ctx: AsyncParserContext,\n  depth: number,\n  properties: Record<string | symbol, unknown>,\n): Promise<SerovalObjectRecordNode> {\n  const entries = Object.entries(properties);\n  const keyNodes: SerovalObjectRecordKey[] = [];\n  const valueNodes: SerovalNode[] = [];\n  for (let i = 0, len = entries.length; i < len; i++) {\n    keyNodes.push(serializeString(entries[i][0]));\n    valueNodes.push(await parseAsync(ctx, depth, entries[i][1]));\n  }\n  // Check special properties\n  if (SYM_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ITERATOR));\n    valueNodes.push(\n      createIteratorFactoryInstanceNode(\n        parseIteratorFactory(ctx.base),\n        await parseAsync(\n          ctx,\n          depth,\n          iteratorToSequence(properties as unknown as Iterable<unknown>),\n        ),\n      ),\n    );\n  }\n  if (SYM_ASYNC_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ASYNC_ITERATOR));\n    valueNodes.push(\n      createAsyncIteratorFactoryInstanceNode(\n        parseAsyncIteratorFactory(ctx.base),\n        await parseAsync(\n          ctx,\n          depth,\n          createStreamFromAsyncIterable(\n            properties as unknown as AsyncIterable<unknown>,\n          ),\n        ),\n      ),\n    );\n  }\n  if (SYM_TO_STRING_TAG in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_TO_STRING_TAG));\n    valueNodes.push(createStringNode(properties[SYM_TO_STRING_TAG] as string));\n  }\n  if (SYM_IS_CONCAT_SPREADABLE in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_IS_CONCAT_SPREADABLE));\n    valueNodes.push(\n      properties[SYM_IS_CONCAT_SPREADABLE] ? TRUE_NODE : FALSE_NODE,\n    );\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n  };\n}\n\nasync function parsePlainObject(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: Record<string, unknown>,\n  empty: boolean,\n): Promise<ObjectLikeNode> {\n  return createObjectNode(\n    id,\n    current,\n    empty,\n    await parseProperties(ctx, depth, current),\n  );\n}\n\n// TODO: check if parseBoxedSync can be used\nasync function parseBoxed(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: object,\n): Promise<SerovalBoxedNode> {\n  return createBoxedNode(id, await parseAsync(ctx, depth, current.valueOf()));\n}\n\nasync function parseTypedArray(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: TypedArrayValue,\n): Promise<SerovalTypedArrayNode> {\n  return createTypedArrayNode(\n    id,\n    current,\n    await parseAsync(ctx, depth, current.buffer),\n  );\n}\n\nasync function parseBigIntTypedArray(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: BigIntTypedArrayValue,\n): Promise<SerovalBigIntTypedArrayNode> {\n  return createBigIntTypedArrayNode(\n    id,\n    current,\n    await parseAsync(ctx, depth, current.buffer),\n  );\n}\n\nasync function parseDataView(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: DataView,\n): Promise<SerovalDataViewNode> {\n  return createDataViewNode(\n    id,\n    current,\n    await parseAsync(ctx, depth, current.buffer),\n  );\n}\n\nasync function parseError(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: Error,\n): Promise<SerovalErrorNode> {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createErrorNode(\n    id,\n    current,\n    options ? await parseProperties(ctx, depth, options) : NIL,\n  );\n}\n\nasync function parseAggregateError(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: AggregateError,\n): Promise<SerovalAggregateErrorNode> {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createAggregateErrorNode(\n    id,\n    current,\n    options ? await parseProperties(ctx, depth, options) : NIL,\n  );\n}\n\nasync function parseMap(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: Map<unknown, unknown>,\n): Promise<SerovalMapNode> {\n  const keyNodes: SerovalNode[] = [];\n  const valueNodes: SerovalNode[] = [];\n  for (const [key, value] of current.entries()) {\n    keyNodes.push(await parseAsync(ctx, depth, key));\n    valueNodes.push(await parseAsync(ctx, depth, value));\n  }\n  return createMapNode(ctx.base, id, keyNodes, valueNodes);\n}\n\nasync function parseSet(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: Set<unknown>,\n): Promise<SerovalSetNode> {\n  const items: SerovalNode[] = [];\n  for (const item of current.keys()) {\n    items.push(await parseAsync(ctx, depth, item));\n  }\n  return createSetNode(id, items);\n}\n\nasync function parsePlugin(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: unknown,\n): Promise<SerovalPluginNode | undefined> {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    for (let i = 0, len = currentPlugins.length; i < len; i++) {\n      const plugin = currentPlugins[i];\n      if (plugin.parse.async && plugin.test(current)) {\n        return createPluginNode(\n          id,\n          plugin.tag,\n          await plugin.parse.async(\n            current,\n            new AsyncParsePluginContext(ctx, depth),\n            {\n              id,\n            },\n          ),\n        );\n      }\n    }\n  }\n  return NIL;\n}\n\nasync function parsePromise(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: Promise<unknown>,\n): Promise<SerovalPromiseNode> {\n  const [status, result] = await promiseToResult(current);\n\n  return createSerovalNode(\n    SerovalNodeType.Promise,\n    id,\n    status,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    await parseAsync(ctx, depth, result),\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nfunction parseStreamHandle<T>(\n  this: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: Stream<T>,\n  resolve: (value: SerovalNode[] | PromiseLike<SerovalNode[]>) => void,\n  reject: (reason?: any) => void,\n): void {\n  const sequence: SerovalNode[] = [];\n  // TODO Optimizable\n  const cleanup = current.on({\n    next: value => {\n      markParserRef(this.base, id);\n      parseAsync(this, depth, value).then(\n        data => {\n          sequence.push(createStreamNextNode(id, data));\n        },\n        data => {\n          reject(data);\n          cleanup();\n        },\n      );\n    },\n    throw: value => {\n      markParserRef(this.base, id);\n      parseAsync(this, depth, value).then(\n        data => {\n          sequence.push(createStreamThrowNode(id, data));\n          resolve(sequence);\n          cleanup();\n        },\n        data => {\n          reject(data);\n          cleanup();\n        },\n      );\n    },\n    return: value => {\n      markParserRef(this.base, id);\n      parseAsync(this, depth, value).then(\n        data => {\n          sequence.push(createStreamReturnNode(id, data));\n          resolve(sequence);\n          cleanup();\n        },\n        data => {\n          reject(data);\n          cleanup();\n        },\n      );\n    },\n  });\n}\n\nasync function parseStream(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: Stream<unknown>,\n): Promise<SerovalStreamConstructorNode> {\n  return createStreamConstructorNode(\n    id,\n    parseSpecialReference(ctx.base, SpecialReference.StreamConstructor),\n    await new Promise<SerovalNode[]>(\n      parseStreamHandle.bind(ctx, depth, id, current),\n    ),\n  );\n}\n\nexport async function parseObjectAsync(\n  ctx: AsyncParserContext,\n  depth: number,\n  id: number,\n  current: object,\n): Promise<SerovalNode> {\n  if (Array.isArray(current)) {\n    return parseArray(ctx, depth, id, current);\n  }\n  if (isStream(current)) {\n    return parseStream(ctx, depth, id, current);\n  }\n  const currentClass = current.constructor;\n  if (currentClass === OpaqueReference) {\n    return parseAsync(\n      ctx,\n      depth,\n      (current as OpaqueReference<unknown, unknown>).replacement,\n    );\n  }\n  const parsed = await parsePlugin(ctx, depth, id, current);\n  if (parsed) {\n    return parsed;\n  }\n  switch (currentClass) {\n    case Object:\n      return parsePlainObject(\n        ctx,\n        depth,\n        id,\n        current as Record<string, unknown>,\n        false,\n      );\n    case NIL:\n      return parsePlainObject(\n        ctx,\n        depth,\n        id,\n        current as Record<string, unknown>,\n        true,\n      );\n    case Date:\n      return createDateNode(id, current as unknown as Date);\n    case Error:\n    case EvalError:\n    case RangeError:\n    case ReferenceError:\n    case SyntaxError:\n    case TypeError:\n    case URIError:\n      return parseError(ctx, depth, id, current as unknown as Error);\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n      return parseBoxed(ctx, depth, id, current);\n    case ArrayBuffer:\n      return createArrayBufferNode(\n        ctx.base,\n        id,\n        current as unknown as ArrayBuffer,\n      );\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n      return parseTypedArray(\n        ctx,\n        depth,\n        id,\n        current as unknown as TypedArrayValue,\n      );\n    case DataView:\n      return parseDataView(ctx, depth, id, current as unknown as DataView);\n    case Map:\n      return parseMap(\n        ctx,\n        depth,\n        id,\n        current as unknown as Map<unknown, unknown>,\n      );\n    case Set:\n      return parseSet(ctx, depth, id, current as unknown as Set<unknown>);\n    default:\n      break;\n  }\n  // Promises\n  if (currentClass === Promise || current instanceof Promise) {\n    return parsePromise(ctx, depth, id, current as unknown as Promise<unknown>);\n  }\n  const currentFeatures = ctx.base.features;\n  if (currentFeatures & Feature.RegExp && currentClass === RegExp) {\n    return createRegExpNode(id, current as unknown as RegExp);\n  }\n  // BigInt Typed Arrays\n  if (currentFeatures & Feature.BigIntTypedArray) {\n    switch (currentClass) {\n      case BigInt64Array:\n      case BigUint64Array:\n        return parseBigIntTypedArray(\n          ctx,\n          depth,\n          id,\n          current as unknown as BigIntTypedArrayValue,\n        );\n      default:\n        break;\n    }\n  }\n  if (\n    currentFeatures & Feature.AggregateError &&\n    typeof AggregateError !== 'undefined' &&\n    (currentClass === AggregateError || current instanceof AggregateError)\n  ) {\n    return parseAggregateError(\n      ctx,\n      depth,\n      id,\n      current as unknown as AggregateError,\n    );\n  }\n  // Slow path. We only need to handle Errors and Iterators\n  // since they have very broad implementations.\n  if (current instanceof Error) {\n    return parseError(ctx, depth, id, current);\n  }\n  // Generator functions don't have a global constructor\n  // despite existing\n  if (SYM_ITERATOR in current || SYM_ASYNC_ITERATOR in current) {\n    return parsePlainObject(ctx, depth, id, current, !!currentClass);\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\n\nexport async function parseFunctionAsync(\n  ctx: AsyncParserContext,\n  depth: number,\n  current: unknown,\n): Promise<SerovalNode> {\n  const ref = getReferenceNode(ctx.base, current);\n  if (ref.type !== ParserNodeType.Fresh) {\n    return ref.value;\n  }\n  const plugin = await parsePlugin(ctx, depth, ref.value, current);\n  if (plugin) {\n    return plugin;\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\n\nexport async function parseAsync<T>(\n  ctx: AsyncParserContext,\n  depth: number,\n  current: T,\n): Promise<SerovalNode> {\n  switch (typeof current) {\n    case 'boolean':\n      return current ? TRUE_NODE : FALSE_NODE;\n    case 'undefined':\n      return UNDEFINED_NODE;\n    case 'string':\n      return createStringNode(current as string);\n    case 'number':\n      return createNumberNode(current as number);\n    case 'bigint':\n      return createBigIntNode(current as bigint);\n    case 'object': {\n      if (current) {\n        const ref = getReferenceNode(ctx.base, current);\n        return ref.type === 0\n          ? await parseObjectAsync(ctx, depth + 1, ref.value, current as object)\n          : ref.value;\n      }\n      return NULL_NODE;\n    }\n    case 'symbol':\n      return parseWellKnownSymbol(ctx.base, current);\n    case 'function':\n      return parseFunctionAsync(ctx, depth, current);\n    default:\n      throw new SerovalUnsupportedTypeError(current);\n  }\n}\n\nexport async function parseTopAsync<T>(\n  ctx: AsyncParserContext,\n  current: T,\n): Promise<SerovalNode> {\n  try {\n    return await parseAsync(ctx, 0, current);\n  } catch (error) {\n    throw error instanceof SerovalParserError\n      ? error\n      : new SerovalParserError(error);\n  }\n}\n", "import type { AsyncParsePluginContext } from './context/async-parser';\nimport type { DeserializePluginContext } from './context/deserializer';\nimport type { SerializePluginContext } from './context/serializer';\nimport type {\n  StreamParsePluginContext,\n  SyncParsePluginContext,\n} from './context/sync-parser';\n\nexport const enum SerovalMode {\n  Vanilla = 1,\n  Cross = 2,\n}\n\nexport interface PluginData {\n  id: number;\n}\n\nexport interface Plugin<Value, Node> {\n  /**\n   * A unique string that helps idenfity the plugin\n   */\n  tag: string;\n  /**\n   * List of dependency plugins\n   */\n  extends?: Plugin<any, any>[];\n  /**\n   * Method to test if a value is an expected value of the plugin\n   * @param value\n   */\n  test(value: unknown): boolean;\n  /**\n   * Parsing modes\n   */\n  parse: {\n    sync?: (\n      value: Value,\n      ctx: SyncParsePluginContext,\n      data: PluginData,\n    ) => Node;\n    async?: (\n      value: Value,\n      ctx: AsyncParsePluginContext,\n      data: PluginData,\n    ) => Promise<Node>;\n    stream?: (\n      value: Value,\n      ctx: StreamParsePluginContext,\n      data: PluginData,\n    ) => Node;\n  };\n  /**\n   * Convert the parsed node into a JS string\n   */\n  serialize(node: Node, ctx: SerializePluginContext, data: PluginData): string;\n  /**\n   * Convert the parsed node into its runtime equivalent.\n   */\n  deserialize(\n    node: Node,\n    ctx: DeserializePluginContext,\n    data: PluginData,\n  ): Value;\n}\n\nexport function createPlugin<Value, Node>(\n  plugin: Plugin<Value, Node>,\n): Plugin<Value, Node> {\n  return plugin;\n}\n\nexport interface PluginAccessOptions {\n  plugins?: Plugin<any, any>[];\n}\n\nfunction dedupePlugins(\n  deduped: Set<Plugin<any, any>>,\n  plugins: Plugin<any, any>[],\n): void {\n  for (let i = 0, len = plugins.length; i < len; i++) {\n    const current = plugins[i];\n    if (!deduped.has(current)) {\n      deduped.add(current);\n      if (current.extends) {\n        dedupePlugins(deduped, current.extends);\n      }\n    }\n  }\n}\n\nexport function resolvePlugins(\n  plugins?: Plugin<any, any>[],\n): Plugin<any, any>[] | undefined {\n  if (plugins) {\n    const deduped = new Set<Plugin<any, any>>();\n    dedupePlugins(deduped, plugins);\n    return [...deduped];\n  }\n  return undefined;\n}\n", "import { SerovalUnknownTypedArrayError } from '../errors';\n\ntype TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint16ArrayConstructor\n  | Uint32ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\nexport type TypedArrayValue =\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array;\n\nexport type BigIntTypedArrayValue = BigInt64Array | BigUint64Array;\n\nexport function getTypedArrayConstructor(name: string): TypedArrayConstructor {\n  switch (name) {\n    case 'Int8Array':\n      return Int8Array;\n    case 'Int16Array':\n      return Int16Array;\n    case 'Int32Array':\n      return Int32Array;\n    case 'Uint8Array':\n      return Uint8Array;\n    case 'Uint16Array':\n      return Uint16Array;\n    case 'Uint32Array':\n      return Uint32Array;\n    case 'Uint8ClampedArray':\n      return Uint8ClampedArray;\n    case 'Float32Array':\n      return Float32Array;\n    case 'Float64Array':\n      return Float64Array;\n    case 'BigInt64Array':\n      return BigInt64Array;\n    case 'BigUint64Array':\n      return BigUint64Array;\n    default:\n      throw new SerovalUnknownTypedArrayError(name);\n  }\n}\n", "import { ALL_ENABLED, Feature } from '../compat';\nimport {\n  CONSTANT_VAL,\n  ERROR_CONSTRUCTOR,\n  NIL,\n  SerovalNodeType,\n  SerovalObjectFlags,\n  SYMBOL_REF,\n} from '../constants';\nimport {\n  ARRAY_BUFFER_CONSTRUCTOR,\n  PROMISE_CONSTRUCTOR,\n  type PromiseConstructorResolver,\n} from '../constructors';\nimport {\n  SerovalDepthLimitError,\n  SerovalDeserializationError,\n  SerovalMalformedNodeError,\n  SerovalMissingInstanceError,\n  SerovalMissingPluginError,\n  SerovalUnsupportedNodeError,\n} from '../errors';\nimport type { PluginAccessOptions } from '../plugin';\nimport { SerovalMode } from '../plugin';\nimport { getReference } from '../reference';\nimport type { Stream } from '../stream';\nimport { createStream, isStream, streamToAsyncIterable } from '../stream';\nimport { deserializeString } from '../string';\nimport {\n  SYM_ASYNC_ITERATOR,\n  SYM_IS_CONCAT_SPREADABLE,\n  SYM_ITERATOR,\n  SYM_TO_STRING_TAG,\n} from '../symbols';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayBufferNode,\n  SerovalArrayNode,\n  SerovalAsyncIteratorFactoryInstanceNode,\n  SerovalAsyncIteratorFactoryNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalDateNode,\n  SerovalErrorNode,\n  SerovalIteratorFactoryInstanceNode,\n  SerovalIteratorFactoryNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseConstructorNode,\n  SerovalPromiseNode,\n  SerovalPromiseRejectNode,\n  SerovalPromiseResolveNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalSetNode,\n  SerovalStreamConstructorNode,\n  SerovalStreamNextNode,\n  SerovalStreamReturnNode,\n  SerovalStreamThrowNode,\n  SerovalTypedArrayNode,\n} from '../types';\nimport type { Sequence } from '../utils/iterator-to-sequence';\nimport { sequenceToIterator } from '../utils/iterator-to-sequence';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../utils/typed-array';\nimport { getTypedArrayConstructor } from '../utils/typed-array';\n\nconst MAX_BASE64_LENGTH = 1_000_000; // ~0.75MB decoded\nconst MAX_BIGINT_LENGTH = 10_000;\nconst MAX_REGEXP_SOURCE_LENGTH = 20_000;\n\nfunction applyObjectFlag(obj: unknown, flag: SerovalObjectFlags): unknown {\n  switch (flag) {\n    case SerovalObjectFlags.Frozen:\n      return Object.freeze(obj);\n    case SerovalObjectFlags.NonExtensible:\n      return Object.preventExtensions(obj);\n    case SerovalObjectFlags.Sealed:\n      return Object.seal(obj);\n    default:\n      return obj;\n  }\n}\n\ntype AssignableValue = AggregateError | Error | Iterable<unknown>;\ntype AssignableNode = SerovalAggregateErrorNode | SerovalErrorNode;\n\nexport interface BaseDeserializerContextOptions extends PluginAccessOptions {\n  refs?: Map<number, unknown>;\n  features?: number;\n  disabledFeatures?: number;\n  depthLimit?: number;\n}\n\nexport interface BaseDeserializerContext extends PluginAccessOptions {\n  readonly mode: SerovalMode;\n  /**\n   * Mapping ids to values\n   */\n  refs: Map<number, unknown>;\n  features: number;\n  depthLimit: number;\n}\n\nconst DEFAULT_DEPTH_LIMIT = 1000;\n\nexport function createBaseDeserializerContext(\n  mode: SerovalMode,\n  options: BaseDeserializerContextOptions,\n): BaseDeserializerContext {\n  return {\n    mode,\n    plugins: options.plugins,\n    refs: options.refs || new Map(),\n    features: options.features ?? ALL_ENABLED ^ (options.disabledFeatures || 0),\n    depthLimit: options.depthLimit || DEFAULT_DEPTH_LIMIT,\n  };\n}\n\nexport interface VanillaDeserializerContextOptions\n  extends Omit<BaseDeserializerContextOptions, 'refs'> {\n  markedRefs: number[] | Set<number>;\n}\n\nexport interface VanillaDeserializerState {\n  marked: Set<number>;\n}\n\nexport interface VanillaDeserializerContext {\n  mode: SerovalMode.Vanilla;\n  base: BaseDeserializerContext;\n  child: DeserializePluginContext | undefined;\n  state: VanillaDeserializerState;\n}\n\nexport function createVanillaDeserializerContext(\n  options: VanillaDeserializerContextOptions,\n): VanillaDeserializerContext {\n  return {\n    mode: SerovalMode.Vanilla,\n    base: createBaseDeserializerContext(SerovalMode.Vanilla, options),\n    child: NIL,\n    state: {\n      marked: new Set(options.markedRefs),\n    },\n  };\n}\n\nexport interface CrossDeserializerContext {\n  mode: SerovalMode.Cross;\n  base: BaseDeserializerContext;\n  child: DeserializePluginContext | undefined;\n}\n\nexport type CrossDeserializerContextOptions = BaseDeserializerContextOptions;\n\nexport function createCrossDeserializerContext(\n  options: CrossDeserializerContextOptions,\n): CrossDeserializerContext {\n  return {\n    mode: SerovalMode.Cross,\n    base: createBaseDeserializerContext(SerovalMode.Cross, options),\n    child: NIL,\n  };\n}\n\ntype DeserializerContext =\n  | VanillaDeserializerContext\n  | CrossDeserializerContext;\n\nexport class DeserializePluginContext {\n  constructor(\n    private _p: DeserializerContext,\n    private depth: number,\n  ) {}\n\n  deserialize<T>(node: SerovalNode): T {\n    return deserialize(this._p, this.depth, node) as T;\n  }\n}\n\nfunction guardIndexedValue(ctx: BaseDeserializerContext, id: number): void {\n  if (id < 0 || !Number.isFinite(id) || !Number.isInteger(id)) {\n    throw new SerovalMalformedNodeError({\n      t: SerovalNodeType.IndexedValue,\n      i: id,\n    } as SerovalNode);\n  }\n  if (ctx.refs.has(id)) {\n    throw new Error('Conflicted ref id: ' + id);\n  }\n}\n\nfunction assignIndexedValueVanilla<T>(\n  ctx: VanillaDeserializerContext,\n  id: number,\n  value: T,\n): T {\n  guardIndexedValue(ctx.base, id);\n  if (ctx.state.marked.has(id)) {\n    ctx.base.refs.set(id, value);\n  }\n  return value;\n}\n\nfunction assignIndexedValueCross<T>(\n  ctx: CrossDeserializerContext,\n  id: number,\n  value: T,\n): T {\n  guardIndexedValue(ctx.base, id);\n  ctx.base.refs.set(id, value);\n  return value;\n}\n\nfunction assignIndexedValue<T>(\n  ctx: DeserializerContext,\n  id: number,\n  value: T,\n): T {\n  return ctx.mode === SerovalMode.Vanilla\n    ? assignIndexedValueVanilla(ctx, id, value)\n    : assignIndexedValueCross(ctx, id, value);\n}\n\nfunction deserializeKnownValue<\n  T extends Record<string, unknown>,\n  K extends keyof T,\n>(node: SerovalNode, record: T, key: K): T[K] {\n  if (Object.hasOwn(record, key)) {\n    return record[key];\n  }\n  throw new SerovalMalformedNodeError(node);\n}\n\nfunction deserializeReference(\n  ctx: DeserializerContext,\n  node: SerovalReferenceNode,\n): unknown {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    getReference(deserializeString(node.s)),\n  );\n}\n\nfunction deserializeArray(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalArrayNode,\n): unknown[] {\n  const items = node.a;\n  const len = items.length;\n  const result: unknown[] = assignIndexedValue(\n    ctx,\n    node.i,\n    new Array<unknown>(len),\n  );\n  for (let i = 0, item: SerovalNode | 0; i < len; i++) {\n    item = items[i];\n    if (item) {\n      result[i] = deserialize(ctx, depth, item);\n    }\n  }\n  applyObjectFlag(result, node.o);\n  return result;\n}\n\nfunction isValidKey(key: string): boolean {\n  switch (key) {\n    case 'constructor':\n    case '__proto__':\n    case 'prototype':\n    case '__defineGetter__':\n    case '__defineSetter__':\n    case '__lookupGetter__':\n    case '__lookupSetter__':\n      // case 'then':\n      return false;\n    default:\n      return true;\n  }\n}\n\nfunction isValidSymbol(symbol: symbol): boolean {\n  switch (symbol) {\n    case SYM_ASYNC_ITERATOR:\n    case SYM_IS_CONCAT_SPREADABLE:\n    case SYM_TO_STRING_TAG:\n    case SYM_ITERATOR:\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction assignStringProperty(\n  object: Record<string | symbol, unknown>,\n  key: string,\n  value: unknown,\n): void {\n  if (isValidKey(key)) {\n    object[key] = value;\n  } else {\n    Object.defineProperty(object, key, {\n      value,\n      configurable: true,\n      enumerable: true,\n      writable: true,\n    });\n  }\n}\n\nfunction assignProperty(\n  ctx: DeserializerContext,\n  depth: number,\n  object: Record<string | symbol, unknown>,\n  key: string | SerovalNode,\n  value: SerovalNode,\n): void {\n  if (typeof key === 'string') {\n    assignStringProperty(object, key, deserialize(ctx, depth, value));\n  } else {\n    const actual = deserialize(ctx, depth, key);\n    switch (typeof actual) {\n      case 'string':\n        assignStringProperty(object, actual, deserialize(ctx, depth, value));\n        break;\n      case 'symbol':\n        if (isValidSymbol(actual)) {\n          object[actual] = deserialize(ctx, depth, value);\n        }\n        break;\n      default:\n        throw new SerovalMalformedNodeError(key);\n    }\n  }\n}\n\nfunction deserializeProperties(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalObjectRecordNode,\n  result: Record<string | symbol, unknown>,\n): Record<string | symbol, unknown> {\n  const keys = node.k;\n  const len = keys.length;\n  if (len > 0) {\n    for (let i = 0, vals = node.v, len = keys.length; i < len; i++) {\n      assignProperty(ctx, depth, result, keys[i], vals[i]);\n    }\n  }\n  return result;\n}\n\nfunction deserializeObject(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalObjectNode | SerovalNullConstructorNode,\n): Record<string, unknown> {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    (node.t === SerovalNodeType.Object ? {} : Object.create(null)) as Record<\n      string,\n      unknown\n    >,\n  );\n  deserializeProperties(ctx, depth, node.p, result);\n  applyObjectFlag(result, node.o);\n  return result;\n}\n\nfunction deserializeDate(\n  ctx: DeserializerContext,\n  node: SerovalDateNode,\n): Date {\n  return assignIndexedValue(ctx, node.i, new Date(node.s));\n}\n\nfunction deserializeRegExp(\n  ctx: DeserializerContext,\n  node: SerovalRegExpNode,\n): RegExp {\n  if (ctx.base.features & Feature.RegExp) {\n    const source = deserializeString(node.c);\n    if (source.length > MAX_REGEXP_SOURCE_LENGTH) {\n      throw new SerovalMalformedNodeError(node);\n    }\n    return assignIndexedValue(ctx, node.i, new RegExp(source, node.m));\n  }\n  throw new SerovalUnsupportedNodeError(node);\n}\n\nfunction deserializeSet(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalSetNode,\n): Set<unknown> {\n  const result = assignIndexedValue(ctx, node.i, new Set<unknown>());\n  for (let i = 0, items = node.a, len = items.length; i < len; i++) {\n    result.add(deserialize(ctx, depth, items[i]));\n  }\n  return result;\n}\n\nfunction deserializeMap(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalMapNode,\n): Map<unknown, unknown> {\n  const result = assignIndexedValue(ctx, node.i, new Map<unknown, unknown>());\n  for (\n    let i = 0, keys = node.e.k, vals = node.e.v, len = keys.length;\n    i < len;\n    i++\n  ) {\n    result.set(\n      deserialize(ctx, depth, keys[i]),\n      deserialize(ctx, depth, vals[i]),\n    );\n  }\n  return result;\n}\n\nfunction deserializeArrayBuffer(\n  ctx: DeserializerContext,\n  node: SerovalArrayBufferNode,\n): ArrayBuffer {\n  if (node.s.length > MAX_BASE64_LENGTH) {\n    throw new SerovalMalformedNodeError(node);\n  }\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    ARRAY_BUFFER_CONSTRUCTOR(deserializeString(node.s)),\n  );\n  return result;\n}\n\nfunction deserializeTypedArray(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalTypedArrayNode | SerovalBigIntTypedArrayNode,\n): TypedArrayValue | BigIntTypedArrayValue {\n  const construct = getTypedArrayConstructor(node.c) as Int8ArrayConstructor;\n  const source = deserialize(ctx, depth, node.f) as ArrayBuffer;\n  const offset = node.b ?? 0;\n  if (offset < 0 || offset > source.byteLength) {\n    throw new SerovalMalformedNodeError(node);\n  }\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new construct(source, offset, node.l),\n  );\n  return result;\n}\n\nfunction deserializeDataView(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalDataViewNode,\n): DataView {\n  const source = deserialize(ctx, depth, node.f) as ArrayBuffer;\n  const offset = node.b ?? 0;\n  if (offset < 0 || offset > source.byteLength) {\n    throw new SerovalMalformedNodeError(node);\n  }\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new DataView(source, offset, node.l),\n  );\n  return result;\n}\n\nfunction deserializeDictionary<T extends AssignableValue>(\n  ctx: DeserializerContext,\n  depth: number,\n  node: AssignableNode,\n  result: T,\n): T {\n  if (node.p) {\n    const fields = deserializeProperties(ctx, depth, node.p, {});\n    Object.defineProperties(result, Object.getOwnPropertyDescriptors(fields));\n  }\n  return result;\n}\n\nfunction deserializeAggregateError(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalAggregateErrorNode,\n): AggregateError {\n  // Serialize the required arguments\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new AggregateError([], deserializeString(node.m)),\n  );\n  // `AggregateError` might've been extended\n  // either through class or custom properties\n  // Make sure to assign extra properties\n  return deserializeDictionary(ctx, depth, node, result);\n}\n\nfunction deserializeError(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalErrorNode,\n): Error {\n  const construct = deserializeKnownValue(node, ERROR_CONSTRUCTOR, node.s);\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new construct(deserializeString(node.m)),\n  );\n  return deserializeDictionary(ctx, depth, node, result);\n}\n\nfunction deserializePromise(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalPromiseNode,\n): Promise<unknown> {\n  const deferred = PROMISE_CONSTRUCTOR();\n  const result = assignIndexedValue(ctx, node.i, deferred.p);\n  const deserialized = deserialize(ctx, depth, node.f);\n  if (node.s) {\n    deferred.s(deserialized);\n  } else {\n    deferred.f(deserialized);\n  }\n  return result;\n}\n\nfunction deserializeBoxed(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalBoxedNode,\n): unknown {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    // biome-ignore lint/style/useConsistentBuiltinInstantiation: intended\n    Object(deserialize(ctx, depth, node.f)),\n  );\n}\n\nfunction deserializePlugin(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalPluginNode,\n): unknown {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    const tag = deserializeString(node.c);\n    for (let i = 0, len = currentPlugins.length; i < len; i++) {\n      const plugin = currentPlugins[i];\n      if (plugin.tag === tag) {\n        return assignIndexedValue(\n          ctx,\n          node.i,\n          plugin.deserialize(node.s, new DeserializePluginContext(ctx, depth), {\n            id: node.i,\n          }),\n        );\n      }\n    }\n  }\n  throw new SerovalMissingPluginError(node.c);\n}\n\nfunction deserializePromiseConstructor(\n  ctx: DeserializerContext,\n  node: SerovalPromiseConstructorNode,\n): unknown {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    assignIndexedValue(ctx, node.s, PROMISE_CONSTRUCTOR()).p,\n  );\n}\n\nfunction deserializePromiseResolve(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalPromiseResolveNode,\n): unknown {\n  const deferred = ctx.base.refs.get(node.i) as\n    | PromiseConstructorResolver\n    | undefined;\n  if (deferred) {\n    deferred.s(deserialize(ctx, depth, node.a[1]));\n    return NIL;\n  }\n  throw new SerovalMissingInstanceError('Promise');\n}\n\nfunction deserializePromiseReject(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalPromiseRejectNode,\n): unknown {\n  const deferred = ctx.base.refs.get(node.i) as\n    | PromiseConstructorResolver\n    | undefined;\n  if (deferred) {\n    deferred.f(deserialize(ctx, depth, node.a[1]));\n    return NIL;\n  }\n  throw new SerovalMissingInstanceError('Promise');\n}\n\nfunction deserializeIteratorFactoryInstance(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalIteratorFactoryInstanceNode,\n): unknown {\n  deserialize(ctx, depth, node.a[0]);\n  const source = deserialize(ctx, depth, node.a[1]);\n  return sequenceToIterator(source as Sequence);\n}\n\nfunction deserializeAsyncIteratorFactoryInstance(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalAsyncIteratorFactoryInstanceNode,\n): unknown {\n  deserialize(ctx, depth, node.a[0]);\n  const source = deserialize(ctx, depth, node.a[1]);\n  return streamToAsyncIterable(source as Stream<any>);\n}\n\nfunction deserializeStreamConstructor(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalStreamConstructorNode,\n): unknown {\n  const result = assignIndexedValue(ctx, node.i, createStream());\n  const items = node.a;\n  const len = items.length;\n  if (len) {\n    for (let i = 0; i < len; i++) {\n      deserialize(ctx, depth, items[i]);\n    }\n  }\n  return result;\n}\n\nfunction deserializeStreamNext(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalStreamNextNode,\n): unknown {\n  const deferred = ctx.base.refs.get(node.i) as Stream<unknown> | undefined;\n  if (deferred && isStream(deferred)) {\n    deferred.next(deserialize(ctx, depth, node.f));\n    return NIL;\n  }\n  throw new SerovalMissingInstanceError('Stream');\n}\n\nfunction deserializeStreamThrow(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalStreamThrowNode,\n): unknown {\n  const deferred = ctx.base.refs.get(node.i) as Stream<unknown> | undefined;\n  if (deferred && isStream(deferred)) {\n    deferred.throw(deserialize(ctx, depth, node.f));\n    return NIL;\n  }\n  throw new SerovalMissingInstanceError('Stream');\n}\n\nfunction deserializeStreamReturn(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalStreamReturnNode,\n): unknown {\n  const deferred = ctx.base.refs.get(node.i) as Stream<unknown> | undefined;\n  if (deferred && isStream(deferred)) {\n    deferred.return(deserialize(ctx, depth, node.f));\n    return NIL;\n  }\n  throw new SerovalMissingInstanceError('Stream');\n}\n\nfunction deserializeIteratorFactory(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalIteratorFactoryNode,\n): unknown {\n  deserialize(ctx, depth, node.f);\n  return NIL;\n}\n\nfunction deserializeAsyncIteratorFactory(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalAsyncIteratorFactoryNode,\n): unknown {\n  deserialize(ctx, depth, node.a[1]);\n  return NIL;\n}\n\nfunction deserialize(\n  ctx: DeserializerContext,\n  depth: number,\n  node: SerovalNode,\n): unknown {\n  if (depth > ctx.base.depthLimit) {\n    throw new SerovalDepthLimitError(ctx.base.depthLimit);\n  }\n  depth += 1;\n  switch (node.t) {\n    case SerovalNodeType.Constant:\n      return deserializeKnownValue(node, CONSTANT_VAL, node.s);\n    case SerovalNodeType.Number:\n      return Number(node.s);\n    case SerovalNodeType.String:\n      return deserializeString(String(node.s));\n    case SerovalNodeType.BigInt:\n      if (String(node.s).length > MAX_BIGINT_LENGTH) {\n        throw new SerovalMalformedNodeError(node);\n      }\n      return BigInt(node.s);\n    case SerovalNodeType.IndexedValue:\n      return ctx.base.refs.get(node.i);\n    case SerovalNodeType.Reference:\n      return deserializeReference(ctx, node);\n    case SerovalNodeType.Array:\n      return deserializeArray(ctx, depth, node);\n    case SerovalNodeType.Object:\n    case SerovalNodeType.NullConstructor:\n      return deserializeObject(ctx, depth, node);\n    case SerovalNodeType.Date:\n      return deserializeDate(ctx, node);\n    case SerovalNodeType.RegExp:\n      return deserializeRegExp(ctx, node);\n    case SerovalNodeType.Set:\n      return deserializeSet(ctx, depth, node);\n    case SerovalNodeType.Map:\n      return deserializeMap(ctx, depth, node);\n    case SerovalNodeType.ArrayBuffer:\n      return deserializeArrayBuffer(ctx, node);\n    case SerovalNodeType.BigIntTypedArray:\n    case SerovalNodeType.TypedArray:\n      return deserializeTypedArray(ctx, depth, node);\n    case SerovalNodeType.DataView:\n      return deserializeDataView(ctx, depth, node);\n    case SerovalNodeType.AggregateError:\n      return deserializeAggregateError(ctx, depth, node);\n    case SerovalNodeType.Error:\n      return deserializeError(ctx, depth, node);\n    case SerovalNodeType.Promise:\n      return deserializePromise(ctx, depth, node);\n    case SerovalNodeType.WKSymbol:\n      return deserializeKnownValue(node, SYMBOL_REF, node.s);\n    case SerovalNodeType.Boxed:\n      return deserializeBoxed(ctx, depth, node);\n    case SerovalNodeType.Plugin:\n      return deserializePlugin(ctx, depth, node);\n    case SerovalNodeType.PromiseConstructor:\n      return deserializePromiseConstructor(ctx, node);\n    case SerovalNodeType.PromiseSuccess:\n      return deserializePromiseResolve(ctx, depth, node);\n    case SerovalNodeType.PromiseFailure:\n      return deserializePromiseReject(ctx, depth, node);\n    case SerovalNodeType.IteratorFactoryInstance:\n      return deserializeIteratorFactoryInstance(ctx, depth, node);\n    case SerovalNodeType.AsyncIteratorFactoryInstance:\n      return deserializeAsyncIteratorFactoryInstance(ctx, depth, node);\n    case SerovalNodeType.StreamConstructor:\n      return deserializeStreamConstructor(ctx, depth, node);\n    case SerovalNodeType.StreamNext:\n      return deserializeStreamNext(ctx, depth, node);\n    case SerovalNodeType.StreamThrow:\n      return deserializeStreamThrow(ctx, depth, node);\n    case SerovalNodeType.StreamReturn:\n      return deserializeStreamReturn(ctx, depth, node);\n    case SerovalNodeType.IteratorFactory:\n      return deserializeIteratorFactory(ctx, depth, node);\n    case SerovalNodeType.AsyncIteratorFactory:\n      return deserializeAsyncIteratorFactory(ctx, depth, node);\n    // case SerovalNodeType.SpecialReference:\n    default:\n      throw new SerovalUnsupportedNodeError(node);\n  }\n}\n\nexport function deserializeTop(\n  ctx: DeserializerContext,\n  node: SerovalNode,\n): unknown {\n  try {\n    return deserialize(ctx, 0, node);\n  } catch (error) {\n    throw new SerovalDeserializationError(error);\n  }\n}\n", "\ndeclare const T: unknown;\n\nconst RETURN = () => T;\nconst SERIALIZED_RETURN = /* @__PURE__ */ RETURN.toString();\n\nconst IS_MODERN = /* @__PURE__ */ /=>/.test(SERIALIZED_RETURN);\n\nexport function createFunction(parameters: string[], body: string): string {\n  if (IS_MODERN) {\n    const joined =\n      parameters.length === 1\n        ? parameters[0]\n        : '(' + parameters.join(',') + ')';\n    return joined + '=>' + (body.startsWith('{') ? '(' + body + ')' : body);\n  }\n  return 'function(' + parameters.join(',') + '){return ' + body + '}';\n}\n\nexport function createEffectfulFunction(\n  parameters: string[],\n  body: string,\n): string {\n  if (IS_MODERN) {\n    const joined =\n      parameters.length === 1\n        ? parameters[0]\n        : '(' + parameters.join(',') + ')';\n    return joined + '=>{' + body + '}';\n  }\n  return 'function(' + parameters.join(',') + '){' + body + '}';\n}", "// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\nconst REF_START_CHARS = /* @__PURE__ */ 'hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_'; // Avoids chars that could evaluate to a reserved word.\nconst REF_START_CHARS_LEN = /* @__PURE__ */ REF_START_CHARS.length;\nconst REF_CHARS =\n  /* @__PURE__ */ 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_';\nconst REF_CHARS_LEN = /* @__PURE__ */ REF_CHARS.length;\n\nexport default function getIdentifier(index: number): string {\n  let mod = index % REF_START_CHARS_LEN;\n  let ref = REF_START_CHARS[mod];\n  index = (index - mod) / REF_START_CHARS_LEN;\n  while (index > 0) {\n    mod = index % REF_CHARS_LEN;\n    ref += REF_CHARS[mod];\n    index = (index - mod) / REF_CHARS_LEN;\n  }\n  return ref;\n}\n", "const IDENTIFIER_CHECK = /^[$A-Z_][0-9A-Z_$]*$/i;\n\nexport function isValidIdentifier(name: string): boolean {\n  const char = name[0];\n  return (\n    (char === '$' ||\n      char === '_' ||\n      (char >= 'A' && char <= 'Z') ||\n      (char >= 'a' && char <= 'z')) &&\n    IDENTIFIER_CHECK.test(name)\n  );\n}\n", "import { Feature } from '../compat';\nimport {\n  CONSTANT_STRING,\n  ERROR_CONSTRUCTOR_STRING,\n  NIL,\n  SerovalNodeType,\n  SerovalObjectFlags,\n  SYMBOL_STRING,\n} from '../constants';\nimport {\n  SERIALIZED_ASYNC_ITERATOR_CONSTRUCTOR,\n  SERIALIZED_ITERATOR_CONSTRUCTOR,\n} from '../constructors';\nimport {\n  SerovalMissingPluginError,\n  SerovalSerializationError,\n  SerovalUnsupportedNodeError,\n} from '../errors';\nimport { createEffectfulFunction, createFunction } from '../function-string';\nimport { GLOBAL_CONTEXT_REFERENCES, REFERENCES_KEY } from '../keys';\nimport type { PluginAccessOptions } from '../plugin';\nimport { SerovalMode } from '../plugin';\nimport { SPECIAL_REF_STRING } from '../special-reference';\nimport { serializeString } from '../string';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayBufferNode,\n  SerovalArrayNode,\n  SerovalAsyncIteratorFactoryInstanceNode,\n  SerovalAsyncIteratorFactoryNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalDateNode,\n  SerovalErrorNode,\n  SerovalIndexedValueNode,\n  SerovalIteratorFactoryInstanceNode,\n  SerovalIteratorFactoryNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNodeWithID,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseConstructorNode,\n  SerovalPromiseNode,\n  SerovalPromiseRejectNode,\n  SerovalPromiseResolveNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalSetNode,\n  SerovalStreamConstructorNode,\n  SerovalStreamNextNode,\n  SerovalStreamReturnNode,\n  SerovalStreamThrowNode,\n  SerovalTypedArrayNode,\n} from '../types';\nimport getIdentifier from '../utils/get-identifier';\nimport { isValidIdentifier } from '../utils/is-valid-identifier';\n\nconst enum AssignmentType {\n  Index = 0,\n  Add = 1,\n  Set = 2,\n  Delete = 3,\n}\n\ninterface IndexAssignment {\n  t: AssignmentType.Index;\n  s: string;\n  k: undefined;\n  v: string;\n}\n\ninterface SetAssignment {\n  t: AssignmentType.Set;\n  s: string;\n  k: string;\n  v: string;\n}\n\ninterface AddAssignment {\n  t: AssignmentType.Add;\n  s: string;\n  k: undefined;\n  v: string;\n}\n\ninterface DeleteAssignment {\n  t: AssignmentType.Delete;\n  s: string;\n  k: string;\n  v: undefined;\n}\n\n// Array of assignments to be done (used for recursion)\ntype Assignment =\n  | IndexAssignment\n  | AddAssignment\n  | SetAssignment\n  | DeleteAssignment;\n\nexport interface FlaggedObject {\n  type: SerovalObjectFlags;\n  value: string;\n}\n\nfunction getAssignmentExpression(assignment: Assignment): string {\n  switch (assignment.t) {\n    case AssignmentType.Index:\n      return assignment.s + '=' + assignment.v;\n    case AssignmentType.Set:\n      return assignment.s + '.set(' + assignment.k + ',' + assignment.v + ')';\n    case AssignmentType.Add:\n      return assignment.s + '.add(' + assignment.v + ')';\n    case AssignmentType.Delete:\n      return assignment.s + '.delete(' + assignment.k + ')';\n  }\n}\n\nfunction mergeAssignments(assignments: Assignment[]): Assignment[] {\n  const newAssignments: Assignment[] = [];\n  let current = assignments[0];\n  for (\n    let i = 1, len = assignments.length, item: Assignment, prev = current;\n    i < len;\n    i++\n  ) {\n    item = assignments[i];\n    if (item.t === AssignmentType.Index && item.v === prev.v) {\n      // Merge if the right-hand value is the same\n      // saves at least 2 chars\n      current = {\n        t: AssignmentType.Index,\n        s: item.s,\n        k: NIL,\n        v: getAssignmentExpression(current),\n      } as IndexAssignment;\n    } else if (item.t === AssignmentType.Set && item.s === prev.s) {\n      // Maps has chaining methods, merge if source is the same\n      current = {\n        t: AssignmentType.Set,\n        s: getAssignmentExpression(current),\n        k: item.k,\n        v: item.v,\n      } as SetAssignment;\n    } else if (item.t === AssignmentType.Add && item.s === prev.s) {\n      // Sets has chaining methods too\n      current = {\n        t: AssignmentType.Add,\n        s: getAssignmentExpression(current),\n        k: NIL,\n        v: item.v,\n      } as AddAssignment;\n    } else if (item.t === AssignmentType.Delete && item.s === prev.s) {\n      // Maps has chaining methods, merge if source is the same\n      current = {\n        t: AssignmentType.Delete,\n        s: getAssignmentExpression(current),\n        k: item.k,\n        v: NIL,\n      } as DeleteAssignment;\n    } else {\n      // Different assignment, push current\n      newAssignments.push(current);\n      current = item;\n    }\n    prev = item;\n  }\n\n  newAssignments.push(current);\n\n  return newAssignments;\n}\n\nfunction resolveAssignments(assignments: Assignment[]): string | undefined {\n  if (assignments.length) {\n    let result = '';\n    const merged = mergeAssignments(assignments);\n    for (let i = 0, len = merged.length; i < len; i++) {\n      result += getAssignmentExpression(merged[i]) + ',';\n    }\n    return result;\n  }\n  return NIL;\n}\n\nconst NULL_CONSTRUCTOR = 'Object.create(null)';\nconst SET_CONSTRUCTOR = 'new Set';\nconst MAP_CONSTRUCTOR = 'new Map';\n\nconst PROMISE_RESOLVE = 'Promise.resolve';\nconst PROMISE_REJECT = 'Promise.reject';\n\nconst OBJECT_FLAG_CONSTRUCTOR: Record<SerovalObjectFlags, string | undefined> =\n  {\n    [SerovalObjectFlags.Frozen]: 'Object.freeze',\n    [SerovalObjectFlags.Sealed]: 'Object.seal',\n    [SerovalObjectFlags.NonExtensible]: 'Object.preventExtensions',\n    [SerovalObjectFlags.None]: NIL,\n  };\n\ntype SerovalNodeWithProperties =\n  | SerovalObjectNode\n  | SerovalNullConstructorNode\n  | SerovalAggregateErrorNode\n  | SerovalErrorNode;\n\nexport interface BaseSerializerContextOptions extends PluginAccessOptions {\n  features: number;\n  markedRefs: number[] | Set<number>;\n}\n\nexport interface BaseSerializerContext extends PluginAccessOptions {\n  readonly mode: SerovalMode;\n\n  features: number;\n  /*\n   * To check if an object is synchronously referencing itself\n   */\n  stack: number[];\n  /**\n   * Array of object mutations\n   */\n  flags: FlaggedObject[];\n  /**\n   * Array of assignments to be done (used for recursion)\n   */\n  assignments: Assignment[];\n  /**\n   * Refs that are...referenced\n   */\n  marked: Set<number>;\n}\n\nexport interface CrossContextOptions {\n  scopeId?: string;\n}\n\nexport function createBaseSerializerContext(\n  mode: SerovalMode,\n  options: BaseSerializerContextOptions,\n): BaseSerializerContext {\n  return {\n    mode,\n    plugins: options.plugins,\n    features: options.features,\n    marked: new Set(options.markedRefs),\n    stack: [],\n    flags: [],\n    assignments: [],\n  };\n}\n\nexport interface VanillaSerializerState {\n  valid: Map<number, number>;\n  vars: string[];\n}\n\nfunction createVanillaSerializerState(): VanillaSerializerState {\n  return {\n    valid: new Map(),\n    vars: [],\n  };\n}\n\nexport interface VanillaSerializerContext {\n  mode: SerovalMode.Vanilla;\n  base: BaseSerializerContext;\n  state: VanillaSerializerState;\n  child: SerializePluginContext | undefined;\n}\n\nexport type VanillaSerializerContextOptions = BaseSerializerContextOptions;\n\nexport function createVanillaSerializerContext(\n  options: VanillaSerializerContextOptions,\n): VanillaSerializerContext {\n  return {\n    mode: SerovalMode.Vanilla,\n    base: createBaseSerializerContext(SerovalMode.Vanilla, options),\n    state: createVanillaSerializerState(),\n    child: NIL,\n  };\n}\n\nexport interface CrossSerializerContext {\n  mode: SerovalMode.Cross;\n  base: BaseSerializerContext;\n  state: CrossContextOptions;\n  child: SerializePluginContext | undefined;\n}\n\nexport interface CrossSerializerContextOptions\n  extends BaseSerializerContextOptions,\n    CrossContextOptions {\n  // empty\n}\n\nexport function createCrossSerializerContext(\n  options: CrossSerializerContextOptions,\n): CrossSerializerContext {\n  return {\n    mode: SerovalMode.Cross,\n    base: createBaseSerializerContext(SerovalMode.Cross, options),\n    state: options,\n    child: NIL,\n  };\n}\n\ntype SerializerContext = VanillaSerializerContext | CrossSerializerContext;\n\nexport class SerializePluginContext {\n  constructor(private _p: SerializerContext) {}\n\n  serialize(node: SerovalNode) {\n    return serialize(this._p, node);\n  }\n}\n\n/**\n * Creates the reference param (identifier) from the given reference ID\n * Calling this function means the value has been referenced somewhere\n */\nfunction getVanillaRefParam(\n  state: VanillaSerializerState,\n  index: number,\n): string {\n  /**\n   * Creates a new reference ID from a given reference ID\n   * This new reference ID means that the reference itself\n   * has been referenced at least once, and is used to generate\n   * the variables\n   */\n  let actualIndex = state.valid.get(index);\n  if (actualIndex == null) {\n    actualIndex = state.valid.size;\n    state.valid.set(index, actualIndex);\n  }\n  let identifier = state.vars[actualIndex];\n  if (identifier == null) {\n    identifier = getIdentifier(actualIndex);\n    state.vars[actualIndex] = identifier;\n  }\n  return identifier;\n}\n\nfunction getCrossRefParam(id: number): string {\n  return GLOBAL_CONTEXT_REFERENCES + '[' + id + ']';\n}\n\n/**\n * Converts the ID of a reference into a identifier string\n * that is used to refer to the object instance in the\n * generated script.\n */\nfunction getRefParam(ctx: SerializerContext, id: number): string {\n  return ctx.mode === SerovalMode.Vanilla\n    ? getVanillaRefParam(ctx.state, id)\n    : getCrossRefParam(id);\n}\n\nfunction markSerializerRef(ctx: BaseSerializerContext, id: number): void {\n  ctx.marked.add(id);\n}\n\nfunction isSerializerRefMarked(\n  ctx: BaseSerializerContext,\n  id: number,\n): boolean {\n  return ctx.marked.has(id);\n}\n\nfunction pushObjectFlag(\n  ctx: SerializerContext,\n  flag: SerovalObjectFlags,\n  id: number,\n): void {\n  if (flag !== SerovalObjectFlags.None) {\n    markSerializerRef(ctx.base, id);\n    ctx.base.flags.push({\n      type: flag,\n      value: getRefParam(ctx, id),\n    });\n  }\n}\n\nfunction resolveFlags(ctx: BaseSerializerContext): string | undefined {\n  let result = '';\n  for (let i = 0, current = ctx.flags, len = current.length; i < len; i++) {\n    const flag = current[i];\n    result += OBJECT_FLAG_CONSTRUCTOR[flag.type] + '(' + flag.value + '),';\n  }\n  return result;\n}\n\nfunction resolvePatches(ctx: BaseSerializerContext): string | undefined {\n  const assignments = resolveAssignments(ctx.assignments);\n  const flags = resolveFlags(ctx);\n  if (assignments) {\n    if (flags) {\n      return assignments + flags;\n    }\n    return assignments;\n  }\n  return flags;\n}\n\n/**\n * Generates the inlined assignment for the reference\n * This is different from the assignments array as this one\n * signifies creation rather than mutation\n */\nfunction createAssignment(\n  ctx: BaseSerializerContext,\n  source: string,\n  value: string,\n): void {\n  ctx.assignments.push({\n    t: AssignmentType.Index,\n    s: source,\n    k: NIL,\n    v: value,\n  });\n}\n\nfunction createAddAssignment(\n  ctx: SerializerContext,\n  ref: number,\n  value: string,\n): void {\n  ctx.base.assignments.push({\n    t: AssignmentType.Add,\n    s: getRefParam(ctx, ref),\n    k: NIL,\n    v: value,\n  });\n}\n\nfunction createSetAssignment(\n  ctx: SerializerContext,\n  ref: number,\n  key: string,\n  value: string,\n): void {\n  ctx.base.assignments.push({\n    t: AssignmentType.Set,\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: value,\n  });\n}\n\nfunction createDeleteAssignment(\n  ctx: SerializerContext,\n  ref: number,\n  key: string,\n): void {\n  ctx.base.assignments.push({\n    t: AssignmentType.Delete,\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: NIL,\n  });\n}\n\nfunction createArrayAssign(\n  ctx: SerializerContext,\n  ref: number,\n  index: number | string,\n  value: string,\n): void {\n  createAssignment(ctx.base, getRefParam(ctx, ref) + '[' + index + ']', value);\n}\n\nfunction createObjectAssign(\n  ctx: SerializerContext,\n  ref: number,\n  key: string,\n  value: string,\n): void {\n  createAssignment(ctx.base, getRefParam(ctx, ref) + '.' + key, value);\n}\n\n/**\n * Checks if the value is in the stack. Stack here is a reference\n * structure to know if a object is to be accessed in a TDZ.\n */\nfunction isIndexedValueInStack(\n  ctx: BaseSerializerContext,\n  node: SerovalNode,\n): boolean {\n  return node.t === SerovalNodeType.IndexedValue && ctx.stack.includes(node.i);\n}\n\n/**\n * Produces an assignment expression. `id` generates a reference\n * parameter (through `getRefParam`) and has the option to\n * return the reference parameter directly or assign a value to\n * it.\n */\nfunction assignIndexedValue(\n  ctx: SerializerContext,\n  index: number,\n  value: string,\n): string {\n  if (\n    ctx.mode === SerovalMode.Vanilla &&\n    !isSerializerRefMarked(ctx.base, index)\n  ) {\n    return value;\n  }\n  /**\n   * In cross-reference, we have to assume that\n   * every reference are going to be referenced\n   * in the future, and so we need to store\n   * all of it into the reference array.\n   *\n   * otherwise in vanilla, we only do this if it\n   * is actually referenced\n   */\n  return getRefParam(ctx, index) + '=' + value;\n}\n\nfunction serializeReference(node: SerovalReferenceNode): string {\n  return REFERENCES_KEY + '.get(\"' + node.s + '\")';\n}\n\nfunction serializeArrayItem(\n  ctx: SerializerContext,\n  id: number,\n  item: SerovalNode | 0,\n  index: number,\n): string {\n  // Check if index is a hole\n  if (item) {\n    // Check if item is a parent\n    if (isIndexedValueInStack(ctx.base, item)) {\n      markSerializerRef(ctx.base, id);\n      createArrayAssign(\n        ctx,\n        id,\n        index,\n        getRefParam(ctx, (item as SerovalIndexedValueNode).i),\n      );\n      return '';\n    }\n    return serialize(ctx, item);\n  }\n  return '';\n}\n\nfunction serializeArray(\n  ctx: SerializerContext,\n  node: SerovalArrayNode,\n): string {\n  const id = node.i;\n  const list = node.a;\n  const len = list.length;\n  if (len > 0) {\n    ctx.base.stack.push(id);\n    let values = serializeArrayItem(ctx, id, list[0], 0);\n    // This is different than Map and Set\n    // because we also need to serialize\n    // the holes of the Array\n    let isHoley = values === '';\n    for (let i = 1, item: string; i < len; i++) {\n      item = serializeArrayItem(ctx, id, list[i], i);\n      values += ',' + item;\n      isHoley = item === '';\n    }\n    ctx.base.stack.pop();\n    pushObjectFlag(ctx, node.o, node.i);\n    return '[' + values + (isHoley ? ',]' : ']');\n  }\n  return '[]';\n}\n\nfunction serializeProperty(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  key: SerovalObjectRecordKey,\n  val: SerovalNode,\n): string {\n  if (typeof key === 'string') {\n    const check = Number(key);\n    const isIdentifier =\n      // Test if key is a valid positive number or JS identifier\n      // so that we don't have to serialize the key and wrap with brackets\n      (check >= 0 &&\n        // It's also important to consider that if the key is\n        // indeed numeric, we need to make sure that when\n        // converted back into a string, it's still the same\n        // to the original key. This allows us to differentiate\n        // keys that has numeric formats but in a different\n        // format, which can cause unintentional key declaration\n        // Example: { 0x1: 1 } vs { '0x1': 1 }\n        check.toString() === key) ||\n      isValidIdentifier(key);\n    if (isIndexedValueInStack(ctx.base, val)) {\n      const refParam = getRefParam(ctx, (val as SerovalIndexedValueNode).i);\n      markSerializerRef(ctx.base, source.i);\n      // Strict identifier check, make sure\n      // that it isn't numeric (except NaN)\n      if (isIdentifier && check !== check) {\n        createObjectAssign(ctx, source.i, key, refParam);\n      } else {\n        createArrayAssign(\n          ctx,\n          source.i,\n          isIdentifier ? key : '\"' + key + '\"',\n          refParam,\n        );\n      }\n      return '';\n    }\n    return (isIdentifier ? key : '\"' + key + '\"') + ':' + serialize(ctx, val);\n  }\n  return '[' + serialize(ctx, key) + ']:' + serialize(ctx, val);\n}\n\nfunction serializeProperties(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  record: SerovalObjectRecordNode,\n): string {\n  const keys = record.k;\n  const len = keys.length;\n  if (len > 0) {\n    const values = record.v;\n    ctx.base.stack.push(source.i);\n    let result = serializeProperty(ctx, source, keys[0], values[0]);\n    for (let i = 1, item = result; i < len; i++) {\n      item = serializeProperty(ctx, source, keys[i], values[i]);\n      result += (item && result && ',') + item;\n    }\n    ctx.base.stack.pop();\n    return '{' + result + '}';\n  }\n  return '{}';\n}\n\nfunction serializeObject(\n  ctx: SerializerContext,\n  node: SerovalObjectNode,\n): string {\n  pushObjectFlag(ctx, node.o, node.i);\n  return serializeProperties(ctx, node, node.p);\n}\n\nfunction serializeWithObjectAssign(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  value: SerovalObjectRecordNode,\n  serialized: string,\n): string {\n  const fields = serializeProperties(ctx, source, value);\n  if (fields !== '{}') {\n    return 'Object.assign(' + serialized + ',' + fields + ')';\n  }\n  return serialized;\n}\n\nfunction serializeStringKeyAssignment(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  mainAssignments: Assignment[],\n  key: string,\n  value: SerovalNode,\n): void {\n  const base = ctx.base;\n  const serialized = serialize(ctx, value);\n  const check = Number(key);\n  const isIdentifier =\n    // Test if key is a valid positive number or JS identifier\n    // so that we don't have to serialize the key and wrap with brackets\n    (check >= 0 &&\n      // It's also important to consider that if the key is\n      // indeed numeric, we need to make sure that when\n      // converted back into a string, it's still the same\n      // to the original key. This allows us to differentiate\n      // keys that has numeric formats but in a different\n      // format, which can cause unintentional key declaration\n      // Example: { 0x1: 1 } vs { '0x1': 1 }\n      check.toString() === key) ||\n    isValidIdentifier(key);\n  if (isIndexedValueInStack(base, value)) {\n    // Strict identifier check, make sure\n    // that it isn't numeric (except NaN)\n    if (isIdentifier && check !== check) {\n      createObjectAssign(ctx, source.i, key, serialized);\n    } else {\n      createArrayAssign(\n        ctx,\n        source.i,\n        isIdentifier ? key : '\"' + key + '\"',\n        serialized,\n      );\n    }\n  } else {\n    const parentAssignment = base.assignments;\n    base.assignments = mainAssignments;\n    if (isIdentifier && check !== check) {\n      createObjectAssign(ctx, source.i, key, serialized);\n    } else {\n      createArrayAssign(\n        ctx,\n        source.i,\n        isIdentifier ? key : '\"' + key + '\"',\n        serialized,\n      );\n    }\n    base.assignments = parentAssignment;\n  }\n}\n\nfunction serializeAssignment(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  mainAssignments: Assignment[],\n  key: SerovalObjectRecordKey,\n  value: SerovalNode,\n): void {\n  if (typeof key === 'string') {\n    serializeStringKeyAssignment(ctx, source, mainAssignments, key, value);\n  } else {\n    const base = ctx.base;\n    const parent = base.stack;\n    base.stack = [];\n    const serialized = serialize(ctx, value);\n    base.stack = parent;\n    const parentAssignment = base.assignments;\n    base.assignments = mainAssignments;\n    createArrayAssign(ctx, source.i, serialize(ctx, key), serialized);\n    base.assignments = parentAssignment;\n  }\n}\n\nfunction serializeAssignments(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  node: SerovalObjectRecordNode,\n): string | undefined {\n  const keys = node.k;\n  const len = keys.length;\n  if (len > 0) {\n    const mainAssignments: Assignment[] = [];\n    const values = node.v;\n    ctx.base.stack.push(source.i);\n    for (let i = 0; i < len; i++) {\n      serializeAssignment(ctx, source, mainAssignments, keys[i], values[i]);\n    }\n    ctx.base.stack.pop();\n    return resolveAssignments(mainAssignments);\n  }\n  return NIL;\n}\n\nfunction serializeDictionary(\n  ctx: SerializerContext,\n  node: SerovalNodeWithProperties,\n  init: string,\n): string {\n  if (node.p) {\n    const base = ctx.base;\n    if (base.features & Feature.ObjectAssign) {\n      init = serializeWithObjectAssign(ctx, node, node.p, init);\n    } else {\n      markSerializerRef(base, node.i);\n      const assignments = serializeAssignments(ctx, node, node.p);\n      if (assignments) {\n        return (\n          '(' +\n          assignIndexedValue(ctx, node.i, init) +\n          ',' +\n          assignments +\n          getRefParam(ctx, node.i) +\n          ')'\n        );\n      }\n    }\n  }\n  return init;\n}\n\nfunction serializeNullConstructor(\n  ctx: SerializerContext,\n  node: SerovalNullConstructorNode,\n): string {\n  pushObjectFlag(ctx, node.o, node.i);\n  return serializeDictionary(ctx, node, NULL_CONSTRUCTOR);\n}\n\nfunction serializeDate(node: SerovalDateNode): string {\n  return 'new Date(\"' + node.s + '\")';\n}\n\nfunction serializeRegExp(\n  ctx: SerializerContext,\n  node: SerovalRegExpNode,\n): string {\n  if (ctx.base.features & Feature.RegExp) {\n    return '/' + node.c + '/' + node.m;\n  }\n  throw new SerovalUnsupportedNodeError(node);\n}\n\nfunction serializeSetItem(\n  ctx: SerializerContext,\n  id: number,\n  item: SerovalNode,\n): string {\n  const base = ctx.base;\n  if (isIndexedValueInStack(base, item)) {\n    markSerializerRef(base, id);\n    createAddAssignment(\n      ctx,\n      id,\n      getRefParam(ctx, (item as SerovalIndexedValueNode).i),\n    );\n    return '';\n  }\n  return serialize(ctx, item);\n}\n\nfunction serializeSet(ctx: SerializerContext, node: SerovalSetNode): string {\n  let serialized = SET_CONSTRUCTOR;\n  const items = node.a;\n  const size = items.length;\n  const id = node.i;\n  if (size > 0) {\n    ctx.base.stack.push(id);\n    let result = serializeSetItem(ctx, id, items[0]);\n    for (let i = 1, item = result; i < size; i++) {\n      item = serializeSetItem(ctx, id, items[i]);\n      result += (item && result && ',') + item;\n    }\n    ctx.base.stack.pop();\n    if (result) {\n      serialized += '([' + result + '])';\n    }\n  }\n  return serialized;\n}\n\nfunction serializeMapEntry(\n  ctx: SerializerContext,\n  id: number,\n  key: SerovalNode,\n  val: SerovalNode,\n  sentinel: string,\n): string {\n  const base = ctx.base;\n  if (isIndexedValueInStack(base, key)) {\n    // Create reference for the map instance\n    const keyRef = getRefParam(ctx, (key as SerovalIndexedValueNode).i);\n    markSerializerRef(base, id);\n    // Check if value is a parent\n    if (isIndexedValueInStack(base, val)) {\n      const valueRef = getRefParam(ctx, (val as SerovalIndexedValueNode).i);\n      // Register an assignment since\n      // both key and value are a parent of this\n      // Map instance\n      createSetAssignment(ctx, id, keyRef, valueRef);\n      return '';\n    }\n    // Reset the stack\n    // This is required because the serialized\n    // value is no longer part of the expression\n    // tree and has been moved to the deferred\n    // assignment\n    if (\n      val.t !== SerovalNodeType.IndexedValue &&\n      val.i != null &&\n      isSerializerRefMarked(base, val.i)\n    ) {\n      // We use a trick here using sequence (or comma) expressions\n      // basically we serialize the intended object in place WITHOUT\n      // actually returning it, this is by returning a placeholder\n      // value that we will remove sometime after.\n      const serialized =\n        '(' + serialize(ctx, val) + ',[' + sentinel + ',' + sentinel + '])';\n      createSetAssignment(ctx, id, keyRef, getRefParam(ctx, val.i));\n      createDeleteAssignment(ctx, id, sentinel);\n      return serialized;\n    }\n    const parent = base.stack;\n    base.stack = [];\n    createSetAssignment(ctx, id, keyRef, serialize(ctx, val));\n    base.stack = parent;\n    return '';\n  }\n  if (isIndexedValueInStack(base, val)) {\n    // Create ref for the Map instance\n    const valueRef = getRefParam(ctx, (val as SerovalIndexedValueNode).i);\n    markSerializerRef(base, id);\n    if (\n      key.t !== SerovalNodeType.IndexedValue &&\n      key.i != null &&\n      isSerializerRefMarked(base, key.i)\n    ) {\n      const serialized =\n        '(' + serialize(ctx, key) + ',[' + sentinel + ',' + sentinel + '])';\n      createSetAssignment(ctx, id, getRefParam(ctx, key.i), valueRef);\n      createDeleteAssignment(ctx, id, sentinel);\n      return serialized;\n    }\n    // Reset stack for the key serialization\n    const parent = base.stack;\n    base.stack = [];\n    createSetAssignment(ctx, id, serialize(ctx, key), valueRef);\n    base.stack = parent;\n    return '';\n  }\n\n  return '[' + serialize(ctx, key) + ',' + serialize(ctx, val) + ']';\n}\n\nfunction serializeMap(ctx: SerializerContext, node: SerovalMapNode): string {\n  let serialized = MAP_CONSTRUCTOR;\n  const keys = node.e.k;\n  const size = keys.length;\n  const id = node.i;\n  const sentinel = node.f;\n  const sentinelId = getRefParam(ctx, sentinel.i);\n  const base = ctx.base;\n  if (size > 0) {\n    const vals = node.e.v;\n    base.stack.push(id);\n    let result = serializeMapEntry(ctx, id, keys[0], vals[0], sentinelId);\n    for (let i = 1, item = result; i < size; i++) {\n      item = serializeMapEntry(ctx, id, keys[i], vals[i], sentinelId);\n      result += (item && result && ',') + item;\n    }\n    base.stack.pop();\n    // Check if there are any values\n    // so that the empty Map constructor\n    // can be used instead\n    if (result) {\n      serialized += '([' + result + '])';\n    }\n  }\n  if (sentinel.t === SerovalNodeType.SpecialReference) {\n    markSerializerRef(base, sentinel.i);\n    serialized = '(' + serialize(ctx, sentinel) + ',' + serialized + ')';\n  }\n  return serialized;\n}\n\nfunction serializeArrayBuffer(\n  ctx: SerializerContext,\n  node: SerovalArrayBufferNode,\n): string {\n  return getConstructor(ctx, node.f) + '(\"' + node.s + '\")';\n}\n\nfunction serializeTypedArray(\n  ctx: SerializerContext,\n  node: SerovalTypedArrayNode | SerovalBigIntTypedArrayNode,\n): string {\n  return 'new ' + node.c + '(' + serialize(ctx, node.f) + ',' + node.b + ',' + node.l + ')';\n}\n\nfunction serializeDataView(\n  ctx: SerializerContext,\n  node: SerovalDataViewNode,\n): string {\n  return 'new DataView(' + serialize(ctx, node.f) + ',' + node.b + ',' + node.l + ')';\n}\n\nfunction serializeAggregateError(\n  ctx: SerializerContext,\n  node: SerovalAggregateErrorNode,\n): string {\n  const id = node.i;\n  // `AggregateError` might've been extended\n  // either through class or custom properties\n  // Make sure to assign extra properties\n  ctx.base.stack.push(id);\n  const serialized = serializeDictionary(\n    ctx,\n    node,\n    'new AggregateError([],\"' + node.m + '\")',\n  );\n  ctx.base.stack.pop();\n  return serialized;\n}\n\nfunction serializeError(\n  ctx: SerializerContext,\n  node: SerovalErrorNode,\n): string {\n  return serializeDictionary(\n    ctx,\n    node,\n    'new ' + ERROR_CONSTRUCTOR_STRING[node.s] + '(\"' + node.m + '\")',\n  );\n}\n\nfunction serializePromise(\n  ctx: SerializerContext,\n  node: SerovalPromiseNode,\n): string {\n  let serialized: string;\n  // Check if resolved value is a parent expression\n  const fulfilled = node.f;\n  const id = node.i;\n  const promiseConstructor = node.s ? PROMISE_RESOLVE : PROMISE_REJECT;\n  const base = ctx.base;\n  if (isIndexedValueInStack(base, fulfilled)) {\n    // A Promise trick, reference the value\n    // inside the `then` expression so that\n    // the Promise evaluates after the parent\n    // has initialized\n    const ref = getRefParam(ctx, (fulfilled as SerovalIndexedValueNode).i);\n    serialized =\n      promiseConstructor +\n      (node.s\n        ? '().then(' + createFunction([], ref) + ')'\n        : '().catch(' + createEffectfulFunction([], 'throw ' + ref) + ')');\n  } else {\n    base.stack.push(id);\n    const result = serialize(ctx, fulfilled);\n    base.stack.pop();\n    // just inline the value/reference here\n    serialized = promiseConstructor + '(' + result + ')';\n  }\n  return serialized;\n}\n\nfunction serializeBoxed(\n  ctx: SerializerContext,\n  node: SerovalBoxedNode,\n): string {\n  return 'Object(' + serialize(ctx, node.f) + ')';\n}\n\nfunction getConstructor(\n  ctx: SerializerContext,\n  node: SerovalNodeWithID,\n): string {\n  const current = serialize(ctx, node);\n  return node.t === SerovalNodeType.IndexedValue\n    ? current\n    : '(' + current + ')';\n}\n\nfunction serializePromiseConstructor(\n  ctx: SerializerContext,\n  node: SerovalPromiseConstructorNode,\n): string {\n  if (ctx.mode === SerovalMode.Vanilla) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  const resolver = assignIndexedValue(\n    ctx,\n    node.s,\n    getConstructor(ctx, node.f) + '()',\n  );\n  return '(' + resolver + ').p';\n}\n\nfunction serializePromiseResolve(\n  ctx: SerializerContext,\n  node: SerovalPromiseResolveNode,\n): string {\n  if (ctx.mode === SerovalMode.Vanilla) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  return (\n    getConstructor(ctx, node.a[0]) +\n    '(' +\n    getRefParam(ctx, node.i) +\n    ',' +\n    serialize(ctx, node.a[1]) +\n    ')'\n  );\n}\n\nfunction serializePromiseReject(\n  ctx: SerializerContext,\n  node: SerovalPromiseRejectNode,\n): string {\n  if (ctx.mode === SerovalMode.Vanilla) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  return (\n    getConstructor(ctx, node.a[0]) +\n    '(' +\n    getRefParam(ctx, node.i) +\n    ',' +\n    serialize(ctx, node.a[1]) +\n    ')'\n  );\n}\n\nfunction serializePlugin(\n  ctx: SerializerContext,\n  node: SerovalPluginNode,\n): string {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    for (let i = 0, len = currentPlugins.length; i < len; i++) {\n      const plugin = currentPlugins[i];\n      if (plugin.tag === node.c) {\n        if (ctx.child == null) {\n          ctx.child = new SerializePluginContext(ctx);\n        }\n        return plugin.serialize(node.s, ctx.child, {\n          id: node.i,\n        });\n      }\n    }\n  }\n  throw new SerovalMissingPluginError(node.c);\n}\n\nfunction serializeIteratorFactory(\n  ctx: SerializerContext,\n  node: SerovalIteratorFactoryNode,\n): string {\n  let result = '';\n  let initialized = false;\n  if (node.f.t !== SerovalNodeType.IndexedValue) {\n    markSerializerRef(ctx.base, node.f.i);\n    result = '(' + serialize(ctx, node.f) + ',';\n    initialized = true;\n  }\n  result += assignIndexedValue(\n    ctx,\n    node.i,\n    '(' +\n      SERIALIZED_ITERATOR_CONSTRUCTOR +\n      ')(' +\n      getRefParam(ctx, node.f.i) +\n      ')',\n  );\n  if (initialized) {\n    result += ')';\n  }\n  return result;\n}\n\nfunction serializeIteratorFactoryInstance(\n  ctx: SerializerContext,\n  node: SerovalIteratorFactoryInstanceNode,\n): string {\n  return getConstructor(ctx, node.a[0]) + '(' + serialize(ctx, node.a[1]) + ')';\n}\n\nfunction serializeAsyncIteratorFactory(\n  ctx: SerializerContext,\n  node: SerovalAsyncIteratorFactoryNode,\n): string {\n  const promise = node.a[0];\n  const symbol = node.a[1];\n  const base = ctx.base;\n\n  let result = '';\n\n  if (promise.t !== SerovalNodeType.IndexedValue) {\n    markSerializerRef(base, promise.i);\n    result += '(' + serialize(ctx, promise);\n  }\n  if (symbol.t !== SerovalNodeType.IndexedValue) {\n    markSerializerRef(base, symbol.i);\n    result += (result ? ',' : '(') + serialize(ctx, symbol);\n  }\n  if (result) {\n    result += ',';\n  }\n\n  const iterator = assignIndexedValue(\n    ctx,\n    node.i,\n    '(' +\n      SERIALIZED_ASYNC_ITERATOR_CONSTRUCTOR +\n      ')(' +\n      getRefParam(ctx, symbol.i) +\n      ',' +\n      getRefParam(ctx, promise.i) +\n      ')',\n  );\n\n  if (result) {\n    return result + iterator + ')';\n  }\n\n  return iterator;\n}\n\nfunction serializeAsyncIteratorFactoryInstance(\n  ctx: SerializerContext,\n  node: SerovalAsyncIteratorFactoryInstanceNode,\n): string {\n  return getConstructor(ctx, node.a[0]) + '(' + serialize(ctx, node.a[1]) + ')';\n}\n\nfunction serializeStreamConstructor(\n  ctx: SerializerContext,\n  node: SerovalStreamConstructorNode,\n): string {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    getConstructor(ctx, node.f) + '()',\n  );\n  const len = node.a.length;\n  if (len) {\n    let values = serialize(ctx, node.a[0]);\n    for (let i = 1; i < len; i++) {\n      values += ',' + serialize(ctx, node.a[i]);\n    }\n    return '(' + result + ',' + values + ',' + getRefParam(ctx, node.i) + ')';\n  }\n  return result;\n}\n\nfunction serializeStreamNext(\n  ctx: SerializerContext,\n  node: SerovalStreamNextNode,\n): string {\n  return getRefParam(ctx, node.i) + '.next(' + serialize(ctx, node.f) + ')';\n}\n\nfunction serializeStreamThrow(\n  ctx: SerializerContext,\n  node: SerovalStreamThrowNode,\n): string {\n  return getRefParam(ctx, node.i) + '.throw(' + serialize(ctx, node.f) + ')';\n}\n\nfunction serializeStreamReturn(\n  ctx: SerializerContext,\n  node: SerovalStreamReturnNode,\n): string {\n  return getRefParam(ctx, node.i) + '.return(' + serialize(ctx, node.f) + ')';\n}\n\nfunction serializeAssignable(\n  ctx: SerializerContext,\n  node: SerovalNode,\n): string {\n  switch (node.t) {\n    case SerovalNodeType.WKSymbol:\n      return SYMBOL_STRING[node.s];\n    case SerovalNodeType.Reference:\n      return serializeReference(node);\n    case SerovalNodeType.Array:\n      return serializeArray(ctx, node);\n    case SerovalNodeType.Object:\n      return serializeObject(ctx, node);\n    case SerovalNodeType.NullConstructor:\n      return serializeNullConstructor(ctx, node);\n    case SerovalNodeType.Date:\n      return serializeDate(node);\n    case SerovalNodeType.RegExp:\n      return serializeRegExp(ctx, node);\n    case SerovalNodeType.Set:\n      return serializeSet(ctx, node);\n    case SerovalNodeType.Map:\n      return serializeMap(ctx, node);\n    case SerovalNodeType.ArrayBuffer:\n      return serializeArrayBuffer(ctx, node);\n    case SerovalNodeType.BigIntTypedArray:\n    case SerovalNodeType.TypedArray:\n      return serializeTypedArray(ctx, node);\n    case SerovalNodeType.DataView:\n      return serializeDataView(ctx, node);\n    case SerovalNodeType.AggregateError:\n      return serializeAggregateError(ctx, node);\n    case SerovalNodeType.Error:\n      return serializeError(ctx, node);\n    case SerovalNodeType.Promise:\n      return serializePromise(ctx, node);\n    case SerovalNodeType.Boxed:\n      return serializeBoxed(ctx, node);\n    case SerovalNodeType.PromiseConstructor:\n      return serializePromiseConstructor(ctx, node);\n    case SerovalNodeType.Plugin:\n      return serializePlugin(ctx, node);\n    case SerovalNodeType.SpecialReference:\n      return SPECIAL_REF_STRING[node.s];\n    default:\n      throw new SerovalUnsupportedNodeError(node);\n  }\n}\n\nfunction serialize(ctx: SerializerContext, node: SerovalNode): string {\n  switch (node.t) {\n    case SerovalNodeType.Constant:\n      return CONSTANT_STRING[node.s];\n    case SerovalNodeType.Number:\n      return '' + node.s;\n    case SerovalNodeType.String:\n      return '\"' + node.s + '\"';\n    case SerovalNodeType.BigInt:\n      return node.s + 'n';\n    case SerovalNodeType.IndexedValue:\n      return getRefParam(ctx, node.i);\n    case SerovalNodeType.PromiseSuccess:\n      return serializePromiseResolve(ctx, node);\n    case SerovalNodeType.PromiseFailure:\n      return serializePromiseReject(ctx, node);\n    case SerovalNodeType.IteratorFactory:\n      return serializeIteratorFactory(ctx, node);\n    case SerovalNodeType.IteratorFactoryInstance:\n      return serializeIteratorFactoryInstance(ctx, node);\n    case SerovalNodeType.AsyncIteratorFactory:\n      return serializeAsyncIteratorFactory(ctx, node);\n    case SerovalNodeType.AsyncIteratorFactoryInstance:\n      return serializeAsyncIteratorFactoryInstance(ctx, node);\n    case SerovalNodeType.StreamConstructor:\n      return serializeStreamConstructor(ctx, node);\n    case SerovalNodeType.StreamNext:\n      return serializeStreamNext(ctx, node);\n    case SerovalNodeType.StreamThrow:\n      return serializeStreamThrow(ctx, node);\n    case SerovalNodeType.StreamReturn:\n      return serializeStreamReturn(ctx, node);\n    default:\n      return assignIndexedValue(ctx, node.i, serializeAssignable(ctx, node));\n  }\n}\n\nexport function serializeRoot(\n  ctx: SerializerContext,\n  node: SerovalNode,\n): string {\n  try {\n    return serialize(ctx, node);\n  } catch (error) {\n    throw error instanceof SerovalSerializationError\n      ? error\n      : new SerovalSerializationError(error);\n  }\n}\n\nexport function serializeTopVanilla(\n  ctx: VanillaSerializerContext,\n  tree: SerovalNode,\n): string {\n  const result = serialize(ctx, tree);\n  // Shared references detected\n  if (tree.i != null && ctx.state.vars.length) {\n    const patches = resolvePatches(ctx.base);\n    let body = result;\n    if (patches) {\n      // Get (or create) a ref from the source\n      const index = getRefParam(ctx, tree.i);\n      body = result + ',' + patches + index;\n      if (!result.startsWith(index + '=')) {\n        body = index + '=' + body;\n      }\n      body = '(' + body + ')';\n    }\n    return '(' + createFunction(ctx.state.vars, body) + ')()';\n  }\n  if (tree.t === SerovalNodeType.Object) {\n    return '(' + result + ')';\n  }\n  return result;\n}\n\nexport function serializeTopCross(\n  ctx: CrossSerializerContext,\n  tree: SerovalNode,\n): string {\n  // Get the serialized result\n  const result = serialize(ctx, tree);\n  // If the node is a non-reference, return\n  // the result immediately\n  const id = tree.i;\n  if (id == null) {\n    return result;\n  }\n  // Get the patches\n  const patches = resolvePatches(ctx.base);\n  // Get the variable that represents the root\n  const ref = getRefParam(ctx, id);\n  const scopeId = ctx.state.scopeId;\n  // Parameters needed for scoping\n  const params = scopeId == null ? '' : GLOBAL_CONTEXT_REFERENCES;\n  // If there are patches, append it after the result\n  const body = patches ? '(' + result + ',' + patches + ref + ')' : result;\n  // If there are no params, there's no need to generate a function\n  if (params === '') {\n    if (tree.t === SerovalNodeType.Object && !patches) {\n      return '(' + body + ')';\n    }\n    return body;\n  }\n  // Get the arguments for the IIFE\n  const args =\n    scopeId == null\n      ? '()'\n      : '(' +\n        GLOBAL_CONTEXT_REFERENCES +\n        '[\"' +\n        serializeString(scopeId) +\n        '\"])';\n  // Create the IIFE\n  return '(' + createFunction([params], body) + ')' + args;\n}\n", "import {\n  createAggregateErrorNode,\n  createArrayNode,\n  createAsyncIteratorFactoryInstanceNode,\n  createBigIntNode,\n  createBigIntTypedArrayNode,\n  createBoxedNode,\n  createDataViewNode,\n  createDateNode,\n  createErrorNode,\n  createIteratorFactoryInstanceNode,\n  createNumberNode,\n  createPluginNode,\n  createRegExpNode,\n  createSetNode,\n  createStreamConstructorNode,\n  createStreamNextNode,\n  createStreamReturnNode,\n  createStreamThrowNode,\n  createStringNode,\n  createTypedArrayNode,\n} from '../base-primitives';\nimport { Feature } from '../compat';\nimport { NIL, SerovalNodeType } from '../constants';\nimport {\n  SerovalDepthLimitError,\n  SerovalParserError,\n  SerovalUnsupportedTypeError,\n} from '../errors';\nimport { FALSE_NODE, NULL_NODE, TRUE_NODE, UNDEFINED_NODE } from '../literals';\nimport { createSerovalNode } from '../node';\nimport { OpaqueReference } from '../opaque-reference';\nimport { type Plugin, SerovalMode } from '../plugin';\nimport { SpecialReference } from '../special-reference';\nimport type { Stream } from '../stream';\nimport {\n  createStream,\n  createStreamFromAsyncIterable,\n  isStream,\n} from '../stream';\nimport { serializeString } from '../string';\nimport {\n  SYM_ASYNC_ITERATOR,\n  SYM_IS_CONCAT_SPREADABLE,\n  SYM_ITERATOR,\n  SYM_TO_STRING_TAG,\n} from '../symbols';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalErrorNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseConstructorNode,\n  SerovalSetNode,\n  SerovalTypedArrayNode,\n} from '../types';\nimport { getErrorOptions } from '../utils/error';\nimport { iteratorToSequence } from '../utils/iterator-to-sequence';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../utils/typed-array';\nimport type { BaseParserContext, BaseParserContextOptions } from './parser';\nimport {\n  createArrayBufferNode,\n  createBaseParserContext,\n  createIndexForValue,\n  createMapNode,\n  createObjectNode,\n  createPromiseConstructorNode,\n  getReferenceNode,\n  parseAsyncIteratorFactory,\n  parseIteratorFactory,\n  ParserNodeType,\n  parseSpecialReference,\n  parseWellKnownSymbol,\n} from './parser';\n\ntype ObjectLikeNode = SerovalObjectNode | SerovalNullConstructorNode;\n\nexport type SyncParserContextOptions = BaseParserContextOptions;\n\nconst enum ParserMode {\n  Sync = 1,\n  Stream = 2,\n}\n\nexport interface SyncParserContext {\n  type: ParserMode.Sync;\n  base: BaseParserContext;\n  child: SyncParsePluginContext | undefined;\n}\n\nexport function createSyncParserContext(\n  mode: SerovalMode,\n  options: SyncParserContextOptions,\n): SyncParserContext {\n  return {\n    type: ParserMode.Sync,\n    base: createBaseParserContext(mode, options),\n    child: NIL,\n  };\n}\n\nexport class SyncParsePluginContext {\n  constructor(\n    private _p: SyncParserContext,\n    private depth: number,\n  ) {}\n\n  parse<T>(current: T): SerovalNode {\n    return parseSOS(this._p, this.depth, current);\n  }\n}\n\nexport interface StreamParserContextOptions extends SyncParserContextOptions {\n  onParse: (node: SerovalNode, initial: boolean) => void;\n  onError?: (error: unknown) => void;\n  onDone?: () => void;\n}\n\nexport interface StreamParserContext {\n  type: ParserMode.Stream;\n  base: BaseParserContext;\n  state: StreamParserState;\n}\nexport class StreamParsePluginContext {\n  constructor(\n    private _p: StreamParserContext,\n    private depth: number,\n  ) {}\n\n  parse<T>(current: T): SerovalNode {\n    return parseSOS(this._p, this.depth, current);\n  }\n\n  parseWithError<T>(current: T): SerovalNode | undefined {\n    return parseWithError(this._p, this.depth, current);\n  }\n\n  isAlive(): boolean {\n    return this._p.state.alive;\n  }\n\n  pushPendingState(): void {\n    pushPendingState(this._p);\n  }\n\n  popPendingState(): void {\n    popPendingState(this._p);\n  }\n\n  onParse(node: SerovalNode): void {\n    onParse(this._p, node);\n  }\n\n  onError(error: unknown): void {\n    onError(this._p, error);\n  }\n}\n\ninterface StreamParserState {\n  // Life cycle\n  alive: boolean;\n  // Number of pending things\n  pending: number;\n  //\n  initial: boolean;\n  //\n  buffer: SerovalNode[];\n  // Callbacks\n  onParse: (node: SerovalNode, initial: boolean) => void;\n  onError?: (error: unknown) => void;\n  onDone?: () => void;\n}\n\nfunction createStreamParserState(\n  options: StreamParserContextOptions,\n): StreamParserState {\n  return {\n    alive: true,\n    pending: 0,\n    initial: true,\n    buffer: [],\n    onParse: options.onParse,\n    onError: options.onError,\n    onDone: options.onDone,\n  };\n}\n\nexport function createStreamParserContext(\n  options: StreamParserContextOptions,\n): StreamParserContext {\n  return {\n    type: ParserMode.Stream,\n    base: createBaseParserContext(SerovalMode.Cross, options),\n    state: createStreamParserState(options),\n  };\n}\n\ntype SOSParserContext = SyncParserContext | StreamParserContext;\n\nfunction parseItems(\n  ctx: SOSParserContext,\n  depth: number,\n  current: unknown[],\n): (SerovalNode | 0)[] {\n  const nodes: (SerovalNode | 0)[] = [];\n  for (let i = 0, len = current.length; i < len; i++) {\n    if (i in current) {\n      nodes[i] = parseSOS(ctx, depth, current[i]);\n    } else {\n      nodes[i] = 0;\n    }\n  }\n  return nodes;\n}\n\nfunction parseArray(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: unknown[],\n): SerovalArrayNode {\n  return createArrayNode(id, current, parseItems(ctx, depth, current));\n}\n\nfunction parseProperties(\n  ctx: SOSParserContext,\n  depth: number,\n  properties: Record<string | symbol, unknown>,\n): SerovalObjectRecordNode {\n  const entries = Object.entries(properties);\n  const keyNodes: SerovalObjectRecordKey[] = [];\n  const valueNodes: SerovalNode[] = [];\n  for (let i = 0, len = entries.length; i < len; i++) {\n    keyNodes.push(serializeString(entries[i][0]));\n    valueNodes.push(parseSOS(ctx, depth, entries[i][1]));\n  }\n  // Check special properties, symbols in this case\n  if (SYM_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ITERATOR));\n    valueNodes.push(\n      createIteratorFactoryInstanceNode(\n        parseIteratorFactory(ctx.base),\n        parseSOS(\n          ctx,\n          depth,\n          iteratorToSequence(properties as unknown as Iterable<unknown>),\n        ),\n      ),\n    );\n  }\n  if (SYM_ASYNC_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ASYNC_ITERATOR));\n    valueNodes.push(\n      createAsyncIteratorFactoryInstanceNode(\n        parseAsyncIteratorFactory(ctx.base),\n        parseSOS(\n          ctx,\n          depth,\n          ctx.type === ParserMode.Sync\n            ? createStream()\n            : createStreamFromAsyncIterable(\n                properties as unknown as AsyncIterable<unknown>,\n              ),\n        ),\n      ),\n    );\n  }\n  if (SYM_TO_STRING_TAG in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_TO_STRING_TAG));\n    valueNodes.push(createStringNode(properties[SYM_TO_STRING_TAG] as string));\n  }\n  if (SYM_IS_CONCAT_SPREADABLE in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_IS_CONCAT_SPREADABLE));\n    valueNodes.push(\n      properties[SYM_IS_CONCAT_SPREADABLE] ? TRUE_NODE : FALSE_NODE,\n    );\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n  };\n}\n\nfunction parsePlainObject(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: Record<string, unknown>,\n  empty: boolean,\n): ObjectLikeNode {\n  return createObjectNode(\n    id,\n    current,\n    empty,\n    parseProperties(ctx, depth, current),\n  );\n}\n\nfunction parseBoxed(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: object,\n): SerovalBoxedNode {\n  return createBoxedNode(id, parseSOS(ctx, depth, current.valueOf()));\n}\n\nfunction parseTypedArray(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: TypedArrayValue,\n): SerovalTypedArrayNode {\n  return createTypedArrayNode(\n    id,\n    current,\n    parseSOS(ctx, depth, current.buffer),\n  );\n}\n\nfunction parseBigIntTypedArray(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: BigIntTypedArrayValue,\n): SerovalBigIntTypedArrayNode {\n  return createBigIntTypedArrayNode(\n    id,\n    current,\n    parseSOS(ctx, depth, current.buffer),\n  );\n}\n\nfunction parseDataView(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: DataView,\n): SerovalDataViewNode {\n  return createDataViewNode(id, current, parseSOS(ctx, depth, current.buffer));\n}\n\nfunction parseError(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: Error,\n): SerovalErrorNode {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createErrorNode(\n    id,\n    current,\n    options ? parseProperties(ctx, depth, options) : NIL,\n  );\n}\n\nfunction parseAggregateError(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: AggregateError,\n): SerovalAggregateErrorNode {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createAggregateErrorNode(\n    id,\n    current,\n    options ? parseProperties(ctx, depth, options) : NIL,\n  );\n}\n\nfunction parseMap(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: Map<unknown, unknown>,\n): SerovalMapNode {\n  const keyNodes: SerovalNode[] = [];\n  const valueNodes: SerovalNode[] = [];\n  for (const [key, value] of current.entries()) {\n    keyNodes.push(parseSOS(ctx, depth, key));\n    valueNodes.push(parseSOS(ctx, depth, value));\n  }\n  return createMapNode(ctx.base, id, keyNodes, valueNodes);\n}\n\nfunction parseSet(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: Set<unknown>,\n): SerovalSetNode {\n  const items: SerovalNode[] = [];\n  for (const item of current.keys()) {\n    items.push(parseSOS(ctx, depth, item));\n  }\n  return createSetNode(id, items);\n}\n\nfunction parseStream(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: Stream<unknown>,\n): SerovalNode {\n  const result = createStreamConstructorNode(\n    id,\n    parseSpecialReference(ctx.base, SpecialReference.StreamConstructor),\n    [],\n  );\n  if (ctx.type === ParserMode.Sync) {\n    return result;\n  }\n  pushPendingState(ctx);\n  current.on({\n    next: value => {\n      if (ctx.state.alive) {\n        const parsed = parseWithError(ctx, depth, value);\n        if (parsed) {\n          onParse(ctx, createStreamNextNode(id, parsed));\n        }\n      }\n    },\n    throw: value => {\n      if (ctx.state.alive) {\n        const parsed = parseWithError(ctx, depth, value);\n        if (parsed) {\n          onParse(ctx, createStreamThrowNode(id, parsed));\n        }\n      }\n      popPendingState(ctx);\n    },\n    return: value => {\n      if (ctx.state.alive) {\n        const parsed = parseWithError(ctx, depth, value);\n        if (parsed) {\n          onParse(ctx, createStreamReturnNode(id, parsed));\n        }\n      }\n      popPendingState(ctx);\n    },\n  });\n  return result;\n}\n\nfunction handlePromiseSuccess(\n  this: StreamParserContext,\n  id: number,\n  depth: number,\n  data: unknown,\n): void {\n  if (this.state.alive) {\n    const parsed = parseWithError(this, depth, data);\n    if (parsed) {\n      onParse(\n        this,\n        createSerovalNode(\n          SerovalNodeType.PromiseSuccess,\n          id,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          [\n            parseSpecialReference(this.base, SpecialReference.PromiseSuccess),\n            parsed,\n          ],\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n        ),\n      );\n    }\n    popPendingState(this);\n  }\n}\n\nfunction handlePromiseFailure(\n  this: StreamParserContext,\n  id: number,\n  depth: number,\n  data: unknown,\n): void {\n  if (this.state.alive) {\n    const parsed = parseWithError(this, depth, data);\n    if (parsed) {\n      onParse(\n        this,\n        createSerovalNode(\n          SerovalNodeType.PromiseFailure,\n          id,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          [\n            parseSpecialReference(this.base, SpecialReference.PromiseFailure),\n            parsed,\n          ],\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n        ),\n      );\n    }\n  }\n  popPendingState(this);\n}\n\nfunction parsePromise(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: Promise<unknown>,\n): SerovalPromiseConstructorNode {\n  // Creates a unique reference for the promise resolver\n  const resolver = createIndexForValue(ctx.base, {});\n  if (ctx.type === ParserMode.Stream) {\n    pushPendingState(ctx);\n    current.then(\n      handlePromiseSuccess.bind(ctx, resolver, depth),\n      handlePromiseFailure.bind(ctx, resolver, depth),\n    );\n  }\n  return createPromiseConstructorNode(ctx.base, id, resolver);\n}\n\nfunction parsePluginSync(\n  ctx: SyncParserContext,\n  depth: number,\n  id: number,\n  current: unknown,\n  currentPlugins: Plugin<any, any>[],\n): SerovalPluginNode | undefined {\n  for (let i = 0, len = currentPlugins.length; i < len; i++) {\n    const plugin = currentPlugins[i];\n    if (plugin.parse.sync && plugin.test(current)) {\n      return createPluginNode(\n        id,\n        plugin.tag,\n        plugin.parse.sync(current, new SyncParsePluginContext(ctx, depth), {\n          id,\n        }),\n      );\n    }\n  }\n  return NIL;\n}\n\nfunction parsePluginStream(\n  ctx: StreamParserContext,\n  depth: number,\n  id: number,\n  current: unknown,\n  currentPlugins: Plugin<any, any>[],\n): SerovalPluginNode | undefined {\n  for (let i = 0, len = currentPlugins.length; i < len; i++) {\n    const plugin = currentPlugins[i];\n    if (plugin.parse.stream && plugin.test(current)) {\n      return createPluginNode(\n        id,\n        plugin.tag,\n        plugin.parse.stream(current, new StreamParsePluginContext(ctx, depth), {\n          id,\n        }),\n      );\n    }\n  }\n  return NIL;\n}\n\nfunction parsePlugin(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: unknown,\n): SerovalPluginNode | undefined {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    return ctx.type === ParserMode.Sync\n      ? parsePluginSync(ctx, depth, id, current, currentPlugins)\n      : parsePluginStream(ctx, depth, id, current, currentPlugins);\n  }\n  return NIL;\n}\n\nfunction parseObjectPhase2(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: object,\n  currentClass: unknown,\n): SerovalNode {\n  switch (currentClass) {\n    case Object:\n      return parsePlainObject(\n        ctx,\n        depth,\n        id,\n        current as Record<string, unknown>,\n        false,\n      );\n    case NIL:\n      return parsePlainObject(\n        ctx,\n        depth,\n        id,\n        current as Record<string, unknown>,\n        true,\n      );\n    case Date:\n      return createDateNode(id, current as unknown as Date);\n    case Error:\n    case EvalError:\n    case RangeError:\n    case ReferenceError:\n    case SyntaxError:\n    case TypeError:\n    case URIError:\n      return parseError(ctx, depth, id, current as unknown as Error);\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n      return parseBoxed(ctx, depth, id, current);\n    case ArrayBuffer:\n      return createArrayBufferNode(\n        ctx.base,\n        id,\n        current as unknown as ArrayBuffer,\n      );\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n      return parseTypedArray(\n        ctx,\n        depth,\n        id,\n        current as unknown as TypedArrayValue,\n      );\n    case DataView:\n      return parseDataView(ctx, depth, id, current as unknown as DataView);\n    case Map:\n      return parseMap(\n        ctx,\n        depth,\n        id,\n        current as unknown as Map<unknown, unknown>,\n      );\n    case Set:\n      return parseSet(ctx, depth, id, current as unknown as Set<unknown>);\n    default:\n      break;\n  }\n  // Promises\n  if (currentClass === Promise || current instanceof Promise) {\n    return parsePromise(ctx, depth, id, current as unknown as Promise<unknown>);\n  }\n  const currentFeatures = ctx.base.features;\n  if (currentFeatures & Feature.RegExp && currentClass === RegExp) {\n    return createRegExpNode(id, current as unknown as RegExp);\n  }\n  // BigInt Typed Arrays\n  if (currentFeatures & Feature.BigIntTypedArray) {\n    switch (currentClass) {\n      case BigInt64Array:\n      case BigUint64Array:\n        return parseBigIntTypedArray(\n          ctx,\n          depth,\n          id,\n          current as unknown as BigIntTypedArrayValue,\n        );\n      default:\n        break;\n    }\n  }\n  if (\n    currentFeatures & Feature.AggregateError &&\n    typeof AggregateError !== 'undefined' &&\n    (currentClass === AggregateError || current instanceof AggregateError)\n  ) {\n    return parseAggregateError(\n      ctx,\n      depth,\n      id,\n      current as unknown as AggregateError,\n    );\n  }\n  // Slow path. We only need to handle Errors and Iterators\n  // since they have very broad implementations.\n  if (current instanceof Error) {\n    return parseError(ctx, depth, id, current);\n  }\n  // Generator functions don't have a global constructor\n  // despite existing\n  if (SYM_ITERATOR in current || SYM_ASYNC_ITERATOR in current) {\n    return parsePlainObject(ctx, depth, id, current, !!currentClass);\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\n\nfunction parseObject(\n  ctx: SOSParserContext,\n  depth: number,\n  id: number,\n  current: object,\n): SerovalNode {\n  if (Array.isArray(current)) {\n    return parseArray(ctx, depth, id, current);\n  }\n  if (isStream(current)) {\n    return parseStream(ctx, depth, id, current);\n  }\n  const currentClass = current.constructor;\n  if (currentClass === OpaqueReference) {\n    return parseSOS(\n      ctx,\n      depth,\n      (current as OpaqueReference<unknown, unknown>).replacement,\n    );\n  }\n  const parsed = parsePlugin(ctx, depth, id, current);\n  if (parsed) {\n    return parsed;\n  }\n  return parseObjectPhase2(ctx, depth, id, current, currentClass);\n}\n\nfunction parseFunction(\n  ctx: SOSParserContext,\n  depth: number,\n  current: unknown,\n): SerovalNode {\n  const ref = getReferenceNode(ctx.base, current);\n  if (ref.type !== ParserNodeType.Fresh) {\n    return ref.value;\n  }\n  const plugin = parsePlugin(ctx, depth, ref.value, current);\n  if (plugin) {\n    return plugin;\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\n\nexport function parseSOS<T>(\n  ctx: SOSParserContext,\n  depth: number,\n  current: T,\n): SerovalNode {\n  if (depth >= ctx.base.depthLimit) {\n    throw new SerovalDepthLimitError(ctx.base.depthLimit);\n  }\n  switch (typeof current) {\n    case 'boolean':\n      return current ? TRUE_NODE : FALSE_NODE;\n    case 'undefined':\n      return UNDEFINED_NODE;\n    case 'string':\n      return createStringNode(current as string);\n    case 'number':\n      return createNumberNode(current as number);\n    case 'bigint':\n      return createBigIntNode(current as bigint);\n    case 'object': {\n      if (current) {\n        const ref = getReferenceNode(ctx.base, current);\n        return ref.type === ParserNodeType.Fresh\n          ? parseObject(ctx, depth + 1, ref.value, current as object)\n          : ref.value;\n      }\n      return NULL_NODE;\n    }\n    case 'symbol':\n      return parseWellKnownSymbol(ctx.base, current);\n    case 'function': {\n      return parseFunction(ctx, depth, current);\n    }\n    default:\n      throw new SerovalUnsupportedTypeError(current);\n  }\n}\n\nexport function parseTop<T>(ctx: SyncParserContext, current: T): SerovalNode {\n  try {\n    return parseSOS(ctx, 0, current);\n  } catch (error) {\n    throw error instanceof SerovalParserError\n      ? error\n      : new SerovalParserError(error);\n  }\n}\n\nfunction onParse(ctx: StreamParserContext, node: SerovalNode): void {\n  // If the value emitted happens to be during parsing, we push to the\n  // buffer and emit after the initial parsing is done.\n  if (ctx.state.initial) {\n    ctx.state.buffer.push(node);\n  } else {\n    onParseInternal(ctx, node, false);\n  }\n}\n\nfunction onError(ctx: StreamParserContext, error: unknown): void {\n  if (ctx.state.onError) {\n    ctx.state.onError(error);\n  } else {\n    throw error instanceof SerovalParserError\n      ? error\n      : new SerovalParserError(error);\n  }\n}\n\nfunction onDone(ctx: StreamParserContext): void {\n  if (ctx.state.onDone) {\n    ctx.state.onDone();\n  }\n}\n\nfunction onParseInternal(\n  ctx: StreamParserContext,\n  node: SerovalNode,\n  initial: boolean,\n): void {\n  try {\n    ctx.state.onParse(node, initial);\n  } catch (error) {\n    onError(ctx, error);\n  }\n}\n\nfunction pushPendingState(ctx: StreamParserContext): void {\n  ctx.state.pending++;\n}\n\nfunction popPendingState(ctx: StreamParserContext): void {\n  if (--ctx.state.pending <= 0) {\n    onDone(ctx);\n  }\n}\n\nfunction parseWithError<T>(\n  ctx: StreamParserContext,\n  depth: number,\n  current: T,\n): SerovalNode | undefined {\n  try {\n    return parseSOS(ctx, depth, current);\n  } catch (err) {\n    onError(ctx, err);\n    return NIL;\n  }\n}\n\nexport function startStreamParse<T>(\n  ctx: StreamParserContext,\n  current: T,\n): void {\n  const parsed = parseWithError(ctx, 0, current);\n  if (parsed) {\n    onParseInternal(ctx, parsed, true);\n    ctx.state.initial = false;\n    flushStreamParse(ctx, ctx.state);\n\n    // Check if there's any pending pushes\n    if (ctx.state.pending <= 0) {\n      destroyStreamParse(ctx);\n    }\n  }\n}\n\nfunction flushStreamParse(\n  ctx: StreamParserContext,\n  state: StreamParserState,\n): void {\n  for (let i = 0, len = state.buffer.length; i < len; i++) {\n    onParseInternal(ctx, state.buffer[i], false);\n  }\n}\n\nexport function destroyStreamParse(ctx: StreamParserContext): void {\n  if (ctx.state.alive) {\n    onDone(ctx);\n    ctx.state.alive = false;\n  }\n}\n", "import type { AsyncParserContextOptions } from '../context/async-parser';\nimport {\n  createAsyncParserContext,\n  parseTopAsync,\n} from '../context/async-parser';\nimport type { CrossDeserializerContextOptions } from '../context/deserializer';\nimport {\n  createCrossDeserializerContext,\n  deserializeTop,\n} from '../context/deserializer';\nimport type { CrossContextOptions } from '../context/serializer';\nimport {\n  createCrossSerializerContext,\n  serializeTopCross,\n} from '../context/serializer';\nimport type {\n  StreamParserContextOptions,\n  SyncParserContextOptions,\n} from '../context/sync-parser';\nimport {\n  createStreamParserContext,\n  createSyncParserContext,\n  destroyStreamParse,\n  parseTop,\n  startStreamParse,\n} from '../context/sync-parser';\nimport { resolvePlugins, SerovalMode } from '../plugin';\nimport type { SerovalNode } from '../types';\n\nexport interface CrossSerializeOptions\n  extends SyncParserContextOptions,\n    CrossContextOptions {}\n\nexport function crossSerialize<T>(\n  source: T,\n  options: CrossSerializeOptions = {},\n): string {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(SerovalMode.Cross, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  const tree = parseTop(ctx, source);\n  const serial = createCrossSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    scopeId: options.scopeId,\n    markedRefs: ctx.base.marked,\n  });\n  return serializeTopCross(serial, tree);\n}\n\nexport interface CrossSerializeAsyncOptions\n  extends AsyncParserContextOptions,\n    CrossContextOptions {}\n\nexport async function crossSerializeAsync<T>(\n  source: T,\n  options: CrossSerializeAsyncOptions = {},\n): Promise<string> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(SerovalMode.Cross, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  const tree = await parseTopAsync(ctx, source);\n  const serial = createCrossSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    scopeId: options.scopeId,\n    markedRefs: ctx.base.marked,\n  });\n  return serializeTopCross(serial, tree);\n}\n\nexport type ToCrossJSONOptions = SyncParserContextOptions;\n\nexport function toCrossJSON<T>(\n  source: T,\n  options: ToCrossJSONOptions = {},\n): SerovalNode {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(SerovalMode.Cross, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  return parseTop(ctx, source);\n}\n\nexport type ToCrossJSONAsyncOptions = AsyncParserContextOptions;\n\nexport async function toCrossJSONAsync<T>(\n  source: T,\n  options: ToCrossJSONAsyncOptions = {},\n): Promise<SerovalNode> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(SerovalMode.Cross, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  return await parseTopAsync(ctx, source);\n}\n\nexport interface CrossSerializeStreamOptions\n  extends Omit<StreamParserContextOptions, 'onParse'>,\n    CrossContextOptions {\n  onSerialize: (data: string, initial: boolean) => void;\n}\n\nexport function crossSerializeStream<T>(\n  source: T,\n  options: CrossSerializeStreamOptions,\n): () => void {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createStreamParserContext({\n    plugins,\n    refs: options.refs,\n    disabledFeatures: options.disabledFeatures,\n    onParse(node, initial): void {\n      const serial = createCrossSerializerContext({\n        plugins,\n        features: ctx.base.features,\n        scopeId: options.scopeId,\n        markedRefs: ctx.base.marked,\n      });\n\n      let serialized: string;\n\n      try {\n        serialized = serializeTopCross(serial, node);\n      } catch (err) {\n        if (options.onError) {\n          options.onError(err);\n        }\n        return;\n      }\n\n      options.onSerialize(serialized, initial);\n    },\n    onError: options.onError,\n    onDone: options.onDone,\n  });\n\n  startStreamParse(ctx, source);\n\n  return destroyStreamParse.bind(null, ctx);\n}\n\nexport type ToCrossJSONStreamOptions = StreamParserContextOptions;\n\nexport function toCrossJSONStream<T>(\n  source: T,\n  options: ToCrossJSONStreamOptions,\n): () => void {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createStreamParserContext({\n    plugins,\n    refs: options.refs,\n    disabledFeatures: options.disabledFeatures,\n    onParse: options.onParse,\n    onError: options.onError,\n    onDone: options.onDone,\n  });\n\n  startStreamParse(ctx, source);\n\n  return destroyStreamParse.bind(null, ctx);\n}\n\nexport type FromCrossJSONOptions = CrossDeserializerContextOptions;\n\nexport function fromCrossJSON<T>(\n  source: SerovalNode,\n  options: FromCrossJSONOptions,\n): T {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createCrossDeserializerContext({\n    plugins,\n    refs: options.refs,\n    features: options.features,\n    disabledFeatures: options.disabledFeatures,\n  });\n  return deserializeTop(ctx, source) as T;\n}\n", "import { crossSerializeStream } from './cross';\nimport {\n  resolvePlugins,\n  type Plugin,\n  type PluginAccessOptions,\n} from './plugin';\nimport { serializeString } from './string';\n\nexport interface SerializerOptions extends PluginAccessOptions {\n  globalIdentifier: string;\n  scopeId?: string;\n  disabledFeatures?: number;\n  onData: (result: string) => void;\n  onError: (error: unknown) => void;\n  onDone?: () => void;\n}\n\nexport default class Serializer {\n  private alive = true;\n\n  private flushed = false;\n\n  private done = false;\n\n  private pending = 0;\n\n  private cleanups: (() => void)[] = [];\n\n  private refs = new Map<unknown, number>();\n\n  private plugins?: Plugin<any, any>[];\n\n  constructor(private options: SerializerOptions) {\n    this.plugins = resolvePlugins(options.plugins);\n  }\n\n  keys = new Set<string>();\n\n  write(key: string, value: unknown): void {\n    if (this.alive && !this.flushed) {\n      this.pending++;\n      this.keys.add(key);\n      this.cleanups.push(\n        crossSerializeStream(value, {\n          plugins: this.plugins,\n          scopeId: this.options.scopeId,\n          refs: this.refs,\n          disabledFeatures: this.options.disabledFeatures,\n          onError: this.options.onError,\n          onSerialize: (data, initial) => {\n            if (this.alive) {\n              this.options.onData(\n                initial\n                  ? this.options.globalIdentifier +\n                      '[\"' +\n                      serializeString(key) +\n                      '\"]=' +\n                      data\n                  : data,\n              );\n            }\n          },\n          onDone: () => {\n            if (this.alive) {\n              this.pending--;\n              if (\n                this.pending <= 0 &&\n                this.flushed &&\n                !this.done &&\n                this.options.onDone\n              ) {\n                this.options.onDone();\n                this.done = true;\n              }\n            }\n          },\n        }),\n      );\n    }\n  }\n\n  ids = 0;\n\n  private getNextID(): string {\n    while (this.keys.has('' + this.ids)) {\n      this.ids++;\n    }\n    return '' + this.ids;\n  }\n\n  push(value: unknown): string {\n    const newID = this.getNextID();\n    this.write(newID, value);\n    return newID;\n  }\n\n  flush(): void {\n    if (this.alive) {\n      this.flushed = true;\n      if (this.pending <= 0 && !this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n    }\n  }\n\n  close(): void {\n    if (this.alive) {\n      for (let i = 0, len = this.cleanups.length; i < len; i++) {\n        this.cleanups[i]();\n      }\n      if (!this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n      this.alive = false;\n    }\n  }\n}\n", "import {\n  createAsyncParserContext,\n  parseTopAsync,\n} from '../context/async-parser';\nimport {\n  createVanillaDeserializerContext,\n  deserializeTop,\n} from '../context/deserializer';\nimport type { BaseParserContextOptions } from '../context/parser';\nimport {\n  createVanillaSerializerContext,\n  serializeTopVanilla,\n} from '../context/serializer';\nimport { createSyncParserContext, parseTop } from '../context/sync-parser';\nimport {\n  type PluginAccessOptions,\n  resolvePlugins,\n  SerovalMode,\n} from '../plugin';\nimport type { SerovalNode } from '../types';\nimport { ALL_ENABLED } from '../compat';\nexport type SyncParserContextOptions = Omit<BaseParserContextOptions, 'refs'>;\nexport type AsyncParserContextOptions = Omit<BaseParserContextOptions, 'refs'>;\n\nexport function serialize<T>(\n  source: T,\n  options: SyncParserContextOptions = {},\n): string {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(SerovalMode.Vanilla, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  const tree = parseTop(ctx, source);\n  const serial = createVanillaSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    markedRefs: ctx.base.marked,\n  });\n  return serializeTopVanilla(serial, tree);\n}\n\nexport async function serializeAsync<T>(\n  source: T,\n  options: AsyncParserContextOptions = {},\n): Promise<string> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(SerovalMode.Vanilla, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  const tree = await parseTopAsync(ctx, source);\n  const serial = createVanillaSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    markedRefs: ctx.base.marked,\n  });\n  return serializeTopVanilla(serial, tree);\n}\n\nexport function deserialize<T>(source: string): T {\n  return (0, eval)(source) as T;\n}\n\nexport interface SerovalJSON {\n  t: SerovalNode;\n  f: number;\n  m: number[];\n}\n\nexport interface FromJSONOptions extends PluginAccessOptions {\n  disabledFeatures?: number;\n}\n\nexport function toJSON<T>(\n  source: T,\n  options: SyncParserContextOptions = {},\n): SerovalJSON {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(SerovalMode.Vanilla, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  return {\n    t: parseTop(ctx, source),\n    f: ctx.base.features,\n    m: Array.from(ctx.base.marked),\n  };\n}\n\nexport async function toJSONAsync<T>(\n  source: T,\n  options: AsyncParserContextOptions = {},\n): Promise<SerovalJSON> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(SerovalMode.Vanilla, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  return {\n    t: await parseTopAsync(ctx, source),\n    f: ctx.base.features,\n    m: Array.from(ctx.base.marked),\n  };\n}\n\nexport function compileJSON(\n  source: SerovalJSON,\n  options: PluginAccessOptions = {},\n): string {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createVanillaSerializerContext({\n    plugins,\n    features: source.f,\n    markedRefs: source.m,\n  });\n  return serializeTopVanilla(ctx, source.t);\n}\n\nexport function fromJSON<T>(\n  source: SerovalJSON,\n  options: FromJSONOptions = {},\n): T {\n  const plugins = resolvePlugins(options.plugins);\n  const disabledFeatures = options.disabledFeatures || 0;\n  const sourceFeatures = source.f ?? ALL_ENABLED;\n  const ctx = createVanillaDeserializerContext({\n    plugins,\n    markedRefs: source.m,\n    features: sourceFeatures & ~disabledFeatures,\n    disabledFeatures,\n  });\n  return deserializeTop(ctx, source.t) as T;\n}\n"],
  "mappings": "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",
  "names": ["deserialize", "serialize", "Feature", "index", "SerovalMode", "len", "assignIndexedValue", "parseItems", "parseArray", "parseProperties", "parsePlainObject", "parseBoxed", "parseTypedArray", "parseBigIntTypedArray", "parseDataView", "parseError", "parseAggregateError", "parseMap", "parseSet", "parseStream", "parsePromise", "parsePlugin", "serialize", "deserialize"]
}
