{"version":3,"file":"@dnd-kit_sortable.js","names":[],"sources":["../../@dnd-kit/sortable/dist/sortable.esm.js"],"sourcesContent":["import React, { useMemo, useRef, useEffect, useState, useContext } from 'react';\nimport { useDndContext, getClientRect, useDroppable, useDraggable, closestCorners, getFirstCollision, getScrollableAncestors, KeyboardCode } from '@dnd-kit/core';\nimport { useUniqueId, useIsomorphicLayoutEffect, CSS, useCombinedRefs, isKeyboardEvent, subtract } from '@dnd-kit/utilities';\n\n/**\r\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\r\n */\nfunction arrayMove(array, from, to) {\n  const newArray = array.slice();\n  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);\n  return newArray;\n}\n\n/**\r\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\r\n */\nfunction arraySwap(array, from, to) {\n  const newArray = array.slice();\n  newArray[from] = array[to];\n  newArray[to] = array[from];\n  return newArray;\n}\n\nfunction getSortedRects(items, rects) {\n  return items.reduce((accumulator, id, index) => {\n    const rect = rects.get(id);\n\n    if (rect) {\n      accumulator[index] = rect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n\nfunction isValidIndex(index) {\n  return index !== null && index >= 0;\n}\n\nfunction itemsEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction normalizeDisabled(disabled) {\n  if (typeof disabled === 'boolean') {\n    return {\n      draggable: disabled,\n      droppable: disabled\n    };\n  }\n\n  return disabled;\n}\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1\n};\nconst horizontalListSortingStrategy = _ref => {\n  var _rects$activeIndex;\n\n  let {\n    rects,\n    activeNodeRect: fallbackActiveRect,\n    activeIndex,\n    overIndex,\n    index\n  } = _ref;\n  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  const itemGap = getItemGap(rects, index, activeIndex);\n\n  if (index === activeIndex) {\n    const newIndexRect = rects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return {\n      x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,\n      y: 0,\n      ...defaultScale\n    };\n  }\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale\n  };\n};\n\nfunction getItemGap(rects, index, activeIndex) {\n  const currentRect = rects[index];\n  const previousRect = rects[index - 1];\n  const nextRect = rects[index + 1];\n\n  if (!currentRect || !previousRect && !nextRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);\n  }\n\n  return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);\n}\n\nconst rectSortingStrategy = _ref => {\n  let {\n    rects,\n    activeIndex,\n    overIndex,\n    index\n  } = _ref;\n  const newRects = arrayMove(rects, overIndex, activeIndex);\n  const oldRect = rects[index];\n  const newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n};\n\nconst rectSwappingStrategy = _ref => {\n  let {\n    activeIndex,\n    index,\n    rects,\n    overIndex\n  } = _ref;\n  let oldRect;\n  let newRect;\n\n  if (index === activeIndex) {\n    oldRect = rects[index];\n    newRect = rects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = rects[index];\n    newRect = rects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n};\n\n// To-do: We should be calculating scale transformation\nconst defaultScale$1 = {\n  scaleX: 1,\n  scaleY: 1\n};\nconst verticalListSortingStrategy = _ref => {\n  var _rects$activeIndex;\n\n  let {\n    activeIndex,\n    activeNodeRect: fallbackActiveRect,\n    index,\n    rects,\n    overIndex\n  } = _ref;\n  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    const overIndexRect = rects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return {\n      x: 0,\n      y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,\n      ...defaultScale$1\n    };\n  }\n\n  const itemGap = getItemGap$1(rects, index, activeIndex);\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale$1\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale$1\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale$1\n  };\n};\n\nfunction getItemGap$1(clientRects, index, activeIndex) {\n  const currentRect = clientRects[index];\n  const previousRect = clientRects[index - 1];\n  const nextRect = clientRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;\n  }\n\n  return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;\n}\n\nconst ID_PREFIX = 'Sortable';\nconst Context = /*#__PURE__*/React.createContext({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n  disabled: {\n    draggable: false,\n    droppable: false\n  }\n});\nfunction SortableContext(_ref) {\n  let {\n    children,\n    id,\n    items: userDefinedItems,\n    strategy = rectSortingStrategy,\n    disabled: disabledProp = false\n  } = _ref;\n  const {\n    active,\n    dragOverlay,\n    droppableRects,\n    over,\n    measureDroppableContainers\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(dragOverlay.rect !== null);\n  const items = useMemo(() => userDefinedItems.map(item => typeof item === 'object' && 'id' in item ? item.id : item), [userDefinedItems]);\n  const isDragging = active != null;\n  const activeIndex = active ? items.indexOf(active.id) : -1;\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);\n  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;\n  const disabled = normalizeDisabled(disabledProp);\n  useIsomorphicLayoutEffect(() => {\n    if (itemsHaveChanged && isDragging) {\n      measureDroppableContainers(items);\n    }\n  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);\n  useEffect(() => {\n    previousItemsRef.current = items;\n  }, [items]);\n  const contextValue = useMemo(() => ({\n    activeIndex,\n    containerId,\n    disabled,\n    disableTransforms,\n    items,\n    overIndex,\n    useDragOverlay,\n    sortedRects: getSortedRects(items, droppableRects),\n    strategy\n  }), // eslint-disable-next-line react-hooks/exhaustive-deps\n  [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]);\n  return React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\n\nconst defaultNewIndexGetter = _ref => {\n  let {\n    id,\n    items,\n    activeIndex,\n    overIndex\n  } = _ref;\n  return arrayMove(items, activeIndex, overIndex).indexOf(id);\n};\nconst defaultAnimateLayoutChanges = _ref2 => {\n  let {\n    containerId,\n    isSorting,\n    wasDragging,\n    index,\n    items,\n    newIndex,\n    previousItems,\n    previousContainerId,\n    transition\n  } = _ref2;\n\n  if (!transition || !wasDragging) {\n    return false;\n  }\n\n  if (previousItems !== items && index === newIndex) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index && containerId === previousContainerId;\n};\nconst defaultTransition = {\n  duration: 200,\n  easing: 'ease'\n};\nconst transitionProperty = 'transform';\nconst disabledTransition = /*#__PURE__*/CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear'\n});\nconst defaultAttributes = {\n  roleDescription: 'sortable'\n};\n\n/*\r\n * When the index of an item changes while sorting,\r\n * we need to temporarily disable the transforms\r\n */\n\nfunction useDerivedTransform(_ref) {\n  let {\n    disabled,\n    index,\n    node,\n    rect\n  } = _ref;\n  const [derivedTransform, setDerivedtransform] = useState(null);\n  const previousIndex = useRef(index);\n  useIsomorphicLayoutEffect(() => {\n    if (!disabled && index !== previousIndex.current && node.current) {\n      const initial = rect.current;\n\n      if (initial) {\n        const current = getClientRect(node.current, {\n          ignoreTransform: true\n        });\n        const delta = {\n          x: initial.left - current.left,\n          y: initial.top - current.top,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== previousIndex.current) {\n      previousIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n  useEffect(() => {\n    if (derivedTransform) {\n      setDerivedtransform(null);\n    }\n  }, [derivedTransform]);\n  return derivedTransform;\n}\n\nfunction useSortable(_ref) {\n  let {\n    animateLayoutChanges = defaultAnimateLayoutChanges,\n    attributes: userDefinedAttributes,\n    disabled: localDisabled,\n    data: customData,\n    getNewIndex = defaultNewIndexGetter,\n    id,\n    strategy: localStrategy,\n    resizeObserverConfig,\n    transition = defaultTransition\n  } = _ref;\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disabled: globalDisabled,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy\n  } = useContext(Context);\n  const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);\n  const index = items.indexOf(id);\n  const data = useMemo(() => ({\n    sortable: {\n      containerId,\n      index,\n      items\n    },\n    ...customData\n  }), [containerId, customData, index, items]);\n  const itemsAfterCurrentSortable = useMemo(() => items.slice(items.indexOf(id)), [items, id]);\n  const {\n    rect,\n    node,\n    isOver,\n    setNodeRef: setDroppableNodeRef\n  } = useDroppable({\n    id,\n    data,\n    disabled: disabled.droppable,\n    resizeObserverConfig: {\n      updateMeasurementsFor: itemsAfterCurrentSortable,\n      ...resizeObserverConfig\n    }\n  });\n  const {\n    active,\n    activatorEvent,\n    activeNodeRect,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    setActivatorNodeRef,\n    transform\n  } = useDraggable({\n    id,\n    data,\n    attributes: { ...defaultAttributes,\n      ...userDefinedAttributes\n    },\n    disabled: disabled.draggable\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;\n  const strategy = localStrategy != null ? localStrategy : globalStrategy;\n  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({\n    rects: sortedRects,\n    activeNodeRect,\n    activeIndex,\n    overIndex,\n    index\n  }) : null;\n  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({\n    id,\n    items,\n    activeIndex,\n    overIndex\n  }) : index;\n  const activeId = active == null ? void 0 : active.id;\n  const previous = useRef({\n    activeId,\n    items,\n    newIndex,\n    containerId\n  });\n  const itemsHaveChanged = items !== previous.current.items;\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    containerId,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: previous.current.newIndex,\n    previousItems: previous.current.items,\n    previousContainerId: previous.current.containerId,\n    transition,\n    wasDragging: previous.current.activeId != null\n  });\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect\n  });\n  useEffect(() => {\n    if (isSorting && previous.current.newIndex !== newIndex) {\n      previous.current.newIndex = newIndex;\n    }\n\n    if (containerId !== previous.current.containerId) {\n      previous.current.containerId = containerId;\n    }\n\n    if (items !== previous.current.items) {\n      previous.current.items = items;\n    }\n  }, [isSorting, newIndex, containerId, items]);\n  useEffect(() => {\n    if (activeId === previous.current.activeId) {\n      return;\n    }\n\n    if (activeId != null && previous.current.activeId == null) {\n      previous.current.activeId = activeId;\n      return;\n    }\n\n    const timeoutId = setTimeout(() => {\n      previous.current.activeId = activeId;\n    }, 50);\n    return () => clearTimeout(timeoutId);\n  }, [activeId]);\n  return {\n    active,\n    activeIndex,\n    attributes,\n    data,\n    rect,\n    index,\n    newIndex,\n    items,\n    isOver,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setActivatorNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform != null ? derivedTransform : finalTransform,\n    transition: getTransition()\n  };\n\n  function getTransition() {\n    if ( // Temporarily disable transitions for a single frame to set up derived transforms\n    derivedTransform || // Or to prevent items jumping to back to their \"new\" position when items change\n    itemsHaveChanged && previous.current.newIndex === index) {\n      return disabledTransition;\n    }\n\n    if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {\n      return undefined;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({ ...transition,\n        property: transitionProperty\n      });\n    }\n\n    return undefined;\n  }\n}\n\nfunction normalizeLocalDisabled(localDisabled, globalDisabled) {\n  var _localDisabled$dragga, _localDisabled$droppa;\n\n  if (typeof localDisabled === 'boolean') {\n    return {\n      draggable: localDisabled,\n      // Backwards compatibility\n      droppable: false\n    };\n  }\n\n  return {\n    draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,\n    droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable\n  };\n}\n\nfunction hasSortableData(entry) {\n  if (!entry) {\n    return false;\n  }\n\n  const data = entry.data.current;\n\n  if (data && 'sortable' in data && typeof data.sortable === 'object' && 'containerId' in data.sortable && 'items' in data.sortable && 'index' in data.sortable) {\n    return true;\n  }\n\n  return false;\n}\n\nconst directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];\nconst sortableKeyboardCoordinates = (event, _ref) => {\n  let {\n    context: {\n      active,\n      collisionRect,\n      droppableRects,\n      droppableContainers,\n      over,\n      scrollableAncestors\n    }\n  } = _ref;\n\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!active || !collisionRect) {\n      return;\n    }\n\n    const filteredContainers = [];\n    droppableContainers.getEnabled().forEach(entry => {\n      if (!entry || entry != null && entry.disabled) {\n        return;\n      }\n\n      const rect = droppableRects.get(entry.id);\n\n      if (!rect) {\n        return;\n      }\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (collisionRect.top < rect.top) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n\n        case KeyboardCode.Up:\n          if (collisionRect.top > rect.top) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n\n        case KeyboardCode.Left:\n          if (collisionRect.left > rect.left) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n\n        case KeyboardCode.Right:\n          if (collisionRect.left < rect.left) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n      }\n    });\n    const collisions = closestCorners({\n      active,\n      collisionRect: collisionRect,\n      droppableRects,\n      droppableContainers: filteredContainers,\n      pointerCoordinates: null\n    });\n    let closestId = getFirstCollision(collisions, 'id');\n\n    if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {\n      closestId = collisions[1].id;\n    }\n\n    if (closestId != null) {\n      const activeDroppable = droppableContainers.get(active.id);\n      const newDroppable = droppableContainers.get(closestId);\n      const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n      const newNode = newDroppable == null ? void 0 : newDroppable.node.current;\n\n      if (newNode && newRect && activeDroppable && newDroppable) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some((element, index) => scrollableAncestors[index] !== element);\n        const hasSameContainer = isSameContainer(activeDroppable, newDroppable);\n        const isAfterActive = isAfter(activeDroppable, newDroppable);\n        const offset = hasDifferentScrollAncestors || !hasSameContainer ? {\n          x: 0,\n          y: 0\n        } : {\n          x: isAfterActive ? collisionRect.width - newRect.width : 0,\n          y: isAfterActive ? collisionRect.height - newRect.height : 0\n        };\n        const rectCoordinates = {\n          x: newRect.left,\n          y: newRect.top\n        };\n        const newCoordinates = offset.x && offset.y ? rectCoordinates : subtract(rectCoordinates, offset);\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n\nfunction isSameContainer(a, b) {\n  if (!hasSortableData(a) || !hasSortableData(b)) {\n    return false;\n  }\n\n  return a.data.current.sortable.containerId === b.data.current.sortable.containerId;\n}\n\nfunction isAfter(a, b) {\n  if (!hasSortableData(a) || !hasSortableData(b)) {\n    return false;\n  }\n\n  if (!isSameContainer(a, b)) {\n    return false;\n  }\n\n  return a.data.current.sortable.index < b.data.current.sortable.index;\n}\n\nexport { SortableContext, arrayMove, arraySwap, defaultAnimateLayoutChanges, defaultNewIndexGetter, hasSortableData, horizontalListSortingStrategy, rectSortingStrategy, rectSwappingStrategy, sortableKeyboardCoordinates, useSortable, verticalListSortingStrategy };\n//# sourceMappingURL=sortable.esm.js.map\n"],"mappings":"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"}