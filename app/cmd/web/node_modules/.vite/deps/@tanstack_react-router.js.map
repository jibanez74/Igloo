{"version":3,"file":"@tanstack_react-router.js","names":["isProduction","prefix","trimPathRight","prefix","notFound","lazyFn","\"use\"","intersectionObserverOptions","useRef","subscribe","storageKey","Fragment","ScrollRestoration","Fragment","ScrollRestoration","Fragment","Fragment"],"sources":["../../@tanstack/store/dist/esm/scheduler.js","../../@tanstack/store/dist/esm/types.js","../../@tanstack/store/dist/esm/store.js","../../@tanstack/history/dist/esm/index.js","../../@tanstack/router-core/dist/esm/utils.js","../../tiny-invariant/dist/esm/tiny-invariant.js","../../@tanstack/router-core/dist/esm/lru-cache.js","../../@tanstack/router-core/dist/esm/new-process-route-tree.js","../../@tanstack/router-core/dist/esm/path.js","../../@tanstack/router-core/dist/esm/not-found.js","../../@tanstack/router-core/dist/esm/scroll-restoration.js","../../@tanstack/router-core/dist/esm/qss.js","../../@tanstack/router-core/dist/esm/searchParams.js","../../@tanstack/router-core/dist/esm/root.js","../../@tanstack/router-core/dist/esm/redirect.js","../../@tanstack/router-core/dist/esm/load-matches.js","../../@tanstack/router-core/dist/esm/rewrite.js","../../@tanstack/router-core/dist/esm/router.js","../../@tanstack/router-core/dist/esm/defer.js","../../@tanstack/router-core/dist/esm/link.js","../../@tanstack/router-core/dist/esm/Matches.js","../../@tanstack/router-core/dist/esm/route.js","../../@tanstack/router-core/dist/esm/config.js","../../@tanstack/router-core/dist/esm/searchMiddleware.js","../../seroval/dist/esm/development/index.mjs","../../@tanstack/router-core/dist/esm/ssr/serializer/transformer.js","../../@tanstack/react-router/dist/esm/utils.js","../../@tanstack/react-router/dist/esm/awaited.js","../../@tanstack/react-router/dist/esm/CatchBoundary.js","../../@tanstack/react-router/dist/esm/ClientOnly.js","../../tiny-warning/dist/tiny-warning.esm.js","../../use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js","../../use-sync-external-store/shim/with-selector.js","../../@tanstack/react-store/dist/esm/index.js","../../@tanstack/react-router/dist/esm/routerContext.js","../../@tanstack/react-router/dist/esm/useRouter.js","../../@tanstack/react-router/dist/esm/useRouterState.js","../../@tanstack/react-router/dist/esm/matchContext.js","../../@tanstack/react-router/dist/esm/useMatch.js","../../@tanstack/react-router/dist/esm/useLoaderData.js","../../@tanstack/react-router/dist/esm/useLoaderDeps.js","../../@tanstack/react-router/dist/esm/useParams.js","../../@tanstack/react-router/dist/esm/useSearch.js","../../@tanstack/react-router/dist/esm/useNavigate.js","../../@tanstack/react-router/dist/esm/link.js","../../@tanstack/react-router/dist/esm/route.js","../../@tanstack/react-router/dist/esm/fileRoute.js","../../@tanstack/react-router/dist/esm/lazyRouteComponent.js","../../@tanstack/react-router/dist/esm/Transitioner.js","../../@tanstack/react-router/dist/esm/not-found.js","../../@tanstack/react-router/dist/esm/SafeFragment.js","../../@tanstack/react-router/dist/esm/renderRouteNotFound.js","../../@tanstack/react-router/dist/esm/ScriptOnce.js","../../@tanstack/react-router/dist/esm/scroll-restoration.js","../../@tanstack/react-router/dist/esm/Match.js","../../@tanstack/react-router/dist/esm/Matches.js","../../@tanstack/react-router/dist/esm/router.js","../../@tanstack/react-router/dist/esm/RouterProvider.js","../../@tanstack/react-router/dist/esm/ScrollRestoration.js","../../@tanstack/react-router/dist/esm/useBlocker.js","../../@tanstack/react-router/dist/esm/useRouteContext.js","../../@tanstack/react-router/dist/esm/useLocation.js","../../@tanstack/react-router/dist/esm/useCanGoBack.js","../../@tanstack/react-router/dist/esm/Asset.js","../../@tanstack/react-router/dist/esm/headContentUtils.js","../../@tanstack/react-router/dist/esm/Scripts.js","../../@tanstack/react-router/dist/esm/HeadContent.dev.js"],"sourcesContent":["const __storeToDerived = /* @__PURE__ */ new WeakMap();\nconst __derivedToStore = /* @__PURE__ */ new WeakMap();\nconst __depsThatHaveWrittenThisTick = {\n  current: []\n};\nlet __isFlushing = false;\nlet __batchDepth = 0;\nconst __pendingUpdates = /* @__PURE__ */ new Set();\nconst __initialBatchValues = /* @__PURE__ */ new Map();\nfunction __flush_internals(relatedVals) {\n  for (const derived of relatedVals) {\n    if (__depsThatHaveWrittenThisTick.current.includes(derived)) {\n      continue;\n    }\n    __depsThatHaveWrittenThisTick.current.push(derived);\n    derived.recompute();\n    const stores = __derivedToStore.get(derived);\n    if (stores) {\n      for (const store of stores) {\n        const relatedLinkedDerivedVals = __storeToDerived.get(store);\n        if (!(relatedLinkedDerivedVals == null ? void 0 : relatedLinkedDerivedVals.length)) continue;\n        __flush_internals(relatedLinkedDerivedVals);\n      }\n    }\n  }\n}\nfunction __notifyListeners(store) {\n  const value = {\n    prevVal: store.prevState,\n    currentVal: store.state\n  };\n  for (const listener of store.listeners) {\n    listener(value);\n  }\n}\nfunction __notifyDerivedListeners(derived) {\n  const value = {\n    prevVal: derived.prevState,\n    currentVal: derived.state\n  };\n  for (const listener of derived.listeners) {\n    listener(value);\n  }\n}\nfunction __flush(store) {\n  if (__batchDepth > 0 && !__initialBatchValues.has(store)) {\n    __initialBatchValues.set(store, store.prevState);\n  }\n  __pendingUpdates.add(store);\n  if (__batchDepth > 0) return;\n  if (__isFlushing) return;\n  try {\n    __isFlushing = true;\n    while (__pendingUpdates.size > 0) {\n      const stores = Array.from(__pendingUpdates);\n      __pendingUpdates.clear();\n      for (const store2 of stores) {\n        const prevState = __initialBatchValues.get(store2) ?? store2.prevState;\n        store2.prevState = prevState;\n        __notifyListeners(store2);\n      }\n      for (const store2 of stores) {\n        const derivedVals = __storeToDerived.get(store2);\n        if (!derivedVals) continue;\n        __depsThatHaveWrittenThisTick.current.push(store2);\n        __flush_internals(derivedVals);\n      }\n      for (const store2 of stores) {\n        const derivedVals = __storeToDerived.get(store2);\n        if (!derivedVals) continue;\n        for (const derived of derivedVals) {\n          __notifyDerivedListeners(derived);\n        }\n      }\n    }\n  } finally {\n    __isFlushing = false;\n    __depsThatHaveWrittenThisTick.current = [];\n    __initialBatchValues.clear();\n  }\n}\nfunction batch(fn) {\n  __batchDepth++;\n  try {\n    fn();\n  } finally {\n    __batchDepth--;\n    if (__batchDepth === 0) {\n      const pendingUpdateToFlush = __pendingUpdates.values().next().value;\n      if (pendingUpdateToFlush) {\n        __flush(pendingUpdateToFlush);\n      }\n    }\n  }\n}\nexport {\n  __depsThatHaveWrittenThisTick,\n  __derivedToStore,\n  __flush,\n  __storeToDerived,\n  batch\n};\n//# sourceMappingURL=scheduler.js.map\n","function isUpdaterFunction(updater) {\n  return typeof updater === \"function\";\n}\nexport {\n  isUpdaterFunction\n};\n//# sourceMappingURL=types.js.map\n","import { __flush } from \"./scheduler.js\";\nimport { isUpdaterFunction } from \"./types.js\";\nclass Store {\n  constructor(initialState, options) {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = (listener) => {\n      var _a, _b;\n      this.listeners.add(listener);\n      const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);\n      return () => {\n        this.listeners.delete(listener);\n        unsub == null ? void 0 : unsub();\n      };\n    };\n    this.prevState = initialState;\n    this.state = initialState;\n    this.options = options;\n  }\n  setState(updater) {\n    var _a, _b, _c;\n    this.prevState = this.state;\n    if ((_a = this.options) == null ? void 0 : _a.updateFn) {\n      this.state = this.options.updateFn(this.prevState)(updater);\n    } else {\n      if (isUpdaterFunction(updater)) {\n        this.state = updater(this.prevState);\n      } else {\n        this.state = updater;\n      }\n    }\n    (_c = (_b = this.options) == null ? void 0 : _b.onUpdate) == null ? void 0 : _c.call(_b);\n    __flush(this);\n  }\n}\nexport {\n  Store\n};\n//# sourceMappingURL=store.js.map\n","const stateIndexKey = \"__TSR_index\";\nconst popStateEvent = \"popstate\";\nconst beforeUnloadEvent = \"beforeunload\";\nfunction createHistory(opts) {\n  let location = opts.getLocation();\n  const subscribers = /* @__PURE__ */ new Set();\n  const notify = (action, navigateOpts) => {\n    location = opts.getLocation();\n    subscribers.forEach(\n      (subscriber) => subscriber({ location, action, navigateOpts })\n    );\n  };\n  const handleIndexChange = (action) => {\n    if (opts.notifyOnIndexChange ?? true) notify(action);\n    else location = opts.getLocation();\n  };\n  const tryNavigation = async ({\n    task,\n    navigateOpts,\n    ...actionInfo\n  }) => {\n    const ignoreBlocker = navigateOpts?.ignoreBlocker ?? false;\n    if (ignoreBlocker) {\n      task();\n      return { type: \"SUCCESS\" };\n    }\n    const blockers = opts.getBlockers?.() ?? [];\n    const isPushOrReplace = actionInfo.type === \"PUSH\" || actionInfo.type === \"REPLACE\";\n    if (typeof document !== \"undefined\" && blockers.length && isPushOrReplace) {\n      for (const blocker of blockers) {\n        const nextLocation = parseHref(actionInfo.path, actionInfo.state);\n        const isBlocked = await blocker.blockerFn({\n          currentLocation: location,\n          nextLocation,\n          action: actionInfo.type\n        });\n        if (isBlocked) {\n          opts.onBlocked?.();\n          return { type: \"BLOCKED\" };\n        }\n      }\n    }\n    task();\n    return { type: \"SUCCESS\" };\n  };\n  return {\n    get location() {\n      return location;\n    },\n    get length() {\n      return opts.getLength();\n    },\n    subscribers,\n    subscribe: (cb) => {\n      subscribers.add(cb);\n      return () => {\n        subscribers.delete(cb);\n      };\n    },\n    push: (path, state, navigateOpts) => {\n      const currentIndex = location.state[stateIndexKey];\n      state = assignKeyAndIndex(currentIndex + 1, state);\n      return tryNavigation({\n        task: () => {\n          opts.pushState(path, state);\n          notify({ type: \"PUSH\" }, navigateOpts);\n        },\n        navigateOpts,\n        type: \"PUSH\",\n        path,\n        state\n      });\n    },\n    replace: (path, state, navigateOpts) => {\n      const currentIndex = location.state[stateIndexKey];\n      state = assignKeyAndIndex(currentIndex, state);\n      return tryNavigation({\n        task: () => {\n          opts.replaceState(path, state);\n          notify({ type: \"REPLACE\" }, navigateOpts);\n        },\n        navigateOpts,\n        type: \"REPLACE\",\n        path,\n        state\n      });\n    },\n    go: (index, navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.go(index);\n          handleIndexChange({ type: \"GO\", index });\n        },\n        navigateOpts,\n        type: \"GO\"\n      });\n    },\n    back: (navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.back(navigateOpts?.ignoreBlocker ?? false);\n          handleIndexChange({ type: \"BACK\" });\n        },\n        navigateOpts,\n        type: \"BACK\"\n      });\n    },\n    forward: (navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.forward(navigateOpts?.ignoreBlocker ?? false);\n          handleIndexChange({ type: \"FORWARD\" });\n        },\n        navigateOpts,\n        type: \"FORWARD\"\n      });\n    },\n    canGoBack: () => location.state[stateIndexKey] !== 0,\n    createHref: (str) => opts.createHref(str),\n    block: (blocker) => {\n      if (!opts.setBlockers) return () => {\n      };\n      const blockers = opts.getBlockers?.() ?? [];\n      opts.setBlockers([...blockers, blocker]);\n      return () => {\n        const blockers2 = opts.getBlockers?.() ?? [];\n        opts.setBlockers?.(blockers2.filter((b) => b !== blocker));\n      };\n    },\n    flush: () => opts.flush?.(),\n    destroy: () => opts.destroy?.(),\n    notify\n  };\n}\nfunction assignKeyAndIndex(index, state) {\n  if (!state) {\n    state = {};\n  }\n  const key = createRandomKey();\n  return {\n    ...state,\n    key,\n    // TODO: Remove in v2 - use __TSR_key instead\n    __TSR_key: key,\n    [stateIndexKey]: index\n  };\n}\nfunction createBrowserHistory(opts) {\n  const win = opts?.window ?? (typeof document !== \"undefined\" ? window : void 0);\n  const originalPushState = win.history.pushState;\n  const originalReplaceState = win.history.replaceState;\n  let blockers = [];\n  const _getBlockers = () => blockers;\n  const _setBlockers = (newBlockers) => blockers = newBlockers;\n  const createHref = opts?.createHref ?? ((path) => path);\n  const parseLocation = opts?.parseLocation ?? (() => parseHref(\n    `${win.location.pathname}${win.location.search}${win.location.hash}`,\n    win.history.state\n  ));\n  if (!win.history.state?.__TSR_key && !win.history.state?.key) {\n    const addedKey = createRandomKey();\n    win.history.replaceState(\n      {\n        [stateIndexKey]: 0,\n        key: addedKey,\n        // TODO: Remove in v2 - use __TSR_key instead\n        __TSR_key: addedKey\n      },\n      \"\"\n    );\n  }\n  let currentLocation = parseLocation();\n  let rollbackLocation;\n  let nextPopIsGo = false;\n  let ignoreNextPop = false;\n  let skipBlockerNextPop = false;\n  let ignoreNextBeforeUnload = false;\n  const getLocation = () => currentLocation;\n  let next;\n  let scheduled;\n  const flush = () => {\n    if (!next) {\n      return;\n    }\n    history._ignoreSubscribers = true;\n    (next.isPush ? win.history.pushState : win.history.replaceState)(\n      next.state,\n      \"\",\n      next.href\n    );\n    history._ignoreSubscribers = false;\n    next = void 0;\n    scheduled = void 0;\n    rollbackLocation = void 0;\n  };\n  const queueHistoryAction = (type, destHref, state) => {\n    const href = createHref(destHref);\n    if (!scheduled) {\n      rollbackLocation = currentLocation;\n    }\n    currentLocation = parseHref(destHref, state);\n    next = {\n      href,\n      state,\n      isPush: next?.isPush || type === \"push\"\n    };\n    if (!scheduled) {\n      scheduled = Promise.resolve().then(() => flush());\n    }\n  };\n  const onPushPop = (type) => {\n    currentLocation = parseLocation();\n    history.notify({ type });\n  };\n  const onPushPopEvent = async () => {\n    if (ignoreNextPop) {\n      ignoreNextPop = false;\n      return;\n    }\n    const nextLocation = parseLocation();\n    const delta = nextLocation.state[stateIndexKey] - currentLocation.state[stateIndexKey];\n    const isForward = delta === 1;\n    const isBack = delta === -1;\n    const isGo = !isForward && !isBack || nextPopIsGo;\n    nextPopIsGo = false;\n    const action = isGo ? \"GO\" : isBack ? \"BACK\" : \"FORWARD\";\n    const notify = isGo ? {\n      type: \"GO\",\n      index: delta\n    } : {\n      type: isBack ? \"BACK\" : \"FORWARD\"\n    };\n    if (skipBlockerNextPop) {\n      skipBlockerNextPop = false;\n    } else {\n      const blockers2 = _getBlockers();\n      if (typeof document !== \"undefined\" && blockers2.length) {\n        for (const blocker of blockers2) {\n          const isBlocked = await blocker.blockerFn({\n            currentLocation,\n            nextLocation,\n            action\n          });\n          if (isBlocked) {\n            ignoreNextPop = true;\n            win.history.go(1);\n            history.notify(notify);\n            return;\n          }\n        }\n      }\n    }\n    currentLocation = parseLocation();\n    history.notify(notify);\n  };\n  const onBeforeUnload = (e) => {\n    if (ignoreNextBeforeUnload) {\n      ignoreNextBeforeUnload = false;\n      return;\n    }\n    let shouldBlock = false;\n    const blockers2 = _getBlockers();\n    if (typeof document !== \"undefined\" && blockers2.length) {\n      for (const blocker of blockers2) {\n        const shouldHaveBeforeUnload = blocker.enableBeforeUnload ?? true;\n        if (shouldHaveBeforeUnload === true) {\n          shouldBlock = true;\n          break;\n        }\n        if (typeof shouldHaveBeforeUnload === \"function\" && shouldHaveBeforeUnload() === true) {\n          shouldBlock = true;\n          break;\n        }\n      }\n    }\n    if (shouldBlock) {\n      e.preventDefault();\n      return e.returnValue = \"\";\n    }\n    return;\n  };\n  const history = createHistory({\n    getLocation,\n    getLength: () => win.history.length,\n    pushState: (href, state) => queueHistoryAction(\"push\", href, state),\n    replaceState: (href, state) => queueHistoryAction(\"replace\", href, state),\n    back: (ignoreBlocker) => {\n      if (ignoreBlocker) skipBlockerNextPop = true;\n      ignoreNextBeforeUnload = true;\n      return win.history.back();\n    },\n    forward: (ignoreBlocker) => {\n      if (ignoreBlocker) skipBlockerNextPop = true;\n      ignoreNextBeforeUnload = true;\n      win.history.forward();\n    },\n    go: (n) => {\n      nextPopIsGo = true;\n      win.history.go(n);\n    },\n    createHref: (href) => createHref(href),\n    flush,\n    destroy: () => {\n      win.history.pushState = originalPushState;\n      win.history.replaceState = originalReplaceState;\n      win.removeEventListener(beforeUnloadEvent, onBeforeUnload, {\n        capture: true\n      });\n      win.removeEventListener(popStateEvent, onPushPopEvent);\n    },\n    onBlocked: () => {\n      if (rollbackLocation && currentLocation !== rollbackLocation) {\n        currentLocation = rollbackLocation;\n      }\n    },\n    getBlockers: _getBlockers,\n    setBlockers: _setBlockers,\n    notifyOnIndexChange: false\n  });\n  win.addEventListener(beforeUnloadEvent, onBeforeUnload, { capture: true });\n  win.addEventListener(popStateEvent, onPushPopEvent);\n  win.history.pushState = function(...args) {\n    const res = originalPushState.apply(win.history, args);\n    if (!history._ignoreSubscribers) onPushPop(\"PUSH\");\n    return res;\n  };\n  win.history.replaceState = function(...args) {\n    const res = originalReplaceState.apply(win.history, args);\n    if (!history._ignoreSubscribers) onPushPop(\"REPLACE\");\n    return res;\n  };\n  return history;\n}\nfunction createHashHistory(opts) {\n  const win = opts?.window ?? (typeof document !== \"undefined\" ? window : void 0);\n  return createBrowserHistory({\n    window: win,\n    parseLocation: () => {\n      const hashSplit = win.location.hash.split(\"#\").slice(1);\n      const pathPart = hashSplit[0] ?? \"/\";\n      const searchPart = win.location.search;\n      const hashEntries = hashSplit.slice(1);\n      const hashPart = hashEntries.length === 0 ? \"\" : `#${hashEntries.join(\"#\")}`;\n      const hashHref = `${pathPart}${searchPart}${hashPart}`;\n      return parseHref(hashHref, win.history.state);\n    },\n    createHref: (href) => `${win.location.pathname}${win.location.search}#${href}`\n  });\n}\nfunction createMemoryHistory(opts = {\n  initialEntries: [\"/\"]\n}) {\n  const entries = opts.initialEntries;\n  let index = opts.initialIndex ? Math.min(Math.max(opts.initialIndex, 0), entries.length - 1) : entries.length - 1;\n  const states = entries.map(\n    (_entry, index2) => assignKeyAndIndex(index2, void 0)\n  );\n  const getLocation = () => parseHref(entries[index], states[index]);\n  let blockers = [];\n  const _getBlockers = () => blockers;\n  const _setBlockers = (newBlockers) => blockers = newBlockers;\n  return createHistory({\n    getLocation,\n    getLength: () => entries.length,\n    pushState: (path, state) => {\n      if (index < entries.length - 1) {\n        entries.splice(index + 1);\n        states.splice(index + 1);\n      }\n      states.push(state);\n      entries.push(path);\n      index = Math.max(entries.length - 1, 0);\n    },\n    replaceState: (path, state) => {\n      states[index] = state;\n      entries[index] = path;\n    },\n    back: () => {\n      index = Math.max(index - 1, 0);\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1);\n    },\n    go: (n) => {\n      index = Math.min(Math.max(index + n, 0), entries.length - 1);\n    },\n    createHref: (path) => path,\n    getBlockers: _getBlockers,\n    setBlockers: _setBlockers\n  });\n}\nfunction sanitizePath(path) {\n  let sanitized = path.replace(/[\\x00-\\x1f\\x7f]/g, \"\");\n  if (sanitized.startsWith(\"//\")) {\n    sanitized = \"/\" + sanitized.replace(/^\\/+/, \"\");\n  }\n  return sanitized;\n}\nfunction parseHref(href, state) {\n  const sanitizedHref = sanitizePath(href);\n  const hashIndex = sanitizedHref.indexOf(\"#\");\n  const searchIndex = sanitizedHref.indexOf(\"?\");\n  const addedKey = createRandomKey();\n  return {\n    href: sanitizedHref,\n    pathname: sanitizedHref.substring(\n      0,\n      hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : sanitizedHref.length\n    ),\n    hash: hashIndex > -1 ? sanitizedHref.substring(hashIndex) : \"\",\n    search: searchIndex > -1 ? sanitizedHref.slice(\n      searchIndex,\n      hashIndex === -1 ? void 0 : hashIndex\n    ) : \"\",\n    state: state || { [stateIndexKey]: 0, key: addedKey, __TSR_key: addedKey }\n  };\n}\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7);\n}\nexport {\n  createBrowserHistory,\n  createHashHistory,\n  createHistory,\n  createMemoryHistory,\n  parseHref\n};\n//# sourceMappingURL=index.js.map\n","function last(arr) {\n  return arr[arr.length - 1];\n}\nfunction isFunction(d) {\n  return typeof d === \"function\";\n}\nfunction functionalUpdate(updater, previous) {\n  if (isFunction(updater)) {\n    return updater(previous);\n  }\n  return updater;\n}\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst isEnumerable = Object.prototype.propertyIsEnumerable;\nfunction replaceEqualDeep(prev, _next, _depth = 0) {\n  if (prev === _next) {\n    return prev;\n  }\n  if (_depth > 500) return _next;\n  const next = _next;\n  const array = isPlainArray(prev) && isPlainArray(next);\n  if (!array && !(isPlainObject(prev) && isPlainObject(next))) return next;\n  const prevItems = array ? prev : getEnumerableOwnKeys(prev);\n  if (!prevItems) return next;\n  const nextItems = array ? next : getEnumerableOwnKeys(next);\n  if (!nextItems) return next;\n  const prevSize = prevItems.length;\n  const nextSize = nextItems.length;\n  const copy = array ? new Array(nextSize) : {};\n  let equalItems = 0;\n  for (let i = 0; i < nextSize; i++) {\n    const key = array ? i : nextItems[i];\n    const p = prev[key];\n    const n = next[key];\n    if (p === n) {\n      copy[key] = p;\n      if (array ? i < prevSize : hasOwn.call(prev, key)) equalItems++;\n      continue;\n    }\n    if (p === null || n === null || typeof p !== \"object\" || typeof n !== \"object\") {\n      copy[key] = n;\n      continue;\n    }\n    const v = replaceEqualDeep(p, n, _depth + 1);\n    copy[key] = v;\n    if (v === p) equalItems++;\n  }\n  return prevSize === nextSize && equalItems === prevSize ? prev : copy;\n}\nfunction getEnumerableOwnKeys(o) {\n  const names = Object.getOwnPropertyNames(o);\n  for (const name of names) {\n    if (!isEnumerable.call(o, name)) return false;\n  }\n  const symbols = Object.getOwnPropertySymbols(o);\n  if (symbols.length === 0) return names;\n  const keys = names;\n  for (const symbol of symbols) {\n    if (!isEnumerable.call(o, symbol)) return false;\n    keys.push(symbol);\n  }\n  return keys;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (typeof ctor === \"undefined\") {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction deepEqual(a, b, opts) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    for (let i = 0, l = a.length; i < l; i++) {\n      if (!deepEqual(a[i], b[i], opts)) return false;\n    }\n    return true;\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const ignoreUndefined = opts?.ignoreUndefined ?? true;\n    if (opts?.partial) {\n      for (const k in b) {\n        if (!ignoreUndefined || b[k] !== void 0) {\n          if (!deepEqual(a[k], b[k], opts)) return false;\n        }\n      }\n      return true;\n    }\n    let aCount = 0;\n    if (!ignoreUndefined) {\n      aCount = Object.keys(a).length;\n    } else {\n      for (const k in a) {\n        if (a[k] !== void 0) aCount++;\n      }\n    }\n    let bCount = 0;\n    for (const k in b) {\n      if (!ignoreUndefined || b[k] !== void 0) {\n        bCount++;\n        if (bCount > aCount || !deepEqual(a[k], b[k], opts)) return false;\n      }\n    }\n    return aCount === bCount;\n  }\n  return false;\n}\nfunction createControlledPromise(onResolve) {\n  let resolveLoadPromise;\n  let rejectLoadPromise;\n  const controlledPromise = new Promise((resolve, reject) => {\n    resolveLoadPromise = resolve;\n    rejectLoadPromise = reject;\n  });\n  controlledPromise.status = \"pending\";\n  controlledPromise.resolve = (value) => {\n    controlledPromise.status = \"resolved\";\n    controlledPromise.value = value;\n    resolveLoadPromise(value);\n    onResolve?.(value);\n  };\n  controlledPromise.reject = (e) => {\n    controlledPromise.status = \"rejected\";\n    rejectLoadPromise(e);\n  };\n  return controlledPromise;\n}\nfunction isModuleNotFoundError(error) {\n  if (typeof error?.message !== \"string\") return false;\n  return error.message.startsWith(\"Failed to fetch dynamically imported module\") || error.message.startsWith(\"error loading dynamically imported module\") || error.message.startsWith(\"Importing a module script failed\");\n}\nfunction isPromise(value) {\n  return Boolean(\n    value && typeof value === \"object\" && typeof value.then === \"function\"\n  );\n}\nfunction findLast(array, predicate) {\n  for (let i = array.length - 1; i >= 0; i--) {\n    const item = array[i];\n    if (predicate(item)) return item;\n  }\n  return void 0;\n}\nfunction sanitizePathSegment(segment) {\n  return segment.replace(/[\\x00-\\x1f\\x7f]/g, \"\");\n}\nfunction decodeSegment(segment) {\n  let decoded;\n  try {\n    decoded = decodeURI(segment);\n  } catch {\n    decoded = segment.replaceAll(/%[0-9A-F]{2}/gi, (match) => {\n      try {\n        return decodeURI(match);\n      } catch {\n        return match;\n      }\n    });\n  }\n  return sanitizePathSegment(decoded);\n}\nconst SAFE_URL_PROTOCOLS = [\"http:\", \"https:\", \"mailto:\", \"tel:\"];\nfunction isDangerousProtocol(url) {\n  if (!url) return false;\n  try {\n    const parsed = new URL(url);\n    return !SAFE_URL_PROTOCOLS.includes(parsed.protocol);\n  } catch {\n    return false;\n  }\n}\nconst HTML_ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nconst HTML_ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(str) {\n  return str.replace(HTML_ESCAPE_REGEX, (match) => HTML_ESCAPE_LOOKUP[match]);\n}\nfunction decodePath(path, decodeIgnore) {\n  if (!path) return path;\n  const re = decodeIgnore ? new RegExp(`${decodeIgnore.join(\"|\")}`, \"gi\") : /%25|%5C/gi;\n  let cursor = 0;\n  let result = \"\";\n  let match;\n  while (null !== (match = re.exec(path))) {\n    result += decodeSegment(path.slice(cursor, match.index)) + match[0];\n    cursor = re.lastIndex;\n  }\n  result = result + decodeSegment(cursor ? path.slice(cursor) : path);\n  if (result.startsWith(\"//\")) {\n    result = \"/\" + result.replace(/^\\/+/, \"\");\n  }\n  return result;\n}\nfunction buildDevStylesUrl(basepath, routeIds) {\n  const trimmedBasepath = basepath.replace(/^\\/+|\\/+$/g, \"\");\n  const normalizedBasepath = trimmedBasepath === \"\" ? \"\" : `/${trimmedBasepath}`;\n  return `${normalizedBasepath}/@tanstack-start/styles.css?routes=${encodeURIComponent(routeIds.join(\",\"))}`;\n}\nexport {\n  SAFE_URL_PROTOCOLS,\n  buildDevStylesUrl,\n  createControlledPromise,\n  decodePath,\n  deepEqual,\n  escapeHtml,\n  findLast,\n  functionalUpdate,\n  isDangerousProtocol,\n  isModuleNotFoundError,\n  isPlainArray,\n  isPlainObject,\n  isPromise,\n  last,\n  replaceEqualDeep\n};\n//# sourceMappingURL=utils.js.map\n","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n","function createLRUCache(max) {\n  const cache = /* @__PURE__ */ new Map();\n  let oldest;\n  let newest;\n  const touch = (entry) => {\n    if (!entry.next) return;\n    if (!entry.prev) {\n      entry.next.prev = void 0;\n      oldest = entry.next;\n      entry.next = void 0;\n      if (newest) {\n        entry.prev = newest;\n        newest.next = entry;\n      }\n    } else {\n      entry.prev.next = entry.next;\n      entry.next.prev = entry.prev;\n      entry.next = void 0;\n      if (newest) {\n        newest.next = entry;\n        entry.prev = newest;\n      }\n    }\n    newest = entry;\n  };\n  return {\n    get(key) {\n      const entry = cache.get(key);\n      if (!entry) return void 0;\n      touch(entry);\n      return entry.value;\n    },\n    set(key, value) {\n      if (cache.size >= max && oldest) {\n        const toDelete = oldest;\n        cache.delete(toDelete.key);\n        if (toDelete.next) {\n          oldest = toDelete.next;\n          toDelete.next.prev = void 0;\n        }\n        if (toDelete === newest) {\n          newest = void 0;\n        }\n      }\n      const existing = cache.get(key);\n      if (existing) {\n        existing.value = value;\n        touch(existing);\n      } else {\n        const entry = { key, value, prev: newest };\n        if (newest) newest.next = entry;\n        newest = entry;\n        if (!oldest) oldest = entry;\n        cache.set(key, entry);\n      }\n    },\n    clear() {\n      cache.clear();\n      oldest = void 0;\n      newest = void 0;\n    }\n  };\n}\nexport {\n  createLRUCache\n};\n//# sourceMappingURL=lru-cache.js.map\n","import invariant from \"tiny-invariant\";\nimport { createLRUCache } from \"./lru-cache.js\";\nimport { last } from \"./utils.js\";\nconst SEGMENT_TYPE_PATHNAME = 0;\nconst SEGMENT_TYPE_PARAM = 1;\nconst SEGMENT_TYPE_WILDCARD = 2;\nconst SEGMENT_TYPE_OPTIONAL_PARAM = 3;\nconst SEGMENT_TYPE_INDEX = 4;\nconst SEGMENT_TYPE_PATHLESS = 5;\nconst PARAM_W_CURLY_BRACES_RE = /^([^{]*)\\{\\$([a-zA-Z_$][a-zA-Z0-9_$]*)\\}([^}]*)$/;\nconst OPTIONAL_PARAM_W_CURLY_BRACES_RE = /^([^{]*)\\{-\\$([a-zA-Z_$][a-zA-Z0-9_$]*)\\}([^}]*)$/;\nconst WILDCARD_W_CURLY_BRACES_RE = /^([^{]*)\\{\\$\\}([^}]*)$/;\nfunction parseSegment(path, start, output = new Uint16Array(6)) {\n  const next = path.indexOf(\"/\", start);\n  const end = next === -1 ? path.length : next;\n  const part = path.substring(start, end);\n  if (!part || !part.includes(\"$\")) {\n    output[0] = SEGMENT_TYPE_PATHNAME;\n    output[1] = start;\n    output[2] = start;\n    output[3] = end;\n    output[4] = end;\n    output[5] = end;\n    return output;\n  }\n  if (part === \"$\") {\n    const total = path.length;\n    output[0] = SEGMENT_TYPE_WILDCARD;\n    output[1] = start;\n    output[2] = start;\n    output[3] = total;\n    output[4] = total;\n    output[5] = total;\n    return output;\n  }\n  if (part.charCodeAt(0) === 36) {\n    output[0] = SEGMENT_TYPE_PARAM;\n    output[1] = start;\n    output[2] = start + 1;\n    output[3] = end;\n    output[4] = end;\n    output[5] = end;\n    return output;\n  }\n  const wildcardBracesMatch = part.match(WILDCARD_W_CURLY_BRACES_RE);\n  if (wildcardBracesMatch) {\n    const prefix = wildcardBracesMatch[1];\n    const pLength = prefix.length;\n    output[0] = SEGMENT_TYPE_WILDCARD;\n    output[1] = start + pLength;\n    output[2] = start + pLength + 1;\n    output[3] = start + pLength + 2;\n    output[4] = start + pLength + 3;\n    output[5] = path.length;\n    return output;\n  }\n  const optionalParamBracesMatch = part.match(OPTIONAL_PARAM_W_CURLY_BRACES_RE);\n  if (optionalParamBracesMatch) {\n    const prefix = optionalParamBracesMatch[1];\n    const paramName = optionalParamBracesMatch[2];\n    const suffix = optionalParamBracesMatch[3];\n    const pLength = prefix.length;\n    output[0] = SEGMENT_TYPE_OPTIONAL_PARAM;\n    output[1] = start + pLength;\n    output[2] = start + pLength + 3;\n    output[3] = start + pLength + 3 + paramName.length;\n    output[4] = end - suffix.length;\n    output[5] = end;\n    return output;\n  }\n  const paramBracesMatch = part.match(PARAM_W_CURLY_BRACES_RE);\n  if (paramBracesMatch) {\n    const prefix = paramBracesMatch[1];\n    const paramName = paramBracesMatch[2];\n    const suffix = paramBracesMatch[3];\n    const pLength = prefix.length;\n    output[0] = SEGMENT_TYPE_PARAM;\n    output[1] = start + pLength;\n    output[2] = start + pLength + 2;\n    output[3] = start + pLength + 2 + paramName.length;\n    output[4] = end - suffix.length;\n    output[5] = end;\n    return output;\n  }\n  output[0] = SEGMENT_TYPE_PATHNAME;\n  output[1] = start;\n  output[2] = start;\n  output[3] = end;\n  output[4] = end;\n  output[5] = end;\n  return output;\n}\nfunction parseSegments(defaultCaseSensitive, data, route, start, node, depth, onRoute) {\n  onRoute?.(route);\n  let cursor = start;\n  {\n    const path = route.fullPath ?? route.from;\n    const length = path.length;\n    const caseSensitive = route.options?.caseSensitive ?? defaultCaseSensitive;\n    const skipOnParamError = !!(route.options?.params?.parse && route.options?.skipRouteOnParseError?.params);\n    while (cursor < length) {\n      const segment = parseSegment(path, cursor, data);\n      let nextNode;\n      const start2 = cursor;\n      const end = segment[5];\n      cursor = end + 1;\n      depth++;\n      const kind = segment[0];\n      switch (kind) {\n        case SEGMENT_TYPE_PATHNAME: {\n          const value = path.substring(segment[2], segment[3]);\n          if (caseSensitive) {\n            const existingNode = node.static?.get(value);\n            if (existingNode) {\n              nextNode = existingNode;\n            } else {\n              node.static ??= /* @__PURE__ */ new Map();\n              const next = createStaticNode(\n                route.fullPath ?? route.from\n              );\n              next.parent = node;\n              next.depth = depth;\n              nextNode = next;\n              node.static.set(value, next);\n            }\n          } else {\n            const name = value.toLowerCase();\n            const existingNode = node.staticInsensitive?.get(name);\n            if (existingNode) {\n              nextNode = existingNode;\n            } else {\n              node.staticInsensitive ??= /* @__PURE__ */ new Map();\n              const next = createStaticNode(\n                route.fullPath ?? route.from\n              );\n              next.parent = node;\n              next.depth = depth;\n              nextNode = next;\n              node.staticInsensitive.set(name, next);\n            }\n          }\n          break;\n        }\n        case SEGMENT_TYPE_PARAM: {\n          const prefix_raw = path.substring(start2, segment[1]);\n          const suffix_raw = path.substring(segment[4], end);\n          const actuallyCaseSensitive = caseSensitive && !!(prefix_raw || suffix_raw);\n          const prefix = !prefix_raw ? void 0 : actuallyCaseSensitive ? prefix_raw : prefix_raw.toLowerCase();\n          const suffix = !suffix_raw ? void 0 : actuallyCaseSensitive ? suffix_raw : suffix_raw.toLowerCase();\n          const existingNode = !skipOnParamError && node.dynamic?.find(\n            (s) => !s.skipOnParamError && s.caseSensitive === actuallyCaseSensitive && s.prefix === prefix && s.suffix === suffix\n          );\n          if (existingNode) {\n            nextNode = existingNode;\n          } else {\n            const next = createDynamicNode(\n              SEGMENT_TYPE_PARAM,\n              route.fullPath ?? route.from,\n              actuallyCaseSensitive,\n              prefix,\n              suffix\n            );\n            nextNode = next;\n            next.depth = depth;\n            next.parent = node;\n            node.dynamic ??= [];\n            node.dynamic.push(next);\n          }\n          break;\n        }\n        case SEGMENT_TYPE_OPTIONAL_PARAM: {\n          const prefix_raw = path.substring(start2, segment[1]);\n          const suffix_raw = path.substring(segment[4], end);\n          const actuallyCaseSensitive = caseSensitive && !!(prefix_raw || suffix_raw);\n          const prefix = !prefix_raw ? void 0 : actuallyCaseSensitive ? prefix_raw : prefix_raw.toLowerCase();\n          const suffix = !suffix_raw ? void 0 : actuallyCaseSensitive ? suffix_raw : suffix_raw.toLowerCase();\n          const existingNode = !skipOnParamError && node.optional?.find(\n            (s) => !s.skipOnParamError && s.caseSensitive === actuallyCaseSensitive && s.prefix === prefix && s.suffix === suffix\n          );\n          if (existingNode) {\n            nextNode = existingNode;\n          } else {\n            const next = createDynamicNode(\n              SEGMENT_TYPE_OPTIONAL_PARAM,\n              route.fullPath ?? route.from,\n              actuallyCaseSensitive,\n              prefix,\n              suffix\n            );\n            nextNode = next;\n            next.parent = node;\n            next.depth = depth;\n            node.optional ??= [];\n            node.optional.push(next);\n          }\n          break;\n        }\n        case SEGMENT_TYPE_WILDCARD: {\n          const prefix_raw = path.substring(start2, segment[1]);\n          const suffix_raw = path.substring(segment[4], end);\n          const actuallyCaseSensitive = caseSensitive && !!(prefix_raw || suffix_raw);\n          const prefix = !prefix_raw ? void 0 : actuallyCaseSensitive ? prefix_raw : prefix_raw.toLowerCase();\n          const suffix = !suffix_raw ? void 0 : actuallyCaseSensitive ? suffix_raw : suffix_raw.toLowerCase();\n          const next = createDynamicNode(\n            SEGMENT_TYPE_WILDCARD,\n            route.fullPath ?? route.from,\n            actuallyCaseSensitive,\n            prefix,\n            suffix\n          );\n          nextNode = next;\n          next.parent = node;\n          next.depth = depth;\n          node.wildcard ??= [];\n          node.wildcard.push(next);\n        }\n      }\n      node = nextNode;\n    }\n    if (skipOnParamError && route.children && !route.isRoot && route.id && route.id.charCodeAt(route.id.lastIndexOf(\"/\") + 1) === 95) {\n      const pathlessNode = createStaticNode(\n        route.fullPath ?? route.from\n      );\n      pathlessNode.kind = SEGMENT_TYPE_PATHLESS;\n      pathlessNode.parent = node;\n      depth++;\n      pathlessNode.depth = depth;\n      node.pathless ??= [];\n      node.pathless.push(pathlessNode);\n      node = pathlessNode;\n    }\n    const isLeaf = (route.path || !route.children) && !route.isRoot;\n    if (isLeaf && path.endsWith(\"/\")) {\n      const indexNode = createStaticNode(\n        route.fullPath ?? route.from\n      );\n      indexNode.kind = SEGMENT_TYPE_INDEX;\n      indexNode.parent = node;\n      depth++;\n      indexNode.depth = depth;\n      node.index = indexNode;\n      node = indexNode;\n    }\n    node.parse = route.options?.params?.parse ?? null;\n    node.skipOnParamError = skipOnParamError;\n    node.parsingPriority = route.options?.skipRouteOnParseError?.priority ?? 0;\n    if (isLeaf && !node.route) {\n      node.route = route;\n      node.fullPath = route.fullPath ?? route.from;\n    }\n  }\n  if (route.children)\n    for (const child of route.children) {\n      parseSegments(\n        defaultCaseSensitive,\n        data,\n        child,\n        cursor,\n        node,\n        depth,\n        onRoute\n      );\n    }\n}\nfunction sortDynamic(a, b) {\n  if (a.skipOnParamError && !b.skipOnParamError) return -1;\n  if (!a.skipOnParamError && b.skipOnParamError) return 1;\n  if (a.skipOnParamError && b.skipOnParamError && (a.parsingPriority || b.parsingPriority))\n    return b.parsingPriority - a.parsingPriority;\n  if (a.prefix && b.prefix && a.prefix !== b.prefix) {\n    if (a.prefix.startsWith(b.prefix)) return -1;\n    if (b.prefix.startsWith(a.prefix)) return 1;\n  }\n  if (a.suffix && b.suffix && a.suffix !== b.suffix) {\n    if (a.suffix.endsWith(b.suffix)) return -1;\n    if (b.suffix.endsWith(a.suffix)) return 1;\n  }\n  if (a.prefix && !b.prefix) return -1;\n  if (!a.prefix && b.prefix) return 1;\n  if (a.suffix && !b.suffix) return -1;\n  if (!a.suffix && b.suffix) return 1;\n  if (a.caseSensitive && !b.caseSensitive) return -1;\n  if (!a.caseSensitive && b.caseSensitive) return 1;\n  return 0;\n}\nfunction sortTreeNodes(node) {\n  if (node.pathless) {\n    for (const child of node.pathless) {\n      sortTreeNodes(child);\n    }\n  }\n  if (node.static) {\n    for (const child of node.static.values()) {\n      sortTreeNodes(child);\n    }\n  }\n  if (node.staticInsensitive) {\n    for (const child of node.staticInsensitive.values()) {\n      sortTreeNodes(child);\n    }\n  }\n  if (node.dynamic?.length) {\n    node.dynamic.sort(sortDynamic);\n    for (const child of node.dynamic) {\n      sortTreeNodes(child);\n    }\n  }\n  if (node.optional?.length) {\n    node.optional.sort(sortDynamic);\n    for (const child of node.optional) {\n      sortTreeNodes(child);\n    }\n  }\n  if (node.wildcard?.length) {\n    node.wildcard.sort(sortDynamic);\n    for (const child of node.wildcard) {\n      sortTreeNodes(child);\n    }\n  }\n}\nfunction createStaticNode(fullPath) {\n  return {\n    kind: SEGMENT_TYPE_PATHNAME,\n    depth: 0,\n    pathless: null,\n    index: null,\n    static: null,\n    staticInsensitive: null,\n    dynamic: null,\n    optional: null,\n    wildcard: null,\n    route: null,\n    fullPath,\n    parent: null,\n    parse: null,\n    skipOnParamError: false,\n    parsingPriority: 0\n  };\n}\nfunction createDynamicNode(kind, fullPath, caseSensitive, prefix, suffix) {\n  return {\n    kind,\n    depth: 0,\n    pathless: null,\n    index: null,\n    static: null,\n    staticInsensitive: null,\n    dynamic: null,\n    optional: null,\n    wildcard: null,\n    route: null,\n    fullPath,\n    parent: null,\n    parse: null,\n    skipOnParamError: false,\n    parsingPriority: 0,\n    caseSensitive,\n    prefix,\n    suffix\n  };\n}\nfunction processRouteMasks(routeList, processedTree) {\n  const segmentTree = createStaticNode(\"/\");\n  const data = new Uint16Array(6);\n  for (const route of routeList) {\n    parseSegments(false, data, route, 1, segmentTree, 0);\n  }\n  sortTreeNodes(segmentTree);\n  processedTree.masksTree = segmentTree;\n  processedTree.flatCache = createLRUCache(1e3);\n}\nfunction findFlatMatch(path, processedTree) {\n  path ||= \"/\";\n  const cached = processedTree.flatCache.get(path);\n  if (cached) return cached;\n  const result = findMatch(path, processedTree.masksTree);\n  processedTree.flatCache.set(path, result);\n  return result;\n}\nfunction findSingleMatch(from, caseSensitive, fuzzy, path, processedTree) {\n  from ||= \"/\";\n  path ||= \"/\";\n  const key = caseSensitive ? `case\\0${from}` : from;\n  let tree = processedTree.singleCache.get(key);\n  if (!tree) {\n    tree = createStaticNode(\"/\");\n    const data = new Uint16Array(6);\n    parseSegments(caseSensitive, data, { from }, 1, tree, 0);\n    processedTree.singleCache.set(key, tree);\n  }\n  return findMatch(path, tree, fuzzy);\n}\nfunction findRouteMatch(path, processedTree, fuzzy = false) {\n  const key = fuzzy ? path : `nofuzz\\0${path}`;\n  const cached = processedTree.matchCache.get(key);\n  if (cached !== void 0) return cached;\n  path ||= \"/\";\n  let result;\n  try {\n    result = findMatch(\n      path,\n      processedTree.segmentTree,\n      fuzzy\n    );\n  } catch (err) {\n    if (err instanceof URIError) {\n      result = null;\n    } else {\n      throw err;\n    }\n  }\n  if (result) result.branch = buildRouteBranch(result.route);\n  processedTree.matchCache.set(key, result);\n  return result;\n}\nfunction trimPathRight(path) {\n  return path === \"/\" ? path : path.replace(/\\/{1,}$/, \"\");\n}\nfunction processRouteTree(routeTree, caseSensitive = false, initRoute) {\n  const segmentTree = createStaticNode(routeTree.fullPath);\n  const data = new Uint16Array(6);\n  const routesById = {};\n  const routesByPath = {};\n  let index = 0;\n  parseSegments(caseSensitive, data, routeTree, 1, segmentTree, 0, (route) => {\n    initRoute?.(route, index);\n    invariant(\n      !(route.id in routesById),\n      `Duplicate routes found with id: ${String(route.id)}`\n    );\n    routesById[route.id] = route;\n    if (index !== 0 && route.path) {\n      const trimmedFullPath = trimPathRight(route.fullPath);\n      if (!routesByPath[trimmedFullPath] || route.fullPath.endsWith(\"/\")) {\n        routesByPath[trimmedFullPath] = route;\n      }\n    }\n    index++;\n  });\n  sortTreeNodes(segmentTree);\n  const processedTree = {\n    segmentTree,\n    singleCache: createLRUCache(1e3),\n    matchCache: createLRUCache(1e3),\n    flatCache: null,\n    masksTree: null\n  };\n  return {\n    processedTree,\n    routesById,\n    routesByPath\n  };\n}\nfunction findMatch(path, segmentTree, fuzzy = false) {\n  const parts = path.split(\"/\");\n  const leaf = getNodeMatch(path, parts, segmentTree, fuzzy);\n  if (!leaf) return null;\n  const [rawParams] = extractParams(path, parts, leaf);\n  return {\n    route: leaf.node.route,\n    rawParams,\n    parsedParams: leaf.parsedParams\n  };\n}\nfunction extractParams(path, parts, leaf) {\n  const list = buildBranch(leaf.node);\n  let nodeParts = null;\n  const rawParams = {};\n  let partIndex = leaf.extract?.part ?? 0;\n  let nodeIndex = leaf.extract?.node ?? 0;\n  let pathIndex = leaf.extract?.path ?? 0;\n  let segmentCount = leaf.extract?.segment ?? 0;\n  for (; nodeIndex < list.length; partIndex++, nodeIndex++, pathIndex++, segmentCount++) {\n    const node = list[nodeIndex];\n    if (node.kind === SEGMENT_TYPE_INDEX) break;\n    if (node.kind === SEGMENT_TYPE_PATHLESS) {\n      segmentCount--;\n      partIndex--;\n      pathIndex--;\n      continue;\n    }\n    const part = parts[partIndex];\n    const currentPathIndex = pathIndex;\n    if (part) pathIndex += part.length;\n    if (node.kind === SEGMENT_TYPE_PARAM) {\n      nodeParts ??= leaf.node.fullPath.split(\"/\");\n      const nodePart = nodeParts[segmentCount];\n      const preLength = node.prefix?.length ?? 0;\n      const isCurlyBraced = nodePart.charCodeAt(preLength) === 123;\n      if (isCurlyBraced) {\n        const sufLength = node.suffix?.length ?? 0;\n        const name = nodePart.substring(\n          preLength + 2,\n          nodePart.length - sufLength - 1\n        );\n        const value = part.substring(preLength, part.length - sufLength);\n        rawParams[name] = decodeURIComponent(value);\n      } else {\n        const name = nodePart.substring(1);\n        rawParams[name] = decodeURIComponent(part);\n      }\n    } else if (node.kind === SEGMENT_TYPE_OPTIONAL_PARAM) {\n      if (leaf.skipped & 1 << nodeIndex) {\n        partIndex--;\n        pathIndex = currentPathIndex - 1;\n        continue;\n      }\n      nodeParts ??= leaf.node.fullPath.split(\"/\");\n      const nodePart = nodeParts[segmentCount];\n      const preLength = node.prefix?.length ?? 0;\n      const sufLength = node.suffix?.length ?? 0;\n      const name = nodePart.substring(\n        preLength + 3,\n        nodePart.length - sufLength - 1\n      );\n      const value = node.suffix || node.prefix ? part.substring(preLength, part.length - sufLength) : part;\n      if (value) rawParams[name] = decodeURIComponent(value);\n    } else if (node.kind === SEGMENT_TYPE_WILDCARD) {\n      const n = node;\n      const value = path.substring(\n        currentPathIndex + (n.prefix?.length ?? 0),\n        path.length - (n.suffix?.length ?? 0)\n      );\n      const splat = decodeURIComponent(value);\n      rawParams[\"*\"] = splat;\n      rawParams._splat = splat;\n      break;\n    }\n  }\n  if (leaf.rawParams) Object.assign(rawParams, leaf.rawParams);\n  return [\n    rawParams,\n    {\n      part: partIndex,\n      node: nodeIndex,\n      path: pathIndex,\n      segment: segmentCount\n    }\n  ];\n}\nfunction buildRouteBranch(route) {\n  const list = [route];\n  while (route.parentRoute) {\n    route = route.parentRoute;\n    list.push(route);\n  }\n  list.reverse();\n  return list;\n}\nfunction buildBranch(node) {\n  const list = Array(node.depth + 1);\n  do {\n    list[node.depth] = node;\n    node = node.parent;\n  } while (node);\n  return list;\n}\nfunction getNodeMatch(path, parts, segmentTree, fuzzy) {\n  if (path === \"/\" && segmentTree.index)\n    return { node: segmentTree.index, skipped: 0 };\n  const trailingSlash = !last(parts);\n  const pathIsIndex = trailingSlash && path !== \"/\";\n  const partsLength = parts.length - (trailingSlash ? 1 : 0);\n  const stack = [\n    {\n      node: segmentTree,\n      index: 1,\n      skipped: 0,\n      depth: 1,\n      statics: 1,\n      dynamics: 0,\n      optionals: 0\n    }\n  ];\n  let wildcardMatch = null;\n  let bestFuzzy = null;\n  let bestMatch = null;\n  while (stack.length) {\n    const frame = stack.pop();\n    const { node, index, skipped, depth, statics, dynamics, optionals } = frame;\n    let { extract, rawParams, parsedParams } = frame;\n    if (node.skipOnParamError) {\n      const result = validateMatchParams(path, parts, frame);\n      if (!result) continue;\n      rawParams = frame.rawParams;\n      extract = frame.extract;\n      parsedParams = frame.parsedParams;\n    }\n    if (fuzzy && node.route && node.kind !== SEGMENT_TYPE_INDEX && isFrameMoreSpecific(bestFuzzy, frame)) {\n      bestFuzzy = frame;\n    }\n    const isBeyondPath = index === partsLength;\n    if (isBeyondPath) {\n      if (node.route && !pathIsIndex && isFrameMoreSpecific(bestMatch, frame)) {\n        bestMatch = frame;\n      }\n      if (!node.optional && !node.wildcard && !node.index && !node.pathless)\n        continue;\n    }\n    const part = isBeyondPath ? void 0 : parts[index];\n    let lowerPart;\n    if (isBeyondPath && node.index) {\n      const indexFrame = {\n        node: node.index,\n        index,\n        skipped,\n        depth: depth + 1,\n        statics,\n        dynamics,\n        optionals,\n        extract,\n        rawParams,\n        parsedParams\n      };\n      let indexValid = true;\n      if (node.index.skipOnParamError) {\n        const result = validateMatchParams(path, parts, indexFrame);\n        if (!result) indexValid = false;\n      }\n      if (indexValid) {\n        if (statics === partsLength && !dynamics && !optionals && !skipped) {\n          return indexFrame;\n        }\n        if (isFrameMoreSpecific(bestMatch, indexFrame)) {\n          bestMatch = indexFrame;\n        }\n      }\n    }\n    if (node.wildcard && isFrameMoreSpecific(wildcardMatch, frame)) {\n      for (const segment of node.wildcard) {\n        const { prefix, suffix } = segment;\n        if (prefix) {\n          if (isBeyondPath) continue;\n          const casePart = segment.caseSensitive ? part : lowerPart ??= part.toLowerCase();\n          if (!casePart.startsWith(prefix)) continue;\n        }\n        if (suffix) {\n          if (isBeyondPath) continue;\n          const end = parts.slice(index).join(\"/\").slice(-suffix.length);\n          const casePart = segment.caseSensitive ? end : end.toLowerCase();\n          if (casePart !== suffix) continue;\n        }\n        const frame2 = {\n          node: segment,\n          index: partsLength,\n          skipped,\n          depth,\n          statics,\n          dynamics,\n          optionals,\n          extract,\n          rawParams,\n          parsedParams\n        };\n        if (segment.skipOnParamError) {\n          const result = validateMatchParams(path, parts, frame2);\n          if (!result) continue;\n        }\n        wildcardMatch = frame2;\n        break;\n      }\n    }\n    if (node.optional) {\n      const nextSkipped = skipped | 1 << depth;\n      const nextDepth = depth + 1;\n      for (let i = node.optional.length - 1; i >= 0; i--) {\n        const segment = node.optional[i];\n        stack.push({\n          node: segment,\n          index,\n          skipped: nextSkipped,\n          depth: nextDepth,\n          statics,\n          dynamics,\n          optionals,\n          extract,\n          rawParams,\n          parsedParams\n        });\n      }\n      if (!isBeyondPath) {\n        for (let i = node.optional.length - 1; i >= 0; i--) {\n          const segment = node.optional[i];\n          const { prefix, suffix } = segment;\n          if (prefix || suffix) {\n            const casePart = segment.caseSensitive ? part : lowerPart ??= part.toLowerCase();\n            if (prefix && !casePart.startsWith(prefix)) continue;\n            if (suffix && !casePart.endsWith(suffix)) continue;\n          }\n          stack.push({\n            node: segment,\n            index: index + 1,\n            skipped,\n            depth: nextDepth,\n            statics,\n            dynamics,\n            optionals: optionals + 1,\n            extract,\n            rawParams,\n            parsedParams\n          });\n        }\n      }\n    }\n    if (!isBeyondPath && node.dynamic && part) {\n      for (let i = node.dynamic.length - 1; i >= 0; i--) {\n        const segment = node.dynamic[i];\n        const { prefix, suffix } = segment;\n        if (prefix || suffix) {\n          const casePart = segment.caseSensitive ? part : lowerPart ??= part.toLowerCase();\n          if (prefix && !casePart.startsWith(prefix)) continue;\n          if (suffix && !casePart.endsWith(suffix)) continue;\n        }\n        stack.push({\n          node: segment,\n          index: index + 1,\n          skipped,\n          depth: depth + 1,\n          statics,\n          dynamics: dynamics + 1,\n          optionals,\n          extract,\n          rawParams,\n          parsedParams\n        });\n      }\n    }\n    if (!isBeyondPath && node.staticInsensitive) {\n      const match = node.staticInsensitive.get(\n        lowerPart ??= part.toLowerCase()\n      );\n      if (match) {\n        stack.push({\n          node: match,\n          index: index + 1,\n          skipped,\n          depth: depth + 1,\n          statics: statics + 1,\n          dynamics,\n          optionals,\n          extract,\n          rawParams,\n          parsedParams\n        });\n      }\n    }\n    if (!isBeyondPath && node.static) {\n      const match = node.static.get(part);\n      if (match) {\n        stack.push({\n          node: match,\n          index: index + 1,\n          skipped,\n          depth: depth + 1,\n          statics: statics + 1,\n          dynamics,\n          optionals,\n          extract,\n          rawParams,\n          parsedParams\n        });\n      }\n    }\n    if (node.pathless) {\n      const nextDepth = depth + 1;\n      for (let i = node.pathless.length - 1; i >= 0; i--) {\n        const segment = node.pathless[i];\n        stack.push({\n          node: segment,\n          index,\n          skipped,\n          depth: nextDepth,\n          statics,\n          dynamics,\n          optionals,\n          extract,\n          rawParams,\n          parsedParams\n        });\n      }\n    }\n  }\n  if (bestMatch && wildcardMatch) {\n    return isFrameMoreSpecific(wildcardMatch, bestMatch) ? bestMatch : wildcardMatch;\n  }\n  if (bestMatch) return bestMatch;\n  if (wildcardMatch) return wildcardMatch;\n  if (fuzzy && bestFuzzy) {\n    let sliceIndex = bestFuzzy.index;\n    for (let i = 0; i < bestFuzzy.index; i++) {\n      sliceIndex += parts[i].length;\n    }\n    const splat = sliceIndex === path.length ? \"/\" : path.slice(sliceIndex);\n    bestFuzzy.rawParams ??= {};\n    bestFuzzy.rawParams[\"**\"] = decodeURIComponent(splat);\n    return bestFuzzy;\n  }\n  return null;\n}\nfunction validateMatchParams(path, parts, frame) {\n  try {\n    const [rawParams, state] = extractParams(path, parts, frame);\n    frame.rawParams = rawParams;\n    frame.extract = state;\n    const parsed = frame.node.parse(rawParams);\n    frame.parsedParams = Object.assign({}, frame.parsedParams, parsed);\n    return true;\n  } catch {\n    return null;\n  }\n}\nfunction isFrameMoreSpecific(prev, next) {\n  if (!prev) return true;\n  return next.statics > prev.statics || next.statics === prev.statics && (next.dynamics > prev.dynamics || next.dynamics === prev.dynamics && (next.optionals > prev.optionals || next.optionals === prev.optionals && ((next.node.kind === SEGMENT_TYPE_INDEX) > (prev.node.kind === SEGMENT_TYPE_INDEX) || next.node.kind === SEGMENT_TYPE_INDEX === (prev.node.kind === SEGMENT_TYPE_INDEX) && next.depth > prev.depth)));\n}\nexport {\n  SEGMENT_TYPE_OPTIONAL_PARAM,\n  SEGMENT_TYPE_PARAM,\n  SEGMENT_TYPE_PATHNAME,\n  SEGMENT_TYPE_WILDCARD,\n  findFlatMatch,\n  findRouteMatch,\n  findSingleMatch,\n  parseSegment,\n  processRouteMasks,\n  processRouteTree,\n  trimPathRight\n};\n//# sourceMappingURL=new-process-route-tree.js.map\n","import { last } from \"./utils.js\";\nimport { parseSegment, SEGMENT_TYPE_PATHNAME, SEGMENT_TYPE_WILDCARD, SEGMENT_TYPE_PARAM, SEGMENT_TYPE_OPTIONAL_PARAM } from \"./new-process-route-tree.js\";\nfunction joinPaths(paths) {\n  return cleanPath(\n    paths.filter((val) => {\n      return val !== void 0;\n    }).join(\"/\")\n  );\n}\nfunction cleanPath(path) {\n  return path.replace(/\\/{2,}/g, \"/\");\n}\nfunction trimPathLeft(path) {\n  return path === \"/\" ? path : path.replace(/^\\/{1,}/, \"\");\n}\nfunction trimPathRight(path) {\n  const len = path.length;\n  return len > 1 && path[len - 1] === \"/\" ? path.replace(/\\/{1,}$/, \"\") : path;\n}\nfunction trimPath(path) {\n  return trimPathRight(trimPathLeft(path));\n}\nfunction removeTrailingSlash(value, basepath) {\n  if (value?.endsWith(\"/\") && value !== \"/\" && value !== `${basepath}/`) {\n    return value.slice(0, -1);\n  }\n  return value;\n}\nfunction exactPathTest(pathName1, pathName2, basepath) {\n  return removeTrailingSlash(pathName1, basepath) === removeTrailingSlash(pathName2, basepath);\n}\nfunction resolvePath({\n  base,\n  to,\n  trailingSlash = \"never\",\n  cache\n}) {\n  const isAbsolute = to.startsWith(\"/\");\n  const isBase = !isAbsolute && to === \".\";\n  let key;\n  if (cache) {\n    key = isAbsolute ? to : isBase ? base : base + \"\\0\" + to;\n    const cached = cache.get(key);\n    if (cached) return cached;\n  }\n  let baseSegments;\n  if (isBase) {\n    baseSegments = base.split(\"/\");\n  } else if (isAbsolute) {\n    baseSegments = to.split(\"/\");\n  } else {\n    baseSegments = base.split(\"/\");\n    while (baseSegments.length > 1 && last(baseSegments) === \"\") {\n      baseSegments.pop();\n    }\n    const toSegments = to.split(\"/\");\n    for (let index = 0, length = toSegments.length; index < length; index++) {\n      const value = toSegments[index];\n      if (value === \"\") {\n        if (!index) {\n          baseSegments = [value];\n        } else if (index === length - 1) {\n          baseSegments.push(value);\n        } else ;\n      } else if (value === \"..\") {\n        baseSegments.pop();\n      } else if (value === \".\") ;\n      else {\n        baseSegments.push(value);\n      }\n    }\n  }\n  if (baseSegments.length > 1) {\n    if (last(baseSegments) === \"\") {\n      if (trailingSlash === \"never\") {\n        baseSegments.pop();\n      }\n    } else if (trailingSlash === \"always\") {\n      baseSegments.push(\"\");\n    }\n  }\n  let segment;\n  let joined = \"\";\n  for (let i = 0; i < baseSegments.length; i++) {\n    if (i > 0) joined += \"/\";\n    const part = baseSegments[i];\n    if (!part) continue;\n    segment = parseSegment(part, 0, segment);\n    const kind = segment[0];\n    if (kind === SEGMENT_TYPE_PATHNAME) {\n      joined += part;\n      continue;\n    }\n    const end = segment[5];\n    const prefix = part.substring(0, segment[1]);\n    const suffix = part.substring(segment[4], end);\n    const value = part.substring(segment[2], segment[3]);\n    if (kind === SEGMENT_TYPE_PARAM) {\n      joined += prefix || suffix ? `${prefix}{$${value}}${suffix}` : `$${value}`;\n    } else if (kind === SEGMENT_TYPE_WILDCARD) {\n      joined += prefix || suffix ? `${prefix}{$}${suffix}` : \"$\";\n    } else {\n      joined += `${prefix}{-$${value}}${suffix}`;\n    }\n  }\n  joined = cleanPath(joined);\n  const result = joined || \"/\";\n  if (key && cache) cache.set(key, result);\n  return result;\n}\nfunction encodeParam(key, params, decodeCharMap) {\n  const value = params[key];\n  if (typeof value !== \"string\") return value;\n  if (key === \"_splat\") {\n    return encodeURI(value);\n  } else {\n    return encodePathParam(value, decodeCharMap);\n  }\n}\nfunction interpolatePath({\n  path,\n  params,\n  decodeCharMap\n}) {\n  let isMissingParams = false;\n  const usedParams = {};\n  if (!path || path === \"/\")\n    return { interpolatedPath: \"/\", usedParams, isMissingParams };\n  if (!path.includes(\"$\"))\n    return { interpolatedPath: path, usedParams, isMissingParams };\n  const length = path.length;\n  let cursor = 0;\n  let segment;\n  let joined = \"\";\n  while (cursor < length) {\n    const start = cursor;\n    segment = parseSegment(path, start, segment);\n    const end = segment[5];\n    cursor = end + 1;\n    if (start === end) continue;\n    const kind = segment[0];\n    if (kind === SEGMENT_TYPE_PATHNAME) {\n      joined += \"/\" + path.substring(start, end);\n      continue;\n    }\n    if (kind === SEGMENT_TYPE_WILDCARD) {\n      const splat = params._splat;\n      usedParams._splat = splat;\n      usedParams[\"*\"] = splat;\n      const prefix = path.substring(start, segment[1]);\n      const suffix = path.substring(segment[4], end);\n      if (!splat) {\n        isMissingParams = true;\n        if (prefix || suffix) {\n          joined += \"/\" + prefix + suffix;\n        }\n        continue;\n      }\n      const value = encodeParam(\"_splat\", params, decodeCharMap);\n      joined += \"/\" + prefix + value + suffix;\n      continue;\n    }\n    if (kind === SEGMENT_TYPE_PARAM) {\n      const key = path.substring(segment[2], segment[3]);\n      if (!isMissingParams && !(key in params)) {\n        isMissingParams = true;\n      }\n      usedParams[key] = params[key];\n      const prefix = path.substring(start, segment[1]);\n      const suffix = path.substring(segment[4], end);\n      const value = encodeParam(key, params, decodeCharMap) ?? \"undefined\";\n      joined += \"/\" + prefix + value + suffix;\n      continue;\n    }\n    if (kind === SEGMENT_TYPE_OPTIONAL_PARAM) {\n      const key = path.substring(segment[2], segment[3]);\n      const valueRaw = params[key];\n      if (valueRaw == null) continue;\n      usedParams[key] = valueRaw;\n      const prefix = path.substring(start, segment[1]);\n      const suffix = path.substring(segment[4], end);\n      const value = encodeParam(key, params, decodeCharMap) ?? \"\";\n      joined += \"/\" + prefix + value + suffix;\n      continue;\n    }\n  }\n  if (path.endsWith(\"/\")) joined += \"/\";\n  const interpolatedPath = joined || \"/\";\n  return { usedParams, interpolatedPath, isMissingParams };\n}\nfunction encodePathParam(value, decodeCharMap) {\n  let encoded = encodeURIComponent(value);\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char);\n    }\n  }\n  return encoded;\n}\nexport {\n  cleanPath,\n  exactPathTest,\n  interpolatePath,\n  joinPaths,\n  removeTrailingSlash,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight\n};\n//# sourceMappingURL=path.js.map\n","function notFound(options = {}) {\n  options.isNotFound = true;\n  if (options.throw) throw options;\n  return options;\n}\nfunction isNotFound(obj) {\n  return !!obj?.isNotFound;\n}\nexport {\n  isNotFound,\n  notFound\n};\n//# sourceMappingURL=not-found.js.map\n","import { functionalUpdate } from \"./utils.js\";\nfunction getSafeSessionStorage() {\n  try {\n    if (typeof window !== \"undefined\" && typeof window.sessionStorage === \"object\") {\n      return window.sessionStorage;\n    }\n  } catch {\n  }\n  return void 0;\n}\nconst storageKey = \"tsr-scroll-restoration-v1_3\";\nconst throttle = (fn, wait) => {\n  let timeout;\n  return (...args) => {\n    if (!timeout) {\n      timeout = setTimeout(() => {\n        fn(...args);\n        timeout = null;\n      }, wait);\n    }\n  };\n};\nfunction createScrollRestorationCache() {\n  const safeSessionStorage = getSafeSessionStorage();\n  if (!safeSessionStorage) {\n    return null;\n  }\n  const persistedState = safeSessionStorage.getItem(storageKey);\n  let state = persistedState ? JSON.parse(persistedState) : {};\n  return {\n    state,\n    // This setter is simply to make sure that we set the sessionStorage right\n    // after the state is updated. It doesn't necessarily need to be a functional\n    // update.\n    set: (updater) => {\n      state = functionalUpdate(updater, state) || state;\n      try {\n        safeSessionStorage.setItem(storageKey, JSON.stringify(state));\n      } catch {\n        console.warn(\n          \"[ts-router] Could not persist scroll restoration state to sessionStorage.\"\n        );\n      }\n    }\n  };\n}\nconst scrollRestorationCache = createScrollRestorationCache();\nconst defaultGetScrollRestorationKey = (location) => {\n  return location.state.__TSR_key || location.href;\n};\nfunction getCssSelector(el) {\n  const path = [];\n  let parent;\n  while (parent = el.parentNode) {\n    path.push(\n      `${el.tagName}:nth-child(${Array.prototype.indexOf.call(parent.children, el) + 1})`\n    );\n    el = parent;\n  }\n  return `${path.reverse().join(\" > \")}`.toLowerCase();\n}\nlet ignoreScroll = false;\nfunction restoreScroll({\n  storageKey: storageKey2,\n  key,\n  behavior,\n  shouldScrollRestoration,\n  scrollToTopSelectors,\n  location\n}) {\n  let byKey;\n  try {\n    byKey = JSON.parse(sessionStorage.getItem(storageKey2) || \"{}\");\n  } catch (error) {\n    console.error(error);\n    return;\n  }\n  const resolvedKey = key || window.history.state?.__TSR_key;\n  const elementEntries = byKey[resolvedKey];\n  ignoreScroll = true;\n  scroll: {\n    if (shouldScrollRestoration && elementEntries && Object.keys(elementEntries).length > 0) {\n      for (const elementSelector in elementEntries) {\n        const entry = elementEntries[elementSelector];\n        if (elementSelector === \"window\") {\n          window.scrollTo({\n            top: entry.scrollY,\n            left: entry.scrollX,\n            behavior\n          });\n        } else if (elementSelector) {\n          const element = document.querySelector(elementSelector);\n          if (element) {\n            element.scrollLeft = entry.scrollX;\n            element.scrollTop = entry.scrollY;\n          }\n        }\n      }\n      break scroll;\n    }\n    const hash = (location ?? window.location).hash.split(\"#\", 2)[1];\n    if (hash) {\n      const hashScrollIntoViewOptions = window.history.state?.__hashScrollIntoViewOptions ?? true;\n      if (hashScrollIntoViewOptions) {\n        const el = document.getElementById(hash);\n        if (el) {\n          el.scrollIntoView(hashScrollIntoViewOptions);\n        }\n      }\n      break scroll;\n    }\n    const scrollOptions = { top: 0, left: 0, behavior };\n    window.scrollTo(scrollOptions);\n    if (scrollToTopSelectors) {\n      for (const selector of scrollToTopSelectors) {\n        if (selector === \"window\") continue;\n        const element = typeof selector === \"function\" ? selector() : document.querySelector(selector);\n        if (element) element.scrollTo(scrollOptions);\n      }\n    }\n  }\n  ignoreScroll = false;\n}\nfunction setupScrollRestoration(router, force) {\n  if (!scrollRestorationCache && !router.isServer) {\n    return;\n  }\n  const shouldScrollRestoration = force ?? router.options.scrollRestoration ?? false;\n  if (shouldScrollRestoration) {\n    router.isScrollRestoring = true;\n  }\n  if (router.isServer || router.isScrollRestorationSetup || !scrollRestorationCache) {\n    return;\n  }\n  router.isScrollRestorationSetup = true;\n  ignoreScroll = false;\n  const getKey = router.options.getScrollRestorationKey || defaultGetScrollRestorationKey;\n  window.history.scrollRestoration = \"manual\";\n  const onScroll = (event) => {\n    if (ignoreScroll || !router.isScrollRestoring) {\n      return;\n    }\n    let elementSelector = \"\";\n    if (event.target === document || event.target === window) {\n      elementSelector = \"window\";\n    } else {\n      const attrId = event.target.getAttribute(\n        \"data-scroll-restoration-id\"\n      );\n      if (attrId) {\n        elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`;\n      } else {\n        elementSelector = getCssSelector(event.target);\n      }\n    }\n    const restoreKey = getKey(router.state.location);\n    scrollRestorationCache.set((state) => {\n      const keyEntry = state[restoreKey] ||= {};\n      const elementEntry = keyEntry[elementSelector] ||= {};\n      if (elementSelector === \"window\") {\n        elementEntry.scrollX = window.scrollX || 0;\n        elementEntry.scrollY = window.scrollY || 0;\n      } else if (elementSelector) {\n        const element = document.querySelector(elementSelector);\n        if (element) {\n          elementEntry.scrollX = element.scrollLeft || 0;\n          elementEntry.scrollY = element.scrollTop || 0;\n        }\n      }\n      return state;\n    });\n  };\n  if (typeof document !== \"undefined\") {\n    document.addEventListener(\"scroll\", throttle(onScroll, 100), true);\n  }\n  router.subscribe(\"onRendered\", (event) => {\n    const cacheKey = getKey(event.toLocation);\n    const resetScroll = event.toLocation.state.__TSR_resetScroll ?? true;\n    if (!resetScroll) {\n      return;\n    }\n    if (typeof router.options.scrollRestoration === \"function\") {\n      const shouldRestore = router.options.scrollRestoration({\n        location: router.latestLocation\n      });\n      if (!shouldRestore) {\n        return;\n      }\n    }\n    restoreScroll({\n      storageKey,\n      key: cacheKey,\n      behavior: router.options.scrollRestorationBehavior,\n      shouldScrollRestoration: router.isScrollRestoring,\n      scrollToTopSelectors: router.options.scrollToTopSelectors,\n      location: router.history.location\n    });\n    if (router.isScrollRestoring) {\n      scrollRestorationCache.set((state) => {\n        state[cacheKey] ||= {};\n        return state;\n      });\n    }\n  });\n}\nfunction handleHashScroll(router) {\n  if (typeof document !== \"undefined\" && document.querySelector) {\n    const hashScrollIntoViewOptions = router.state.location.state.__hashScrollIntoViewOptions ?? true;\n    if (hashScrollIntoViewOptions && router.state.location.hash !== \"\") {\n      const el = document.getElementById(router.state.location.hash);\n      if (el) {\n        el.scrollIntoView(hashScrollIntoViewOptions);\n      }\n    }\n  }\n}\nexport {\n  defaultGetScrollRestorationKey,\n  getCssSelector,\n  handleHashScroll,\n  restoreScroll,\n  scrollRestorationCache,\n  setupScrollRestoration,\n  storageKey\n};\n//# sourceMappingURL=scroll-restoration.js.map\n","function encode(obj, stringify = String) {\n  const result = new URLSearchParams();\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result.set(key, stringify(val));\n    }\n  }\n  return result.toString();\n}\nfunction toValue(str) {\n  if (!str) return \"\";\n  if (str === \"false\") return false;\n  if (str === \"true\") return true;\n  return +str * 0 === 0 && +str + \"\" === str ? +str : str;\n}\nfunction decode(str) {\n  const searchParams = new URLSearchParams(str);\n  const result = {};\n  for (const [key, value] of searchParams.entries()) {\n    const previousValue = result[key];\n    if (previousValue == null) {\n      result[key] = toValue(value);\n    } else if (Array.isArray(previousValue)) {\n      previousValue.push(toValue(value));\n    } else {\n      result[key] = [previousValue, toValue(value)];\n    }\n  }\n  return result;\n}\nexport {\n  decode,\n  encode\n};\n//# sourceMappingURL=qss.js.map\n","import { decode, encode } from \"./qss.js\";\nconst defaultParseSearch = parseSearchWith(JSON.parse);\nconst defaultStringifySearch = stringifySearchWith(\n  JSON.stringify,\n  JSON.parse\n);\nfunction parseSearchWith(parser) {\n  return (searchStr) => {\n    if (searchStr[0] === \"?\") {\n      searchStr = searchStr.substring(1);\n    }\n    const query = decode(searchStr);\n    for (const key in query) {\n      const value = query[key];\n      if (typeof value === \"string\") {\n        try {\n          query[key] = parser(value);\n        } catch (_err) {\n        }\n      }\n    }\n    return query;\n  };\n}\nfunction stringifySearchWith(stringify, parser) {\n  const hasParser = typeof parser === \"function\";\n  function stringifyValue(val) {\n    if (typeof val === \"object\" && val !== null) {\n      try {\n        return stringify(val);\n      } catch (_err) {\n      }\n    } else if (hasParser && typeof val === \"string\") {\n      try {\n        parser(val);\n        return stringify(val);\n      } catch (_err) {\n      }\n    }\n    return val;\n  }\n  return (search) => {\n    const searchStr = encode(search, stringifyValue);\n    return searchStr ? `?${searchStr}` : \"\";\n  };\n}\nexport {\n  defaultParseSearch,\n  defaultStringifySearch,\n  parseSearchWith,\n  stringifySearchWith\n};\n//# sourceMappingURL=searchParams.js.map\n","const rootRouteId = \"__root__\";\nexport {\n  rootRouteId\n};\n//# sourceMappingURL=root.js.map\n","import { isDangerousProtocol, SAFE_URL_PROTOCOLS } from \"./utils.js\";\nfunction redirect(opts) {\n  opts.statusCode = opts.statusCode || opts.code || 307;\n  if (typeof opts.href === \"string\" && isDangerousProtocol(opts.href)) {\n    throw new Error(\n      `Redirect blocked: unsafe protocol in href \"${opts.href}\". Only ${SAFE_URL_PROTOCOLS.join(\", \")} protocols are allowed.`\n    );\n  }\n  if (!opts.reloadDocument && typeof opts.href === \"string\") {\n    try {\n      new URL(opts.href);\n      opts.reloadDocument = true;\n    } catch {\n    }\n  }\n  const headers = new Headers(opts.headers);\n  if (opts.href && headers.get(\"Location\") === null) {\n    headers.set(\"Location\", opts.href);\n  }\n  const response = new Response(null, {\n    status: opts.statusCode,\n    headers\n  });\n  response.options = opts;\n  if (opts.throw) {\n    throw response;\n  }\n  return response;\n}\nfunction isRedirect(obj) {\n  return obj instanceof Response && !!obj.options;\n}\nfunction isResolvedRedirect(obj) {\n  return isRedirect(obj) && !!obj.options.href;\n}\nfunction parseRedirect(obj) {\n  if (obj !== null && typeof obj === \"object\" && obj.isSerializedRedirect) {\n    return redirect(obj);\n  }\n  return void 0;\n}\nexport {\n  isRedirect,\n  isResolvedRedirect,\n  parseRedirect,\n  redirect\n};\n//# sourceMappingURL=redirect.js.map\n","import { batch } from \"@tanstack/store\";\nimport invariant from \"tiny-invariant\";\nimport { isPromise, createControlledPromise } from \"./utils.js\";\nimport { isNotFound } from \"./not-found.js\";\nimport { rootRouteId } from \"./root.js\";\nimport { isRedirect } from \"./redirect.js\";\nconst triggerOnReady = (inner) => {\n  if (!inner.rendered) {\n    inner.rendered = true;\n    return inner.onReady?.();\n  }\n};\nconst resolvePreload = (inner, matchId) => {\n  return !!(inner.preload && !inner.router.state.matches.some((d) => d.id === matchId));\n};\nconst buildMatchContext = (inner, index, includeCurrentMatch = true) => {\n  const context = {\n    ...inner.router.options.context ?? {}\n  };\n  const end = includeCurrentMatch ? index : index - 1;\n  for (let i = 0; i <= end; i++) {\n    const innerMatch = inner.matches[i];\n    if (!innerMatch) continue;\n    const m = inner.router.getMatch(innerMatch.id);\n    if (!m) continue;\n    Object.assign(context, m.__routeContext, m.__beforeLoadContext);\n  }\n  return context;\n};\nconst _handleNotFound = (inner, err) => {\n  const routeCursor = inner.router.routesById[err.routeId ?? \"\"] ?? inner.router.routeTree;\n  if (!routeCursor.options.notFoundComponent && inner.router.options?.defaultNotFoundComponent) {\n    routeCursor.options.notFoundComponent = inner.router.options.defaultNotFoundComponent;\n  }\n  invariant(\n    routeCursor.options.notFoundComponent,\n    \"No notFoundComponent found. Please set a notFoundComponent on your route or provide a defaultNotFoundComponent to the router.\"\n  );\n  const matchForRoute = inner.matches.find((m) => m.routeId === routeCursor.id);\n  invariant(matchForRoute, \"Could not find match for route: \" + routeCursor.id);\n  inner.updateMatch(matchForRoute.id, (prev) => ({\n    ...prev,\n    status: \"notFound\",\n    error: err,\n    isFetching: false\n  }));\n  if (err.routerCode === \"BEFORE_LOAD\" && routeCursor.parentRoute) {\n    err.routeId = routeCursor.parentRoute.id;\n    _handleNotFound(inner, err);\n  }\n};\nconst handleRedirectAndNotFound = (inner, match, err) => {\n  if (!isRedirect(err) && !isNotFound(err)) return;\n  if (isRedirect(err) && err.redirectHandled && !err.options.reloadDocument) {\n    throw err;\n  }\n  if (match) {\n    match._nonReactive.beforeLoadPromise?.resolve();\n    match._nonReactive.loaderPromise?.resolve();\n    match._nonReactive.beforeLoadPromise = void 0;\n    match._nonReactive.loaderPromise = void 0;\n    const status = isRedirect(err) ? \"redirected\" : \"notFound\";\n    match._nonReactive.error = err;\n    inner.updateMatch(match.id, (prev) => ({\n      ...prev,\n      status,\n      context: buildMatchContext(inner, match.index),\n      isFetching: false,\n      error: err\n    }));\n    if (isNotFound(err) && !err.routeId) {\n      err.routeId = match.routeId;\n    }\n    match._nonReactive.loadPromise?.resolve();\n  }\n  if (isRedirect(err)) {\n    inner.rendered = true;\n    err.options._fromLocation = inner.location;\n    err.redirectHandled = true;\n    err = inner.router.resolveRedirect(err);\n    throw err;\n  } else {\n    _handleNotFound(inner, err);\n    throw err;\n  }\n};\nconst shouldSkipLoader = (inner, matchId) => {\n  const match = inner.router.getMatch(matchId);\n  if (!inner.router.isServer && match._nonReactive.dehydrated) {\n    return true;\n  }\n  if (inner.router.isServer && match.ssr === false) {\n    return true;\n  }\n  return false;\n};\nconst handleSerialError = (inner, index, err, routerCode) => {\n  const { id: matchId, routeId } = inner.matches[index];\n  const route = inner.router.looseRoutesById[routeId];\n  if (err instanceof Promise) {\n    throw err;\n  }\n  err.routerCode = routerCode;\n  inner.firstBadMatchIndex ??= index;\n  handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), err);\n  try {\n    route.options.onError?.(err);\n  } catch (errorHandlerErr) {\n    err = errorHandlerErr;\n    handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), err);\n  }\n  inner.updateMatch(matchId, (prev) => {\n    prev._nonReactive.beforeLoadPromise?.resolve();\n    prev._nonReactive.beforeLoadPromise = void 0;\n    prev._nonReactive.loadPromise?.resolve();\n    return {\n      ...prev,\n      error: err,\n      status: \"error\",\n      isFetching: false,\n      updatedAt: Date.now(),\n      abortController: new AbortController()\n    };\n  });\n};\nconst isBeforeLoadSsr = (inner, matchId, index, route) => {\n  const existingMatch = inner.router.getMatch(matchId);\n  const parentMatchId = inner.matches[index - 1]?.id;\n  const parentMatch = parentMatchId ? inner.router.getMatch(parentMatchId) : void 0;\n  if (inner.router.isShell()) {\n    existingMatch.ssr = route.id === rootRouteId;\n    return;\n  }\n  if (parentMatch?.ssr === false) {\n    existingMatch.ssr = false;\n    return;\n  }\n  const parentOverride = (tempSsr2) => {\n    if (tempSsr2 === true && parentMatch?.ssr === \"data-only\") {\n      return \"data-only\";\n    }\n    return tempSsr2;\n  };\n  const defaultSsr = inner.router.options.defaultSsr ?? true;\n  if (route.options.ssr === void 0) {\n    existingMatch.ssr = parentOverride(defaultSsr);\n    return;\n  }\n  if (typeof route.options.ssr !== \"function\") {\n    existingMatch.ssr = parentOverride(route.options.ssr);\n    return;\n  }\n  const { search, params } = existingMatch;\n  const ssrFnContext = {\n    search: makeMaybe(search, existingMatch.searchError),\n    params: makeMaybe(params, existingMatch.paramsError),\n    location: inner.location,\n    matches: inner.matches.map((match) => ({\n      index: match.index,\n      pathname: match.pathname,\n      fullPath: match.fullPath,\n      staticData: match.staticData,\n      id: match.id,\n      routeId: match.routeId,\n      search: makeMaybe(match.search, match.searchError),\n      params: makeMaybe(match.params, match.paramsError),\n      ssr: match.ssr\n    }))\n  };\n  const tempSsr = route.options.ssr(ssrFnContext);\n  if (isPromise(tempSsr)) {\n    return tempSsr.then((ssr) => {\n      existingMatch.ssr = parentOverride(ssr ?? defaultSsr);\n    });\n  }\n  existingMatch.ssr = parentOverride(tempSsr ?? defaultSsr);\n  return;\n};\nconst setupPendingTimeout = (inner, matchId, route, match) => {\n  if (match._nonReactive.pendingTimeout !== void 0) return;\n  const pendingMs = route.options.pendingMs ?? inner.router.options.defaultPendingMs;\n  const shouldPending = !!(inner.onReady && !inner.router.isServer && !resolvePreload(inner, matchId) && (route.options.loader || route.options.beforeLoad || routeNeedsPreload(route)) && typeof pendingMs === \"number\" && pendingMs !== Infinity && (route.options.pendingComponent ?? inner.router.options?.defaultPendingComponent));\n  if (shouldPending) {\n    const pendingTimeout = setTimeout(() => {\n      triggerOnReady(inner);\n    }, pendingMs);\n    match._nonReactive.pendingTimeout = pendingTimeout;\n  }\n};\nconst preBeforeLoadSetup = (inner, matchId, route) => {\n  const existingMatch = inner.router.getMatch(matchId);\n  if (!existingMatch._nonReactive.beforeLoadPromise && !existingMatch._nonReactive.loaderPromise)\n    return;\n  setupPendingTimeout(inner, matchId, route, existingMatch);\n  const then = () => {\n    const match = inner.router.getMatch(matchId);\n    if (match.preload && (match.status === \"redirected\" || match.status === \"notFound\")) {\n      handleRedirectAndNotFound(inner, match, match.error);\n    }\n  };\n  return existingMatch._nonReactive.beforeLoadPromise ? existingMatch._nonReactive.beforeLoadPromise.then(then) : then();\n};\nconst executeBeforeLoad = (inner, matchId, index, route) => {\n  const match = inner.router.getMatch(matchId);\n  const prevLoadPromise = match._nonReactive.loadPromise;\n  match._nonReactive.loadPromise = createControlledPromise(() => {\n    prevLoadPromise?.resolve();\n  });\n  const { paramsError, searchError } = match;\n  if (paramsError) {\n    handleSerialError(inner, index, paramsError, \"PARSE_PARAMS\");\n  }\n  if (searchError) {\n    handleSerialError(inner, index, searchError, \"VALIDATE_SEARCH\");\n  }\n  setupPendingTimeout(inner, matchId, route, match);\n  const abortController = new AbortController();\n  const parentMatchId = inner.matches[index - 1]?.id;\n  const parentMatch = parentMatchId ? inner.router.getMatch(parentMatchId) : void 0;\n  parentMatch?.context ?? inner.router.options.context ?? void 0;\n  let isPending = false;\n  const pending = () => {\n    if (isPending) return;\n    isPending = true;\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: \"beforeLoad\",\n      fetchCount: prev.fetchCount + 1,\n      abortController\n      // Note: We intentionally don't update context here.\n      // Context should only be updated after beforeLoad resolves to avoid\n      // components seeing incomplete context during async beforeLoad execution.\n    }));\n  };\n  const resolve = () => {\n    match._nonReactive.beforeLoadPromise?.resolve();\n    match._nonReactive.beforeLoadPromise = void 0;\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: false\n    }));\n  };\n  if (!route.options.beforeLoad) {\n    batch(() => {\n      pending();\n      resolve();\n    });\n    return;\n  }\n  match._nonReactive.beforeLoadPromise = createControlledPromise();\n  const context = {\n    ...buildMatchContext(inner, index, false),\n    ...match.__routeContext\n  };\n  const { search, params, cause } = match;\n  const preload = resolvePreload(inner, matchId);\n  const beforeLoadFnContext = {\n    search,\n    abortController,\n    params,\n    preload,\n    context,\n    location: inner.location,\n    navigate: (opts) => inner.router.navigate({\n      ...opts,\n      _fromLocation: inner.location\n    }),\n    buildLocation: inner.router.buildLocation,\n    cause: preload ? \"preload\" : cause,\n    matches: inner.matches,\n    ...inner.router.options.additionalContext\n  };\n  const updateContext = (beforeLoadContext2) => {\n    if (beforeLoadContext2 === void 0) {\n      batch(() => {\n        pending();\n        resolve();\n      });\n      return;\n    }\n    if (isRedirect(beforeLoadContext2) || isNotFound(beforeLoadContext2)) {\n      pending();\n      handleSerialError(inner, index, beforeLoadContext2, \"BEFORE_LOAD\");\n    }\n    batch(() => {\n      pending();\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        __beforeLoadContext: beforeLoadContext2\n      }));\n      resolve();\n    });\n  };\n  let beforeLoadContext;\n  try {\n    beforeLoadContext = route.options.beforeLoad(beforeLoadFnContext);\n    if (isPromise(beforeLoadContext)) {\n      pending();\n      return beforeLoadContext.catch((err) => {\n        handleSerialError(inner, index, err, \"BEFORE_LOAD\");\n      }).then(updateContext);\n    }\n  } catch (err) {\n    pending();\n    handleSerialError(inner, index, err, \"BEFORE_LOAD\");\n  }\n  updateContext(beforeLoadContext);\n  return;\n};\nconst handleBeforeLoad = (inner, index) => {\n  const { id: matchId, routeId } = inner.matches[index];\n  const route = inner.router.looseRoutesById[routeId];\n  const serverSsr = () => {\n    if (inner.router.isServer) {\n      const maybePromise = isBeforeLoadSsr(inner, matchId, index, route);\n      if (isPromise(maybePromise)) return maybePromise.then(queueExecution);\n    }\n    return queueExecution();\n  };\n  const execute = () => executeBeforeLoad(inner, matchId, index, route);\n  const queueExecution = () => {\n    if (shouldSkipLoader(inner, matchId)) return;\n    const result = preBeforeLoadSetup(inner, matchId, route);\n    return isPromise(result) ? result.then(execute) : execute();\n  };\n  return serverSsr();\n};\nconst executeHead = (inner, matchId, route) => {\n  const match = inner.router.getMatch(matchId);\n  if (!match) {\n    return;\n  }\n  if (!route.options.head && !route.options.scripts && !route.options.headers) {\n    return;\n  }\n  const assetContext = {\n    ssr: inner.router.options.ssr,\n    matches: inner.matches,\n    match,\n    params: match.params,\n    loaderData: match.loaderData\n  };\n  return Promise.all([\n    route.options.head?.(assetContext),\n    route.options.scripts?.(assetContext),\n    route.options.headers?.(assetContext)\n  ]).then(([headFnContent, scripts, headers]) => {\n    const meta = headFnContent?.meta;\n    const links = headFnContent?.links;\n    const headScripts = headFnContent?.scripts;\n    const styles = headFnContent?.styles;\n    return {\n      meta,\n      links,\n      headScripts,\n      headers,\n      scripts,\n      styles\n    };\n  });\n};\nconst getLoaderContext = (inner, matchId, index, route) => {\n  const parentMatchPromise = inner.matchPromises[index - 1];\n  const { params, loaderDeps, abortController, cause } = inner.router.getMatch(matchId);\n  const context = buildMatchContext(inner, index);\n  const preload = resolvePreload(inner, matchId);\n  return {\n    params,\n    deps: loaderDeps,\n    preload: !!preload,\n    parentMatchPromise,\n    abortController,\n    context,\n    location: inner.location,\n    navigate: (opts) => inner.router.navigate({\n      ...opts,\n      _fromLocation: inner.location\n    }),\n    cause: preload ? \"preload\" : cause,\n    route,\n    ...inner.router.options.additionalContext\n  };\n};\nconst runLoader = async (inner, matchId, index, route) => {\n  try {\n    const match = inner.router.getMatch(matchId);\n    try {\n      if (!inner.router.isServer || match.ssr === true) {\n        loadRouteChunk(route);\n      }\n      const loaderResult = route.options.loader?.(\n        getLoaderContext(inner, matchId, index, route)\n      );\n      const loaderResultIsPromise = route.options.loader && isPromise(loaderResult);\n      const willLoadSomething = !!(loaderResultIsPromise || route._lazyPromise || route._componentsPromise || route.options.head || route.options.scripts || route.options.headers || match._nonReactive.minPendingPromise);\n      if (willLoadSomething) {\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          isFetching: \"loader\"\n        }));\n      }\n      if (route.options.loader) {\n        const loaderData = loaderResultIsPromise ? await loaderResult : loaderResult;\n        handleRedirectAndNotFound(\n          inner,\n          inner.router.getMatch(matchId),\n          loaderData\n        );\n        if (loaderData !== void 0) {\n          inner.updateMatch(matchId, (prev) => ({\n            ...prev,\n            loaderData\n          }));\n        }\n      }\n      if (route._lazyPromise) await route._lazyPromise;\n      const pendingPromise = match._nonReactive.minPendingPromise;\n      if (pendingPromise) await pendingPromise;\n      if (route._componentsPromise) await route._componentsPromise;\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        error: void 0,\n        context: buildMatchContext(inner, index),\n        status: \"success\",\n        isFetching: false,\n        updatedAt: Date.now()\n      }));\n    } catch (e) {\n      let error = e;\n      if (error?.name === \"AbortError\") {\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          status: prev.status === \"pending\" ? \"success\" : prev.status,\n          isFetching: false,\n          context: buildMatchContext(inner, index)\n        }));\n        return;\n      }\n      const pendingPromise = match._nonReactive.minPendingPromise;\n      if (pendingPromise) await pendingPromise;\n      if (isNotFound(e)) {\n        await route.options.notFoundComponent?.preload?.();\n      }\n      handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), e);\n      try {\n        route.options.onError?.(e);\n      } catch (onErrorError) {\n        error = onErrorError;\n        handleRedirectAndNotFound(\n          inner,\n          inner.router.getMatch(matchId),\n          onErrorError\n        );\n      }\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        error,\n        context: buildMatchContext(inner, index),\n        status: \"error\",\n        isFetching: false\n      }));\n    }\n  } catch (err) {\n    const match = inner.router.getMatch(matchId);\n    if (match) {\n      match._nonReactive.loaderPromise = void 0;\n    }\n    handleRedirectAndNotFound(inner, match, err);\n  }\n};\nconst loadRouteMatch = async (inner, index) => {\n  const { id: matchId, routeId } = inner.matches[index];\n  let loaderShouldRunAsync = false;\n  let loaderIsRunningAsync = false;\n  const route = inner.router.looseRoutesById[routeId];\n  if (shouldSkipLoader(inner, matchId)) {\n    if (inner.router.isServer) {\n      return inner.router.getMatch(matchId);\n    }\n  } else {\n    const prevMatch = inner.router.getMatch(matchId);\n    if (prevMatch._nonReactive.loaderPromise) {\n      if (prevMatch.status === \"success\" && !inner.sync && !prevMatch.preload) {\n        return prevMatch;\n      }\n      await prevMatch._nonReactive.loaderPromise;\n      const match2 = inner.router.getMatch(matchId);\n      const error = match2._nonReactive.error || match2.error;\n      if (error) {\n        handleRedirectAndNotFound(inner, match2, error);\n      }\n    } else {\n      const age = Date.now() - prevMatch.updatedAt;\n      const preload = resolvePreload(inner, matchId);\n      const staleAge = preload ? route.options.preloadStaleTime ?? inner.router.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? inner.router.options.defaultStaleTime ?? 0;\n      const shouldReloadOption = route.options.shouldReload;\n      const shouldReload = typeof shouldReloadOption === \"function\" ? shouldReloadOption(getLoaderContext(inner, matchId, index, route)) : shouldReloadOption;\n      const nextPreload = !!preload && !inner.router.state.matches.some((d) => d.id === matchId);\n      const match2 = inner.router.getMatch(matchId);\n      match2._nonReactive.loaderPromise = createControlledPromise();\n      if (nextPreload !== match2.preload) {\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          preload: nextPreload\n        }));\n      }\n      const { status, invalid } = match2;\n      loaderShouldRunAsync = status === \"success\" && (invalid || (shouldReload ?? age > staleAge));\n      if (preload && route.options.preload === false) ;\n      else if (loaderShouldRunAsync && !inner.sync) {\n        loaderIsRunningAsync = true;\n        (async () => {\n          try {\n            await runLoader(inner, matchId, index, route);\n            const match3 = inner.router.getMatch(matchId);\n            match3._nonReactive.loaderPromise?.resolve();\n            match3._nonReactive.loadPromise?.resolve();\n            match3._nonReactive.loaderPromise = void 0;\n          } catch (err) {\n            if (isRedirect(err)) {\n              await inner.router.navigate(err.options);\n            }\n          }\n        })();\n      } else if (status !== \"success\" || loaderShouldRunAsync && inner.sync) {\n        await runLoader(inner, matchId, index, route);\n      }\n    }\n  }\n  const match = inner.router.getMatch(matchId);\n  if (!loaderIsRunningAsync) {\n    match._nonReactive.loaderPromise?.resolve();\n    match._nonReactive.loadPromise?.resolve();\n  }\n  clearTimeout(match._nonReactive.pendingTimeout);\n  match._nonReactive.pendingTimeout = void 0;\n  if (!loaderIsRunningAsync) match._nonReactive.loaderPromise = void 0;\n  match._nonReactive.dehydrated = void 0;\n  const nextIsFetching = loaderIsRunningAsync ? match.isFetching : false;\n  if (nextIsFetching !== match.isFetching || match.invalid !== false) {\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: nextIsFetching,\n      invalid: false\n    }));\n    return inner.router.getMatch(matchId);\n  } else {\n    return match;\n  }\n};\nasync function loadMatches(arg) {\n  const inner = Object.assign(arg, {\n    matchPromises: []\n  });\n  if (!inner.router.isServer && inner.router.state.matches.some((d) => d._forcePending)) {\n    triggerOnReady(inner);\n  }\n  try {\n    for (let i = 0; i < inner.matches.length; i++) {\n      const beforeLoad = handleBeforeLoad(inner, i);\n      if (isPromise(beforeLoad)) await beforeLoad;\n    }\n    const max = inner.firstBadMatchIndex ?? inner.matches.length;\n    for (let i = 0; i < max; i++) {\n      inner.matchPromises.push(loadRouteMatch(inner, i));\n    }\n    const results = await Promise.allSettled(inner.matchPromises);\n    const failures = results.filter(\n      (result) => result.status === \"rejected\"\n    ).map((result) => result.reason);\n    let firstNotFound;\n    for (const err of failures) {\n      if (isRedirect(err)) {\n        throw err;\n      }\n      if (!firstNotFound && isNotFound(err)) {\n        firstNotFound = err;\n      }\n    }\n    for (const match of inner.matches) {\n      const { id: matchId, routeId } = match;\n      const route = inner.router.looseRoutesById[routeId];\n      try {\n        const headResult = executeHead(inner, matchId, route);\n        if (headResult) {\n          const head = await headResult;\n          inner.updateMatch(matchId, (prev) => ({\n            ...prev,\n            ...head\n          }));\n        }\n      } catch (err) {\n        console.error(`Error executing head for route ${routeId}:`, err);\n      }\n    }\n    if (firstNotFound) {\n      throw firstNotFound;\n    }\n    const readyPromise = triggerOnReady(inner);\n    if (isPromise(readyPromise)) await readyPromise;\n  } catch (err) {\n    if (isNotFound(err) && !inner.preload) {\n      const readyPromise = triggerOnReady(inner);\n      if (isPromise(readyPromise)) await readyPromise;\n      throw err;\n    }\n    if (isRedirect(err)) {\n      throw err;\n    }\n  }\n  return inner.matches;\n}\nasync function loadRouteChunk(route) {\n  if (!route._lazyLoaded && route._lazyPromise === void 0) {\n    if (route.lazyFn) {\n      route._lazyPromise = route.lazyFn().then((lazyRoute) => {\n        const { id: _id, ...options } = lazyRoute.options;\n        Object.assign(route.options, options);\n        route._lazyLoaded = true;\n        route._lazyPromise = void 0;\n      });\n    } else {\n      route._lazyLoaded = true;\n    }\n  }\n  if (!route._componentsLoaded && route._componentsPromise === void 0) {\n    const loadComponents = () => {\n      const preloads = [];\n      for (const type of componentTypes) {\n        const preload = route.options[type]?.preload;\n        if (preload) preloads.push(preload());\n      }\n      if (preloads.length)\n        return Promise.all(preloads).then(() => {\n          route._componentsLoaded = true;\n          route._componentsPromise = void 0;\n        });\n      route._componentsLoaded = true;\n      route._componentsPromise = void 0;\n      return;\n    };\n    route._componentsPromise = route._lazyPromise ? route._lazyPromise.then(loadComponents) : loadComponents();\n  }\n  return route._componentsPromise;\n}\nfunction makeMaybe(value, error) {\n  if (error) {\n    return { status: \"error\", error };\n  }\n  return { status: \"success\", value };\n}\nfunction routeNeedsPreload(route) {\n  for (const componentType of componentTypes) {\n    if (route.options[componentType]?.preload) {\n      return true;\n    }\n  }\n  return false;\n}\nconst componentTypes = [\n  \"component\",\n  \"errorComponent\",\n  \"pendingComponent\",\n  \"notFoundComponent\"\n];\nexport {\n  componentTypes,\n  loadMatches,\n  loadRouteChunk,\n  routeNeedsPreload\n};\n//# sourceMappingURL=load-matches.js.map\n","import { trimPath, joinPaths } from \"./path.js\";\nfunction composeRewrites(rewrites) {\n  return {\n    input: ({ url }) => {\n      for (const rewrite of rewrites) {\n        url = executeRewriteInput(rewrite, url);\n      }\n      return url;\n    },\n    output: ({ url }) => {\n      for (let i = rewrites.length - 1; i >= 0; i--) {\n        url = executeRewriteOutput(rewrites[i], url);\n      }\n      return url;\n    }\n  };\n}\nfunction rewriteBasepath(opts) {\n  const trimmedBasepath = trimPath(opts.basepath);\n  const normalizedBasepath = `/${trimmedBasepath}`;\n  const normalizedBasepathWithSlash = `${normalizedBasepath}/`;\n  const checkBasepath = opts.caseSensitive ? normalizedBasepath : normalizedBasepath.toLowerCase();\n  const checkBasepathWithSlash = opts.caseSensitive ? normalizedBasepathWithSlash : normalizedBasepathWithSlash.toLowerCase();\n  return {\n    input: ({ url }) => {\n      const pathname = opts.caseSensitive ? url.pathname : url.pathname.toLowerCase();\n      if (pathname === checkBasepath) {\n        url.pathname = \"/\";\n      } else if (pathname.startsWith(checkBasepathWithSlash)) {\n        url.pathname = url.pathname.slice(normalizedBasepath.length);\n      }\n      return url;\n    },\n    output: ({ url }) => {\n      url.pathname = joinPaths([\"/\", trimmedBasepath, url.pathname]);\n      return url;\n    }\n  };\n}\nfunction executeRewriteInput(rewrite, url) {\n  const res = rewrite?.input?.({ url });\n  if (res) {\n    if (typeof res === \"string\") {\n      return new URL(res);\n    } else if (res instanceof URL) {\n      return res;\n    }\n  }\n  return url;\n}\nfunction executeRewriteOutput(rewrite, url) {\n  const res = rewrite?.output?.({ url });\n  if (res) {\n    if (typeof res === \"string\") {\n      return new URL(res);\n    } else if (res instanceof URL) {\n      return res;\n    }\n  }\n  return url;\n}\nexport {\n  composeRewrites,\n  executeRewriteInput,\n  executeRewriteOutput,\n  rewriteBasepath\n};\n//# sourceMappingURL=rewrite.js.map\n","import { Store, batch } from \"@tanstack/store\";\nimport { createBrowserHistory, parseHref } from \"@tanstack/history\";\nimport { createControlledPromise, isDangerousProtocol, deepEqual, replaceEqualDeep, decodePath, functionalUpdate, last, findLast } from \"./utils.js\";\nimport { processRouteTree, processRouteMasks, findSingleMatch, findRouteMatch, findFlatMatch } from \"./new-process-route-tree.js\";\nimport { trimPath, resolvePath, cleanPath, trimPathRight, interpolatePath } from \"./path.js\";\nimport { createLRUCache } from \"./lru-cache.js\";\nimport { isNotFound } from \"./not-found.js\";\nimport { setupScrollRestoration } from \"./scroll-restoration.js\";\nimport { defaultParseSearch, defaultStringifySearch } from \"./searchParams.js\";\nimport { rootRouteId } from \"./root.js\";\nimport { redirect, isRedirect } from \"./redirect.js\";\nimport { loadMatches, loadRouteChunk, routeNeedsPreload } from \"./load-matches.js\";\nimport { rewriteBasepath, composeRewrites, executeRewriteInput, executeRewriteOutput } from \"./rewrite.js\";\nfunction defaultSerializeError(err) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message\n    };\n    if (process.env.NODE_ENV === \"development\") {\n      obj.stack = err.stack;\n    }\n    return obj;\n  }\n  return {\n    data: err\n  };\n}\nconst trailingSlashOptions = {\n  always: \"always\",\n  never: \"never\",\n  preserve: \"preserve\"\n};\nfunction getLocationChangeInfo(routerState) {\n  const fromLocation = routerState.resolvedLocation;\n  const toLocation = routerState.location;\n  const pathChanged = fromLocation?.pathname !== toLocation.pathname;\n  const hrefChanged = fromLocation?.href !== toLocation.href;\n  const hashChanged = fromLocation?.hash !== toLocation.hash;\n  return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged };\n}\nclass RouterCore {\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(options) {\n    this.tempLocationKey = `${Math.round(\n      Math.random() * 1e7\n    )}`;\n    this.shouldViewTransition = void 0;\n    this.isViewTransitionTypesSupported = void 0;\n    this.subscribers = /* @__PURE__ */ new Set();\n    this.isScrollRestoring = false;\n    this.isScrollRestorationSetup = false;\n    this.startTransition = (fn) => fn();\n    this.update = (newOptions) => {\n      if (newOptions.notFoundRoute) {\n        console.warn(\n          \"The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info.\"\n        );\n      }\n      const prevOptions = this.options;\n      const prevBasepath = this.basepath ?? prevOptions?.basepath ?? \"/\";\n      const basepathWasUnset = this.basepath === void 0;\n      const prevRewriteOption = prevOptions?.rewrite;\n      this.options = {\n        ...prevOptions,\n        ...newOptions\n      };\n      this.isServer = this.options.isServer ?? typeof document === \"undefined\";\n      this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters ? new Map(\n        this.options.pathParamsAllowedCharacters.map((char) => [\n          encodeURIComponent(char),\n          char\n        ])\n      ) : void 0;\n      if (!this.history || this.options.history && this.options.history !== this.history) {\n        if (!this.options.history) {\n          if (!this.isServer) {\n            this.history = createBrowserHistory();\n          }\n        } else {\n          this.history = this.options.history;\n        }\n      }\n      this.origin = this.options.origin;\n      if (!this.origin) {\n        if (!this.isServer && window?.origin && window.origin !== \"null\") {\n          this.origin = window.origin;\n        } else {\n          this.origin = \"http://localhost\";\n        }\n      }\n      if (this.history) {\n        this.updateLatestLocation();\n      }\n      if (this.options.routeTree !== this.routeTree) {\n        this.routeTree = this.options.routeTree;\n        this.buildRouteTree();\n      }\n      if (!this.__store && this.latestLocation) {\n        this.__store = new Store(getInitialRouterState(this.latestLocation), {\n          onUpdate: () => {\n            this.__store.state = {\n              ...this.state,\n              cachedMatches: this.state.cachedMatches.filter(\n                (d) => ![\"redirected\"].includes(d.status)\n              )\n            };\n          }\n        });\n        setupScrollRestoration(this);\n      }\n      let needsLocationUpdate = false;\n      const nextBasepath = this.options.basepath ?? \"/\";\n      const nextRewriteOption = this.options.rewrite;\n      const basepathChanged = basepathWasUnset || prevBasepath !== nextBasepath;\n      const rewriteChanged = prevRewriteOption !== nextRewriteOption;\n      if (basepathChanged || rewriteChanged) {\n        this.basepath = nextBasepath;\n        const rewrites = [];\n        if (trimPath(nextBasepath) !== \"\") {\n          rewrites.push(\n            rewriteBasepath({\n              basepath: nextBasepath\n            })\n          );\n        }\n        if (nextRewriteOption) {\n          rewrites.push(nextRewriteOption);\n        }\n        this.rewrite = rewrites.length === 0 ? void 0 : rewrites.length === 1 ? rewrites[0] : composeRewrites(rewrites);\n        if (this.history) {\n          this.updateLatestLocation();\n        }\n        needsLocationUpdate = true;\n      }\n      if (needsLocationUpdate && this.__store) {\n        this.__store.state = {\n          ...this.state,\n          location: this.latestLocation\n        };\n      }\n      if (typeof window !== \"undefined\" && \"CSS\" in window && typeof window.CSS?.supports === \"function\") {\n        this.isViewTransitionTypesSupported = window.CSS.supports(\n          \"selector(:active-view-transition-type(a)\"\n        );\n      }\n    };\n    this.updateLatestLocation = () => {\n      this.latestLocation = this.parseLocation(\n        this.history.location,\n        this.latestLocation\n      );\n    };\n    this.buildRouteTree = () => {\n      const { routesById, routesByPath, processedTree } = processRouteTree(\n        this.routeTree,\n        this.options.caseSensitive,\n        (route, i) => {\n          route.init({\n            originalIndex: i\n          });\n        }\n      );\n      if (this.options.routeMasks) {\n        processRouteMasks(this.options.routeMasks, processedTree);\n      }\n      this.routesById = routesById;\n      this.routesByPath = routesByPath;\n      this.processedTree = processedTree;\n      const notFoundRoute = this.options.notFoundRoute;\n      if (notFoundRoute) {\n        notFoundRoute.init({\n          originalIndex: 99999999999\n        });\n        this.routesById[notFoundRoute.id] = notFoundRoute;\n      }\n    };\n    this.subscribe = (eventType, fn) => {\n      const listener = {\n        eventType,\n        fn\n      };\n      this.subscribers.add(listener);\n      return () => {\n        this.subscribers.delete(listener);\n      };\n    };\n    this.emit = (routerEvent) => {\n      this.subscribers.forEach((listener) => {\n        if (listener.eventType === routerEvent.type) {\n          listener.fn(routerEvent);\n        }\n      });\n    };\n    this.parseLocation = (locationToParse, previousLocation) => {\n      const parse = ({\n        href,\n        state\n      }) => {\n        const fullUrl = new URL(href, this.origin);\n        const url = executeRewriteInput(this.rewrite, fullUrl);\n        const parsedSearch = this.options.parseSearch(url.search);\n        const searchStr = this.options.stringifySearch(parsedSearch);\n        url.search = searchStr;\n        const fullPath = url.href.replace(url.origin, \"\");\n        return {\n          href: fullPath,\n          publicHref: href,\n          url,\n          pathname: decodePath(url.pathname),\n          searchStr,\n          search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n          hash: decodePath(url.hash.split(\"#\").reverse()[0] ?? \"\"),\n          state: replaceEqualDeep(previousLocation?.state, state)\n        };\n      };\n      const location = parse(locationToParse);\n      const { __tempLocation, __tempKey } = location.state;\n      if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n        const parsedTempLocation = parse(__tempLocation);\n        parsedTempLocation.state.key = location.state.key;\n        parsedTempLocation.state.__TSR_key = location.state.__TSR_key;\n        delete parsedTempLocation.state.__tempLocation;\n        return {\n          ...parsedTempLocation,\n          maskedLocation: location\n        };\n      }\n      return location;\n    };\n    this.resolvePathCache = createLRUCache(1e3);\n    this.resolvePathWithBase = (from, path) => {\n      const resolvedPath = resolvePath({\n        base: from,\n        to: cleanPath(path),\n        trailingSlash: this.options.trailingSlash,\n        cache: this.resolvePathCache\n      });\n      return resolvedPath;\n    };\n    this.matchRoutes = (pathnameOrNext, locationSearchOrOpts, opts) => {\n      if (typeof pathnameOrNext === \"string\") {\n        return this.matchRoutesInternal(\n          {\n            pathname: pathnameOrNext,\n            search: locationSearchOrOpts\n          },\n          opts\n        ).matches;\n      }\n      return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts).matches;\n    };\n    this.getMatchedRoutes = (pathname) => {\n      return getMatchedRoutes({\n        pathname,\n        routesById: this.routesById,\n        processedTree: this.processedTree\n      });\n    };\n    this.cancelMatch = (id) => {\n      const match = this.getMatch(id);\n      if (!match) return;\n      match.abortController.abort();\n      clearTimeout(match._nonReactive.pendingTimeout);\n      match._nonReactive.pendingTimeout = void 0;\n    };\n    this.cancelMatches = () => {\n      const currentPendingMatches = this.state.matches.filter(\n        (match) => match.status === \"pending\"\n      );\n      const currentLoadingMatches = this.state.matches.filter(\n        (match) => match.isFetching === \"loader\"\n      );\n      const matchesToCancelArray = /* @__PURE__ */ new Set([\n        ...this.state.pendingMatches ?? [],\n        ...currentPendingMatches,\n        ...currentLoadingMatches\n      ]);\n      matchesToCancelArray.forEach((match) => {\n        this.cancelMatch(match.id);\n      });\n    };\n    this.buildLocation = (opts) => {\n      const build = (dest = {}) => {\n        const currentLocation = dest._fromLocation || this.pendingBuiltLocation || this.latestLocation;\n        const allCurrentLocationMatches = this.matchRoutes(currentLocation, {\n          _buildLocation: true\n        });\n        const lastMatch = last(allCurrentLocationMatches);\n        if (dest.from && process.env.NODE_ENV !== \"production\" && dest._isNavigate) {\n          const allFromMatches = this.getMatchedRoutes(dest.from).matchedRoutes;\n          const matchedFrom = findLast(allCurrentLocationMatches, (d) => {\n            return comparePaths(d.fullPath, dest.from);\n          });\n          const matchedCurrent = findLast(allFromMatches, (d) => {\n            return comparePaths(d.fullPath, lastMatch.fullPath);\n          });\n          if (!matchedFrom && !matchedCurrent) {\n            console.warn(`Could not find match for from: ${dest.from}`);\n          }\n        }\n        const defaultedFromPath = dest.unsafeRelative === \"path\" ? currentLocation.pathname : dest.from ?? lastMatch.fullPath;\n        const fromPath = this.resolvePathWithBase(defaultedFromPath, \".\");\n        const fromSearch = lastMatch.search;\n        const fromParams = { ...lastMatch.params };\n        const nextTo = dest.to ? this.resolvePathWithBase(fromPath, `${dest.to}`) : this.resolvePathWithBase(fromPath, \".\");\n        const nextParams = dest.params === false || dest.params === null ? {} : (dest.params ?? true) === true ? fromParams : Object.assign(\n          fromParams,\n          functionalUpdate(dest.params, fromParams)\n        );\n        const interpolatedNextTo = interpolatePath({\n          path: nextTo,\n          params: nextParams\n        }).interpolatedPath;\n        const destMatchResult = this.getMatchedRoutes(interpolatedNextTo);\n        let destRoutes = destMatchResult.matchedRoutes;\n        const rawParams = destMatchResult.routeParams;\n        const isGlobalNotFound = destMatchResult.foundRoute ? destMatchResult.foundRoute.path !== \"/\" && destMatchResult.routeParams[\"**\"] : trimPathRight(interpolatedNextTo);\n        let globalNotFoundRouteId;\n        if (isGlobalNotFound) {\n          if (this.options.notFoundRoute) {\n            destRoutes = [...destRoutes, this.options.notFoundRoute];\n          } else {\n            globalNotFoundRouteId = findGlobalNotFoundRouteId(\n              this.options.notFoundMode,\n              destRoutes\n            );\n          }\n        }\n        if (Object.keys(nextParams).length > 0) {\n          for (const route of destRoutes) {\n            const fn = route.options.params?.stringify ?? route.options.stringifyParams;\n            if (fn) {\n              Object.assign(nextParams, fn(nextParams));\n            }\n          }\n        }\n        const nextPathname = opts.leaveParams ? (\n          // Use the original template path for interpolation\n          // This preserves the original parameter syntax including optional parameters\n          nextTo\n        ) : decodePath(\n          interpolatePath({\n            path: nextTo,\n            params: nextParams,\n            decodeCharMap: this.pathParamsDecodeCharMap\n          }).interpolatedPath\n        );\n        let nextSearch = fromSearch;\n        if (opts._includeValidateSearch && this.options.search?.strict) {\n          const validatedSearch = {};\n          destRoutes.forEach((route) => {\n            if (route.options.validateSearch) {\n              try {\n                Object.assign(\n                  validatedSearch,\n                  validateSearch(route.options.validateSearch, {\n                    ...validatedSearch,\n                    ...nextSearch\n                  })\n                );\n              } catch {\n              }\n            }\n          });\n          nextSearch = validatedSearch;\n        }\n        nextSearch = applySearchMiddleware({\n          search: nextSearch,\n          dest,\n          destRoutes,\n          _includeValidateSearch: opts._includeValidateSearch\n        });\n        nextSearch = replaceEqualDeep(fromSearch, nextSearch);\n        const searchStr = this.options.stringifySearch(nextSearch);\n        const hash = dest.hash === true ? currentLocation.hash : dest.hash ? functionalUpdate(dest.hash, currentLocation.hash) : void 0;\n        const hashStr = hash ? `#${hash}` : \"\";\n        let nextState = dest.state === true ? currentLocation.state : dest.state ? functionalUpdate(dest.state, currentLocation.state) : {};\n        nextState = replaceEqualDeep(currentLocation.state, nextState);\n        const snapshotParams = {\n          ...rawParams,\n          ...nextParams\n        };\n        const matchSnapshot = buildMatchSnapshotFromRoutes({\n          routes: destRoutes,\n          params: snapshotParams,\n          searchStr,\n          globalNotFoundRouteId\n        });\n        const fullPath = `${nextPathname}${searchStr}${hashStr}`;\n        const url = new URL(fullPath, this.origin);\n        const rewrittenUrl = executeRewriteOutput(this.rewrite, url);\n        const encodedHref = url.href.replace(url.origin, \"\");\n        return {\n          publicHref: rewrittenUrl.pathname + rewrittenUrl.search + rewrittenUrl.hash,\n          href: encodedHref,\n          url: rewrittenUrl,\n          pathname: nextPathname,\n          search: nextSearch,\n          searchStr,\n          state: nextState,\n          hash: hash ?? \"\",\n          unmaskOnReload: dest.unmaskOnReload,\n          _matchSnapshot: matchSnapshot\n        };\n      };\n      const buildWithMatches = (dest = {}, maskedDest) => {\n        const next = build(dest);\n        let maskedNext = maskedDest ? build(maskedDest) : void 0;\n        if (!maskedNext) {\n          const params = {};\n          if (this.options.routeMasks) {\n            const match = findFlatMatch(\n              next.pathname,\n              this.processedTree\n            );\n            if (match) {\n              Object.assign(params, match.rawParams);\n              const {\n                from: _from,\n                params: maskParams,\n                ...maskProps\n              } = match.route;\n              const nextParams = maskParams === false || maskParams === null ? {} : (maskParams ?? true) === true ? params : Object.assign(params, functionalUpdate(maskParams, params));\n              maskedDest = {\n                from: opts.from,\n                ...maskProps,\n                params: nextParams\n              };\n              maskedNext = build(maskedDest);\n            }\n          }\n        }\n        if (maskedNext) {\n          next.maskedLocation = maskedNext;\n        }\n        return next;\n      };\n      if (opts.mask) {\n        return buildWithMatches(opts, {\n          from: opts.from,\n          ...opts.mask\n        });\n      }\n      return buildWithMatches(opts);\n    };\n    this.commitLocation = async ({\n      viewTransition,\n      ignoreBlocker,\n      ...next\n    }) => {\n      const isSameState = () => {\n        const ignoredProps = [\n          \"key\",\n          // TODO: Remove in v2 - use __TSR_key instead\n          \"__TSR_key\",\n          \"__TSR_index\",\n          \"__hashScrollIntoViewOptions\"\n        ];\n        ignoredProps.forEach((prop) => {\n          next.state[prop] = this.latestLocation.state[prop];\n        });\n        const isEqual = deepEqual(next.state, this.latestLocation.state);\n        ignoredProps.forEach((prop) => {\n          delete next.state[prop];\n        });\n        return isEqual;\n      };\n      const isSameUrl = trimPathRight(this.latestLocation.href) === trimPathRight(next.href);\n      const previousCommitPromise = this.commitLocationPromise;\n      this.commitLocationPromise = createControlledPromise(() => {\n        previousCommitPromise?.resolve();\n      });\n      if (isSameUrl && isSameState()) {\n        this.load();\n        return this.commitLocationPromise;\n      }\n      let {\n        // eslint-disable-next-line prefer-const\n        maskedLocation,\n        // eslint-disable-next-line prefer-const\n        hashScrollIntoView,\n        // don't pass url into history since it is a URL instance that cannot be serialized\n        // eslint-disable-next-line prefer-const\n        url: _url,\n        ...nextHistory\n      } = next;\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: void 0,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: void 0,\n                __tempLocation: void 0,\n                __TSR_key: void 0,\n                key: void 0\n                // TODO: Remove in v2 - use __TSR_key instead\n              }\n            }\n          }\n        };\n        if (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? false) {\n          nextHistory.state.__tempKey = this.tempLocationKey;\n        }\n      }\n      nextHistory.state.__hashScrollIntoViewOptions = hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? true;\n      nextHistory.state.__TSR_resetScroll = next.resetScroll ?? true;\n      this.shouldViewTransition = viewTransition;\n      nextHistory.state.__TSR_sessionId = this.sessionId;\n      nextHistory.state.__TSR_matches = next._matchSnapshot ?? buildMatchSnapshot({\n        matchResult: this.getMatchedRoutes(next.pathname),\n        pathname: next.pathname,\n        searchStr: next.searchStr,\n        notFoundRoute: this.options.notFoundRoute,\n        notFoundMode: this.options.notFoundMode\n      });\n      const precomputedLocation = {\n        ...next,\n        publicHref: nextHistory.publicHref,\n        state: nextHistory.state,\n        maskedLocation\n      };\n      const result = await this.history[next.replace ? \"replace\" : \"push\"](\n        nextHistory.publicHref,\n        nextHistory.state,\n        { ignoreBlocker, skipTransitionerLoad: true }\n      );\n      if (result.type === \"BLOCKED\") {\n        this.commitLocationPromise?.resolve();\n        return this.commitLocationPromise;\n      }\n      if (this.history.location.href !== nextHistory.publicHref) {\n        return this.commitLocationPromise;\n      }\n      this.latestLocation = precomputedLocation;\n      this.load({ _skipUpdateLatestLocation: true });\n      return this.commitLocationPromise;\n    };\n    this.buildAndCommitLocation = ({\n      replace,\n      resetScroll,\n      hashScrollIntoView,\n      viewTransition,\n      ignoreBlocker,\n      href,\n      ...rest\n    } = {}) => {\n      if (href) {\n        const currentIndex = this.history.location.state.__TSR_index;\n        const parsed = parseHref(href, {\n          __TSR_index: replace ? currentIndex : currentIndex + 1\n        });\n        const hrefUrl = new URL(parsed.pathname, this.origin);\n        const rewrittenUrl = executeRewriteInput(this.rewrite, hrefUrl);\n        rest.to = rewrittenUrl.pathname;\n        rest.search = this.options.parseSearch(parsed.search);\n        rest.hash = parsed.hash.slice(1);\n      }\n      const location = this.buildLocation({\n        ...rest,\n        _includeValidateSearch: true\n      });\n      this.pendingBuiltLocation = location;\n      const commitPromise = this.commitLocation({\n        ...location,\n        viewTransition,\n        replace,\n        resetScroll,\n        hashScrollIntoView,\n        ignoreBlocker\n      });\n      Promise.resolve().then(() => {\n        if (this.pendingBuiltLocation === location) {\n          this.pendingBuiltLocation = void 0;\n        }\n      });\n      return commitPromise;\n    };\n    this.navigate = async ({\n      to,\n      reloadDocument,\n      href,\n      publicHref,\n      ...rest\n    }) => {\n      let hrefIsUrl = false;\n      if (href) {\n        try {\n          new URL(`${href}`);\n          hrefIsUrl = true;\n        } catch {\n        }\n      }\n      if (hrefIsUrl && !reloadDocument) {\n        reloadDocument = true;\n      }\n      if (reloadDocument) {\n        if (to !== void 0 || !href) {\n          const location = this.buildLocation({ to, ...rest });\n          href = href ?? location.url.href;\n          publicHref = publicHref ?? location.url.href;\n        }\n        const reloadHref = !hrefIsUrl && publicHref ? publicHref : href;\n        if (isDangerousProtocol(reloadHref)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.warn(\n              `Blocked navigation to dangerous protocol: ${reloadHref}`\n            );\n          }\n          return Promise.resolve();\n        }\n        if (!rest.ignoreBlocker) {\n          const historyWithBlockers = this.history;\n          const blockers = historyWithBlockers.getBlockers?.() ?? [];\n          for (const blocker of blockers) {\n            if (blocker?.blockerFn) {\n              const shouldBlock = await blocker.blockerFn({\n                currentLocation: this.latestLocation,\n                nextLocation: this.latestLocation,\n                // External URLs don't have a next location in our router\n                action: \"PUSH\"\n              });\n              if (shouldBlock) {\n                return Promise.resolve();\n              }\n            }\n          }\n        }\n        if (rest.replace) {\n          window.location.replace(reloadHref);\n        } else {\n          window.location.href = reloadHref;\n        }\n        return Promise.resolve();\n      }\n      return this.buildAndCommitLocation({\n        ...rest,\n        href,\n        to,\n        _isNavigate: true\n      });\n    };\n    this.beforeLoad = (opts) => {\n      this.cancelMatches();\n      if (!opts?._skipUpdateLatestLocation) {\n        this.updateLatestLocation();\n      }\n      if (this.isServer) {\n        const nextLocation = this.buildLocation({\n          to: this.latestLocation.pathname,\n          search: true,\n          params: true,\n          hash: true,\n          state: true,\n          _includeValidateSearch: true\n        });\n        if (this.latestLocation.publicHref !== nextLocation.publicHref || nextLocation.url.origin !== this.origin) {\n          const href = this.getParsedLocationHref(nextLocation);\n          throw redirect({ href });\n        }\n      }\n      const snapshot = this.latestLocation.state.__TSR_sessionId === this.sessionId ? this.latestLocation.state.__TSR_matches : void 0;\n      const pendingMatches = this.matchRoutes(this.latestLocation, { snapshot });\n      this.__store.setState((s) => ({\n        ...s,\n        status: \"pending\",\n        statusCode: 200,\n        isLoading: true,\n        location: this.latestLocation,\n        pendingMatches,\n        // If a cached moved to pendingMatches, remove it from cachedMatches\n        cachedMatches: s.cachedMatches.filter(\n          (d) => !pendingMatches.some((e) => e.id === d.id)\n        )\n      }));\n    };\n    this.load = async (opts) => {\n      let redirect2;\n      let notFound;\n      let loadPromise;\n      loadPromise = new Promise((resolve) => {\n        this.startTransition(async () => {\n          try {\n            this.beforeLoad({\n              _skipUpdateLatestLocation: opts?._skipUpdateLatestLocation\n            });\n            const next = this.latestLocation;\n            const prevLocation = this.state.resolvedLocation;\n            if (!this.state.redirect) {\n              this.emit({\n                type: \"onBeforeNavigate\",\n                ...getLocationChangeInfo({\n                  resolvedLocation: prevLocation,\n                  location: next\n                })\n              });\n            }\n            this.emit({\n              type: \"onBeforeLoad\",\n              ...getLocationChangeInfo({\n                resolvedLocation: prevLocation,\n                location: next\n              })\n            });\n            await loadMatches({\n              router: this,\n              sync: opts?.sync,\n              matches: this.state.pendingMatches,\n              location: next,\n              updateMatch: this.updateMatch,\n              // eslint-disable-next-line @typescript-eslint/require-await\n              onReady: async () => {\n                this.startTransition(() => {\n                  this.startViewTransition(async () => {\n                    let exitingMatches = [];\n                    let enteringMatches = [];\n                    let stayingMatches = [];\n                    batch(() => {\n                      this.__store.setState((s) => {\n                        const previousMatches = s.matches;\n                        const newMatches = s.pendingMatches || s.matches;\n                        exitingMatches = previousMatches.filter(\n                          (match) => !newMatches.some((d) => d.id === match.id)\n                        );\n                        enteringMatches = newMatches.filter(\n                          (match) => !previousMatches.some((d) => d.id === match.id)\n                        );\n                        stayingMatches = newMatches.filter(\n                          (match) => previousMatches.some((d) => d.id === match.id)\n                        );\n                        return {\n                          ...s,\n                          isLoading: false,\n                          loadedAt: Date.now(),\n                          matches: newMatches,\n                          pendingMatches: void 0,\n                          /**\n                           * When committing new matches, cache any exiting matches that are still usable.\n                           * Routes that resolved with `status: 'error'` or `status: 'notFound'` are\n                           * deliberately excluded from `cachedMatches` so that subsequent invalidations\n                           * or reloads re-run their loaders instead of reusing the failed/not-found data.\n                           */\n                          cachedMatches: [\n                            ...s.cachedMatches,\n                            ...exitingMatches.filter(\n                              (d) => d.status !== \"error\" && d.status !== \"notFound\"\n                            )\n                          ]\n                        };\n                      });\n                      this.clearExpiredCache();\n                    });\n                    [\n                      [exitingMatches, \"onLeave\"],\n                      [enteringMatches, \"onEnter\"],\n                      [stayingMatches, \"onStay\"]\n                    ].forEach(([matches, hook]) => {\n                      matches.forEach((match) => {\n                        this.looseRoutesById[match.routeId].options[hook]?.(\n                          match\n                        );\n                      });\n                    });\n                  });\n                });\n              }\n            });\n          } catch (err) {\n            if (isRedirect(err)) {\n              redirect2 = err;\n              if (!this.isServer) {\n                this.navigate({\n                  ...redirect2.options,\n                  replace: true,\n                  ignoreBlocker: true\n                });\n              }\n            } else if (isNotFound(err)) {\n              notFound = err;\n            }\n            this.__store.setState((s) => ({\n              ...s,\n              statusCode: redirect2 ? redirect2.status : notFound ? 404 : s.matches.some((d) => d.status === \"error\") ? 500 : 200,\n              redirect: redirect2\n            }));\n          }\n          if (this.latestLoadPromise === loadPromise) {\n            this.commitLocationPromise?.resolve();\n            this.latestLoadPromise = void 0;\n            this.commitLocationPromise = void 0;\n          }\n          resolve();\n        });\n      });\n      this.latestLoadPromise = loadPromise;\n      await loadPromise;\n      while (this.latestLoadPromise && loadPromise !== this.latestLoadPromise) {\n        await this.latestLoadPromise;\n      }\n      let newStatusCode = void 0;\n      if (this.hasNotFoundMatch()) {\n        newStatusCode = 404;\n      } else if (this.__store.state.matches.some((d) => d.status === \"error\")) {\n        newStatusCode = 500;\n      }\n      if (newStatusCode !== void 0) {\n        this.__store.setState((s) => ({\n          ...s,\n          statusCode: newStatusCode\n        }));\n      }\n    };\n    this.startViewTransition = (fn) => {\n      const shouldViewTransition = this.shouldViewTransition ?? this.options.defaultViewTransition;\n      delete this.shouldViewTransition;\n      if (shouldViewTransition && typeof document !== \"undefined\" && \"startViewTransition\" in document && typeof document.startViewTransition === \"function\") {\n        let startViewTransitionParams;\n        if (typeof shouldViewTransition === \"object\" && this.isViewTransitionTypesSupported) {\n          const next = this.latestLocation;\n          const prevLocation = this.state.resolvedLocation;\n          const resolvedViewTransitionTypes = typeof shouldViewTransition.types === \"function\" ? shouldViewTransition.types(\n            getLocationChangeInfo({\n              resolvedLocation: prevLocation,\n              location: next\n            })\n          ) : shouldViewTransition.types;\n          if (resolvedViewTransitionTypes === false) {\n            fn();\n            return;\n          }\n          startViewTransitionParams = {\n            update: fn,\n            types: resolvedViewTransitionTypes\n          };\n        } else {\n          startViewTransitionParams = fn;\n        }\n        document.startViewTransition(startViewTransitionParams);\n      } else {\n        fn();\n      }\n    };\n    this.updateMatch = (id, updater) => {\n      this.startTransition(() => {\n        const matchesKey = this.state.pendingMatches?.some((d) => d.id === id) ? \"pendingMatches\" : this.state.matches.some((d) => d.id === id) ? \"matches\" : this.state.cachedMatches.some((d) => d.id === id) ? \"cachedMatches\" : \"\";\n        if (matchesKey) {\n          this.__store.setState((s) => ({\n            ...s,\n            [matchesKey]: s[matchesKey]?.map(\n              (d) => d.id === id ? updater(d) : d\n            )\n          }));\n        }\n      });\n    };\n    this.getMatch = (matchId) => {\n      const findFn = (d) => d.id === matchId;\n      return this.state.cachedMatches.find(findFn) ?? this.state.pendingMatches?.find(findFn) ?? this.state.matches.find(findFn);\n    };\n    this.invalidate = (opts) => {\n      const invalidate = (d) => {\n        if (opts?.filter?.(d) ?? true) {\n          return {\n            ...d,\n            invalid: true,\n            ...opts?.forcePending || d.status === \"error\" || d.status === \"notFound\" ? { status: \"pending\", error: void 0 } : void 0\n          };\n        }\n        return d;\n      };\n      this.__store.setState((s) => ({\n        ...s,\n        matches: s.matches.map(invalidate),\n        cachedMatches: s.cachedMatches.map(invalidate),\n        pendingMatches: s.pendingMatches?.map(invalidate)\n      }));\n      this.shouldViewTransition = false;\n      return this.load({ sync: opts?.sync });\n    };\n    this.getParsedLocationHref = (location) => {\n      let href = location.url.href;\n      if (this.origin && location.url.origin === this.origin) {\n        href = href.replace(this.origin, \"\") || \"/\";\n      }\n      return href;\n    };\n    this.resolveRedirect = (redirect2) => {\n      const locationHeader = redirect2.headers.get(\"Location\");\n      if (!redirect2.options.href) {\n        const location = this.buildLocation(redirect2.options);\n        const href = this.getParsedLocationHref(location);\n        redirect2.options.href = href;\n        redirect2.headers.set(\"Location\", href);\n      } else if (locationHeader) {\n        try {\n          const url = new URL(locationHeader);\n          if (this.origin && url.origin === this.origin) {\n            const href = url.pathname + url.search + url.hash;\n            redirect2.options.href = href;\n            redirect2.headers.set(\"Location\", href);\n          }\n        } catch {\n        }\n      }\n      if (!redirect2.headers.get(\"Location\")) {\n        redirect2.headers.set(\"Location\", redirect2.options.href);\n      }\n      return redirect2;\n    };\n    this.clearCache = (opts) => {\n      const filter = opts?.filter;\n      if (filter !== void 0) {\n        this.__store.setState((s) => {\n          return {\n            ...s,\n            cachedMatches: s.cachedMatches.filter(\n              (m) => !filter(m)\n            )\n          };\n        });\n      } else {\n        this.__store.setState((s) => {\n          return {\n            ...s,\n            cachedMatches: []\n          };\n        });\n      }\n    };\n    this.clearExpiredCache = () => {\n      const filter = (d) => {\n        const route = this.looseRoutesById[d.routeId];\n        if (!route.options.loader) {\n          return true;\n        }\n        const gcTime = (d.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1e3;\n        const isError = d.status === \"error\";\n        if (isError) return true;\n        const gcEligible = Date.now() - d.updatedAt >= gcTime;\n        return gcEligible;\n      };\n      this.clearCache({ filter });\n    };\n    this.loadRouteChunk = loadRouteChunk;\n    this.preloadRoute = async (opts) => {\n      const next = this.buildLocation(opts);\n      let matches = this.matchRoutes(next, {\n        throwOnError: true,\n        preload: true,\n        dest: opts\n      });\n      const activeMatchIds = new Set(\n        [...this.state.matches, ...this.state.pendingMatches ?? []].map(\n          (d) => d.id\n        )\n      );\n      const loadedMatchIds = /* @__PURE__ */ new Set([\n        ...activeMatchIds,\n        ...this.state.cachedMatches.map((d) => d.id)\n      ]);\n      batch(() => {\n        matches.forEach((match) => {\n          if (!loadedMatchIds.has(match.id)) {\n            this.__store.setState((s) => ({\n              ...s,\n              cachedMatches: [...s.cachedMatches, match]\n            }));\n          }\n        });\n      });\n      try {\n        matches = await loadMatches({\n          router: this,\n          matches,\n          location: next,\n          preload: true,\n          updateMatch: (id, updater) => {\n            if (activeMatchIds.has(id)) {\n              matches = matches.map((d) => d.id === id ? updater(d) : d);\n            } else {\n              this.updateMatch(id, updater);\n            }\n          }\n        });\n        return matches;\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (err.options.reloadDocument) {\n            return void 0;\n          }\n          return await this.preloadRoute({\n            ...err.options,\n            _fromLocation: next\n          });\n        }\n        if (!isNotFound(err)) {\n          console.error(err);\n        }\n        return void 0;\n      }\n    };\n    this.matchRoute = (location, opts) => {\n      const matchLocation = {\n        ...location,\n        to: location.to ? this.resolvePathWithBase(\n          location.from || \"\",\n          location.to\n        ) : void 0,\n        params: location.params || {},\n        leaveParams: true\n      };\n      const next = this.buildLocation(matchLocation);\n      if (opts?.pending && this.state.status !== \"pending\") {\n        return false;\n      }\n      const pending = opts?.pending === void 0 ? !this.state.isLoading : opts.pending;\n      const baseLocation = pending ? this.latestLocation : this.state.resolvedLocation || this.state.location;\n      const match = findSingleMatch(\n        next.pathname,\n        opts?.caseSensitive ?? false,\n        opts?.fuzzy ?? false,\n        baseLocation.pathname,\n        this.processedTree\n      );\n      if (!match) {\n        return false;\n      }\n      if (location.params) {\n        if (!deepEqual(match.rawParams, location.params, { partial: true })) {\n          return false;\n        }\n      }\n      if (opts?.includeSearch ?? true) {\n        return deepEqual(baseLocation.search, next.search, { partial: true }) ? match.rawParams : false;\n      }\n      return match.rawParams;\n    };\n    this.hasNotFoundMatch = () => {\n      return this.__store.state.matches.some(\n        (d) => d.status === \"notFound\" || d.globalNotFound\n      );\n    };\n    this.sessionId = typeof crypto !== \"undefined\" && \"randomUUID\" in crypto ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(36).slice(2)}`;\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1e3,\n      defaultPendingMinMs: 500,\n      context: void 0,\n      ...options,\n      caseSensitive: options.caseSensitive ?? false,\n      notFoundMode: options.notFoundMode ?? \"fuzzy\",\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch\n    });\n    if (typeof document !== \"undefined\") {\n      self.__TSR_ROUTER__ = this;\n    }\n  }\n  isShell() {\n    return !!this.options.isShell;\n  }\n  isPrerendering() {\n    return !!this.options.isPrerendering;\n  }\n  get state() {\n    return this.__store.state;\n  }\n  get looseRoutesById() {\n    return this.routesById;\n  }\n  matchRoutesInternal(next, opts) {\n    const snapshot = opts?.snapshot;\n    const snapshotValid = snapshot && snapshot.routeIds.length > 0 && snapshot.routeIds.every((id) => this.routesById[id]);\n    let matchedRoutes;\n    let routeParams;\n    let rawParams;\n    let globalNotFoundRouteId;\n    let parsedParams;\n    if (snapshotValid) {\n      matchedRoutes = snapshot.routeIds.map((id) => this.routesById[id]);\n      routeParams = { ...snapshot.params };\n      rawParams = { ...snapshot.params };\n      globalNotFoundRouteId = snapshot.globalNotFoundRouteId;\n      parsedParams = snapshot.parsedParams;\n    } else {\n      const matchedRoutesResult = this.getMatchedRoutes(next.pathname);\n      const { foundRoute, routeParams: rp } = matchedRoutesResult;\n      routeParams = rp;\n      rawParams = { ...rp };\n      matchedRoutes = matchedRoutesResult.matchedRoutes;\n      parsedParams = matchedRoutesResult.parsedParams;\n      let isGlobalNotFound = false;\n      if (\n        // If we found a route, and it's not an index route and we have left over path\n        foundRoute ? foundRoute.path !== \"/\" && routeParams[\"**\"] : (\n          // Or if we didn't find a route and we have left over path\n          trimPathRight(next.pathname)\n        )\n      ) {\n        if (this.options.notFoundRoute) {\n          matchedRoutes = [...matchedRoutes, this.options.notFoundRoute];\n        } else {\n          isGlobalNotFound = true;\n        }\n      }\n      globalNotFoundRouteId = isGlobalNotFound ? findGlobalNotFoundRouteId(this.options.notFoundMode, matchedRoutes) : void 0;\n    }\n    const matches = [];\n    const getParentContext = (parentMatch) => {\n      const parentMatchId = parentMatch?.id;\n      const parentContext = !parentMatchId ? this.options.context ?? void 0 : parentMatch.context ?? this.options.context ?? void 0;\n      return parentContext;\n    };\n    const canUseCachedSearch = snapshotValid && snapshot.searchStr === next.searchStr && snapshot.validatedSearches?.length === matchedRoutes.length;\n    const validatedSearchesToCache = [];\n    matchedRoutes.forEach((route, index) => {\n      const parentMatch = matches[index - 1];\n      const [preMatchSearch, strictMatchSearch, searchError] = (() => {\n        if (canUseCachedSearch) {\n          const cached = snapshot.validatedSearches[index];\n          return [cached.search, cached.strictSearch, void 0];\n        }\n        const parentSearch = parentMatch?.search ?? next.search;\n        const parentStrictSearch = parentMatch?._strictSearch ?? void 0;\n        try {\n          const strictSearch = validateSearch(route.options.validateSearch, { ...parentSearch }) ?? void 0;\n          return [\n            {\n              ...parentSearch,\n              ...strictSearch\n            },\n            { ...parentStrictSearch, ...strictSearch },\n            void 0\n          ];\n        } catch (err) {\n          let searchParamError = err;\n          if (!(err instanceof SearchParamError)) {\n            searchParamError = new SearchParamError(err.message, {\n              cause: err\n            });\n          }\n          if (opts?.throwOnError) {\n            throw searchParamError;\n          }\n          return [parentSearch, {}, searchParamError];\n        }\n      })();\n      if (!canUseCachedSearch) {\n        validatedSearchesToCache.push({\n          search: preMatchSearch,\n          strictSearch: strictMatchSearch\n        });\n      }\n      const loaderDeps = route.options.loaderDeps?.({\n        search: preMatchSearch\n      }) ?? \"\";\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : \"\";\n      const { interpolatedPath, usedParams } = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n        decodeCharMap: this.pathParamsDecodeCharMap\n      });\n      const matchId = (\n        // route.id for disambiguation\n        route.id + // interpolatedPath for param changes\n        interpolatedPath + // explicit deps\n        loaderDepsHash\n      );\n      const existingMatch = this.getMatch(matchId);\n      const previousMatch = this.state.matches.find(\n        (d) => d.routeId === route.id\n      );\n      const strictParams = existingMatch?._strictParams ?? usedParams;\n      let paramsError = void 0;\n      if (!existingMatch) {\n        if (route.options.skipRouteOnParseError) {\n          for (const key in usedParams) {\n            if (key in parsedParams) {\n              strictParams[key] = parsedParams[key];\n            }\n          }\n        } else {\n          const strictParseParams = route.options.params?.parse ?? route.options.parseParams;\n          if (strictParseParams) {\n            try {\n              Object.assign(\n                strictParams,\n                strictParseParams(strictParams)\n              );\n            } catch (err) {\n              if (isNotFound(err) || isRedirect(err)) {\n                paramsError = err;\n              } else {\n                paramsError = new PathParamError(err.message, {\n                  cause: err\n                });\n              }\n              if (opts?.throwOnError) {\n                throw paramsError;\n              }\n            }\n          }\n        }\n      }\n      Object.assign(routeParams, strictParams);\n      const cause = previousMatch ? \"stay\" : \"enter\";\n      let match;\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,\n          _strictParams: strictParams,\n          search: previousMatch ? replaceEqualDeep(previousMatch.search, preMatchSearch) : replaceEqualDeep(existingMatch.search, preMatchSearch),\n          _strictSearch: strictMatchSearch\n        };\n      } else {\n        const status = route.options.loader || route.options.beforeLoad || route.lazyFn || routeNeedsPreload(route) ? \"pending\" : \"success\";\n        match = {\n          id: matchId,\n          ssr: this.isServer ? void 0 : route.options.ssr,\n          index,\n          routeId: route.id,\n          params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,\n          _strictParams: strictParams,\n          pathname: interpolatedPath,\n          updatedAt: Date.now(),\n          search: previousMatch ? replaceEqualDeep(previousMatch.search, preMatchSearch) : preMatchSearch,\n          _strictSearch: strictMatchSearch,\n          searchError: void 0,\n          status,\n          isFetching: false,\n          error: void 0,\n          paramsError,\n          __routeContext: void 0,\n          _nonReactive: {\n            loadPromise: createControlledPromise()\n          },\n          __beforeLoadContext: void 0,\n          context: {},\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps: previousMatch ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps) : loaderDeps,\n          invalid: false,\n          preload: false,\n          links: void 0,\n          scripts: void 0,\n          headScripts: void 0,\n          meta: void 0,\n          staticData: route.options.staticData || {},\n          fullPath: route.fullPath\n        };\n      }\n      if (!opts?.preload) {\n        match.globalNotFound = globalNotFoundRouteId === route.id;\n      }\n      match.searchError = searchError;\n      const parentContext = getParentContext(parentMatch);\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext\n      };\n      matches.push(match);\n    });\n    if (!canUseCachedSearch && validatedSearchesToCache.length > 0) {\n      const existingSnapshot = next.state?.__TSR_matches;\n      if (existingSnapshot) {\n        existingSnapshot.searchStr = next.searchStr;\n        existingSnapshot.validatedSearches = validatedSearchesToCache;\n      }\n    }\n    matches.forEach((match, index) => {\n      const route = this.looseRoutesById[match.routeId];\n      const existingMatch = this.getMatch(match.id);\n      if (!existingMatch && opts?._buildLocation !== true) {\n        const parentMatch = matches[index - 1];\n        const parentContext = getParentContext(parentMatch);\n        if (route.options.context) {\n          const contextFnContext = {\n            deps: match.loaderDeps,\n            params: match.params,\n            context: parentContext ?? {},\n            location: next,\n            navigate: (opts2) => this.navigate({ ...opts2, _fromLocation: next }),\n            buildLocation: this.buildLocation,\n            cause: match.cause,\n            abortController: match.abortController,\n            preload: !!match.preload,\n            matches\n          };\n          match.__routeContext = route.options.context(contextFnContext) ?? void 0;\n        }\n        match.context = {\n          ...parentContext,\n          ...match.__routeContext,\n          ...match.__beforeLoadContext\n        };\n      }\n    });\n    return { matches, rawParams };\n  }\n}\nclass SearchParamError extends Error {\n}\nclass PathParamError extends Error {\n}\nconst normalize = (str) => str.endsWith(\"/\") && str.length > 1 ? str.slice(0, -1) : str;\nfunction comparePaths(a, b) {\n  return normalize(a) === normalize(b);\n}\nfunction lazyFn(fn, key) {\n  return async (...args) => {\n    const imported = await fn();\n    return imported[key || \"default\"](...args);\n  };\n}\nfunction getInitialRouterState(location) {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: \"idle\",\n    resolvedLocation: void 0,\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200\n  };\n}\nfunction validateSearch(validateSearch2, input) {\n  if (validateSearch2 == null) return {};\n  if (\"~standard\" in validateSearch2) {\n    const result = validateSearch2[\"~standard\"].validate(input);\n    if (result instanceof Promise)\n      throw new SearchParamError(\"Async validation not supported\");\n    if (result.issues)\n      throw new SearchParamError(JSON.stringify(result.issues, void 0, 2), {\n        cause: result\n      });\n    return result.value;\n  }\n  if (\"parse\" in validateSearch2) {\n    return validateSearch2.parse(input);\n  }\n  if (typeof validateSearch2 === \"function\") {\n    return validateSearch2(input);\n  }\n  return {};\n}\nfunction getMatchedRoutes({\n  pathname,\n  routesById,\n  processedTree\n}) {\n  const routeParams = {};\n  const trimmedPath = trimPathRight(pathname);\n  let foundRoute = void 0;\n  let parsedParams = {};\n  const match = findRouteMatch(trimmedPath, processedTree, true);\n  if (match) {\n    foundRoute = match.route;\n    Object.assign(routeParams, match.rawParams);\n    parsedParams = Object.assign({}, match.parsedParams);\n  }\n  const matchedRoutes = match?.branch || [routesById[rootRouteId]];\n  return { matchedRoutes, routeParams, foundRoute, parsedParams };\n}\nfunction buildMatchSnapshot({\n  matchResult,\n  pathname,\n  searchStr,\n  notFoundRoute,\n  notFoundMode\n}) {\n  const snapshot = {\n    routeIds: matchResult.matchedRoutes.map((r) => r.id),\n    params: matchResult.routeParams,\n    parsedParams: matchResult.parsedParams,\n    searchStr\n  };\n  const isGlobalNotFound = matchResult.foundRoute ? matchResult.foundRoute.path !== \"/\" && matchResult.routeParams[\"**\"] : trimPathRight(pathname);\n  if (isGlobalNotFound) {\n    if (notFoundRoute) {\n      snapshot.globalNotFoundRouteId = notFoundRoute.id;\n    } else {\n      if (notFoundMode !== \"root\") {\n        for (let i = matchResult.matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchResult.matchedRoutes[i];\n          if (route.children) {\n            snapshot.globalNotFoundRouteId = route.id;\n            break;\n          }\n        }\n      }\n      if (!snapshot.globalNotFoundRouteId) {\n        snapshot.globalNotFoundRouteId = rootRouteId;\n      }\n    }\n  }\n  return snapshot;\n}\nfunction buildMatchSnapshotFromRoutes({\n  routes,\n  params,\n  searchStr,\n  globalNotFoundRouteId\n}) {\n  const stringParams = {};\n  for (const key in params) {\n    const value = params[key];\n    if (value != null) {\n      stringParams[key] = String(value);\n    }\n  }\n  const snapshot = {\n    routeIds: routes.map((r) => r.id),\n    params: stringParams,\n    parsedParams: params,\n    searchStr\n  };\n  if (globalNotFoundRouteId) {\n    snapshot.globalNotFoundRouteId = globalNotFoundRouteId;\n  }\n  return snapshot;\n}\nfunction applySearchMiddleware({\n  search,\n  dest,\n  destRoutes,\n  _includeValidateSearch\n}) {\n  const allMiddlewares = destRoutes.reduce(\n    (acc, route) => {\n      const middlewares = [];\n      if (\"search\" in route.options) {\n        if (route.options.search?.middlewares) {\n          middlewares.push(...route.options.search.middlewares);\n        }\n      } else if (route.options.preSearchFilters || route.options.postSearchFilters) {\n        const legacyMiddleware = ({\n          search: search2,\n          next\n        }) => {\n          let nextSearch = search2;\n          if (\"preSearchFilters\" in route.options && route.options.preSearchFilters) {\n            nextSearch = route.options.preSearchFilters.reduce(\n              (prev, next2) => next2(prev),\n              search2\n            );\n          }\n          const result = next(nextSearch);\n          if (\"postSearchFilters\" in route.options && route.options.postSearchFilters) {\n            return route.options.postSearchFilters.reduce(\n              (prev, next2) => next2(prev),\n              result\n            );\n          }\n          return result;\n        };\n        middlewares.push(legacyMiddleware);\n      }\n      if (_includeValidateSearch && route.options.validateSearch) {\n        const validate = ({ search: search2, next }) => {\n          const result = next(search2);\n          try {\n            const validatedSearch = {\n              ...result,\n              ...validateSearch(route.options.validateSearch, result) ?? void 0\n            };\n            return validatedSearch;\n          } catch {\n            return result;\n          }\n        };\n        middlewares.push(validate);\n      }\n      return acc.concat(middlewares);\n    },\n    []\n  ) ?? [];\n  const final = ({ search: search2 }) => {\n    if (!dest.search) {\n      return {};\n    }\n    if (dest.search === true) {\n      return search2;\n    }\n    return functionalUpdate(dest.search, search2);\n  };\n  allMiddlewares.push(final);\n  const applyNext = (index, currentSearch) => {\n    if (index >= allMiddlewares.length) {\n      return currentSearch;\n    }\n    const middleware = allMiddlewares[index];\n    const next = (newSearch) => {\n      return applyNext(index + 1, newSearch);\n    };\n    return middleware({ search: currentSearch, next });\n  };\n  return applyNext(0, search);\n}\nfunction findGlobalNotFoundRouteId(notFoundMode, routes) {\n  if (notFoundMode !== \"root\") {\n    for (let i = routes.length - 1; i >= 0; i--) {\n      const route = routes[i];\n      if (route.children) {\n        return route.id;\n      }\n    }\n  }\n  return rootRouteId;\n}\nexport {\n  PathParamError,\n  RouterCore,\n  SearchParamError,\n  buildMatchSnapshot,\n  buildMatchSnapshotFromRoutes,\n  defaultSerializeError,\n  getInitialRouterState,\n  getLocationChangeInfo,\n  getMatchedRoutes,\n  lazyFn,\n  trailingSlashOptions\n};\n//# sourceMappingURL=router.js.map\n","import { defaultSerializeError } from \"./router.js\";\nconst TSR_DEFERRED_PROMISE = /* @__PURE__ */ Symbol.for(\"TSR_DEFERRED_PROMISE\");\nfunction defer(_promise, options) {\n  const promise = _promise;\n  if (promise[TSR_DEFERRED_PROMISE]) {\n    return promise;\n  }\n  promise[TSR_DEFERRED_PROMISE] = { status: \"pending\" };\n  promise.then((data) => {\n    promise[TSR_DEFERRED_PROMISE].status = \"success\";\n    promise[TSR_DEFERRED_PROMISE].data = data;\n  }).catch((error) => {\n    promise[TSR_DEFERRED_PROMISE].status = \"error\";\n    promise[TSR_DEFERRED_PROMISE].error = {\n      data: (options?.serializeError ?? defaultSerializeError)(error),\n      __isServerError: true\n    };\n  });\n  return promise;\n}\nexport {\n  TSR_DEFERRED_PROMISE,\n  defer\n};\n//# sourceMappingURL=defer.js.map\n","const preloadWarning = \"Error preloading route! \";\nexport {\n  preloadWarning\n};\n//# sourceMappingURL=link.js.map\n","const isMatch = (match, path) => {\n  const parts = path.split(\".\");\n  let part;\n  let i = 0;\n  let value = match;\n  while ((part = parts[i++]) != null && value != null) {\n    value = value[part];\n  }\n  return value != null;\n};\nexport {\n  isMatch\n};\n//# sourceMappingURL=Matches.js.map\n","import invariant from \"tiny-invariant\";\nimport { trimPathLeft, joinPaths, trimPathRight } from \"./path.js\";\nimport { notFound } from \"./not-found.js\";\nimport { redirect } from \"./redirect.js\";\nimport { rootRouteId } from \"./root.js\";\nclass BaseRoute {\n  constructor(options) {\n    this.init = (opts) => {\n      this.originalIndex = opts.originalIndex;\n      const options2 = this.options;\n      const isRoot = !options2?.path && !options2?.id;\n      this.parentRoute = this.options.getParentRoute?.();\n      if (isRoot) {\n        this._path = rootRouteId;\n      } else if (!this.parentRoute) {\n        invariant(\n          false,\n          `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`\n        );\n      }\n      let path = isRoot ? rootRouteId : options2?.path;\n      if (path && path !== \"/\") {\n        path = trimPathLeft(path);\n      }\n      const customId = options2?.id || path;\n      let id = isRoot ? rootRouteId : joinPaths([\n        this.parentRoute.id === rootRouteId ? \"\" : this.parentRoute.id,\n        customId\n      ]);\n      if (path === rootRouteId) {\n        path = \"/\";\n      }\n      if (id !== rootRouteId) {\n        id = joinPaths([\"/\", id]);\n      }\n      const fullPath = id === rootRouteId ? \"/\" : joinPaths([this.parentRoute.fullPath, path]);\n      this._path = path;\n      this._id = id;\n      this._fullPath = fullPath;\n      this._to = trimPathRight(fullPath);\n    };\n    this.addChildren = (children) => {\n      return this._addFileChildren(children);\n    };\n    this._addFileChildren = (children) => {\n      if (Array.isArray(children)) {\n        this.children = children;\n      }\n      if (typeof children === \"object\" && children !== null) {\n        this.children = Object.values(children);\n      }\n      return this;\n    };\n    this._addFileTypes = () => {\n      return this;\n    };\n    this.updateLoader = (options2) => {\n      Object.assign(this.options, options2);\n      return this;\n    };\n    this.update = (options2) => {\n      Object.assign(this.options, options2);\n      return this;\n    };\n    this.lazy = (lazyFn) => {\n      this.lazyFn = lazyFn;\n      return this;\n    };\n    this.redirect = (opts) => redirect({ from: this.fullPath, ...opts });\n    this.options = options || {};\n    this.isRoot = !options?.getParentRoute;\n    if (options?.id && options?.path) {\n      throw new Error(`Route cannot have both an 'id' and a 'path' option.`);\n    }\n  }\n  get to() {\n    return this._to;\n  }\n  get id() {\n    return this._id;\n  }\n  get path() {\n    return this._path;\n  }\n  get fullPath() {\n    return this._fullPath;\n  }\n}\nclass BaseRouteApi {\n  constructor({ id }) {\n    this.notFound = (opts) => {\n      return notFound({ routeId: this.id, ...opts });\n    };\n    this.redirect = (opts) => redirect({ from: this.id, ...opts });\n    this.id = id;\n  }\n}\nclass BaseRootRoute extends BaseRoute {\n  constructor(options) {\n    super(options);\n  }\n}\nexport {\n  BaseRootRoute,\n  BaseRoute,\n  BaseRouteApi\n};\n//# sourceMappingURL=route.js.map\n","const createRouterConfig = (options) => {\n  return {\n    serializationAdapters: options.serializationAdapters,\n    defaultSsr: options.defaultSsr\n  };\n};\nexport {\n  createRouterConfig\n};\n//# sourceMappingURL=config.js.map\n","import { deepEqual } from \"./utils.js\";\nfunction retainSearchParams(keys) {\n  return ({ search, next }) => {\n    const result = next(search);\n    if (keys === true) {\n      return { ...search, ...result };\n    }\n    const copy = { ...result };\n    keys.forEach((key) => {\n      if (!(key in copy)) {\n        copy[key] = search[key];\n      }\n    });\n    return copy;\n  };\n}\nfunction stripSearchParams(input) {\n  return ({ search, next }) => {\n    if (input === true) {\n      return {};\n    }\n    const result = { ...next(search) };\n    if (Array.isArray(input)) {\n      input.forEach((key) => {\n        delete result[key];\n      });\n    } else {\n      Object.entries(input).forEach(\n        ([key, value]) => {\n          if (deepEqual(result[key], value)) {\n            delete result[key];\n          }\n        }\n      );\n    }\n    return result;\n  };\n}\nexport {\n  retainSearchParams,\n  stripSearchParams\n};\n//# sourceMappingURL=searchMiddleware.js.map\n","// src/core/compat.ts\nvar Feature = /* @__PURE__ */ ((Feature2) => {\n  Feature2[Feature2[\"AggregateError\"] = 1] = \"AggregateError\";\n  Feature2[Feature2[\"ArrowFunction\"] = 2] = \"ArrowFunction\";\n  Feature2[Feature2[\"ErrorPrototypeStack\"] = 4] = \"ErrorPrototypeStack\";\n  Feature2[Feature2[\"ObjectAssign\"] = 8] = \"ObjectAssign\";\n  Feature2[Feature2[\"BigIntTypedArray\"] = 16] = \"BigIntTypedArray\";\n  Feature2[Feature2[\"RegExp\"] = 32] = \"RegExp\";\n  return Feature2;\n})(Feature || {});\nvar ALL_ENABLED = 1 /* AggregateError */ | 2 /* ArrowFunction */ | 4 /* ErrorPrototypeStack */ | 8 /* ObjectAssign */ | 16 /* BigIntTypedArray */ | 32 /* RegExp */;\n\n// src/core/symbols.ts\nvar SYM_ASYNC_ITERATOR = Symbol.asyncIterator;\nvar SYM_HAS_INSTANCE = Symbol.hasInstance;\nvar SYM_IS_CONCAT_SPREADABLE = Symbol.isConcatSpreadable;\nvar SYM_ITERATOR = Symbol.iterator;\nvar SYM_MATCH = Symbol.match;\nvar SYM_MATCH_ALL = Symbol.matchAll;\nvar SYM_REPLACE = Symbol.replace;\nvar SYM_SEARCH = Symbol.search;\nvar SYM_SPECIES = Symbol.species;\nvar SYM_SPLIT = Symbol.split;\nvar SYM_TO_PRIMITIVE = Symbol.toPrimitive;\nvar SYM_TO_STRING_TAG = Symbol.toStringTag;\nvar SYM_UNSCOPABLES = Symbol.unscopables;\n\n// src/core/constants.ts\nvar SYMBOL_STRING = {\n  [0 /* AsyncIterator */]: \"Symbol.asyncIterator\",\n  [1 /* HasInstance */]: \"Symbol.hasInstance\",\n  [2 /* IsConcatSpreadable */]: \"Symbol.isConcatSpreadable\",\n  [3 /* Iterator */]: \"Symbol.iterator\",\n  [4 /* Match */]: \"Symbol.match\",\n  [5 /* MatchAll */]: \"Symbol.matchAll\",\n  [6 /* Replace */]: \"Symbol.replace\",\n  [7 /* Search */]: \"Symbol.search\",\n  [8 /* Species */]: \"Symbol.species\",\n  [9 /* Split */]: \"Symbol.split\",\n  [10 /* ToPrimitive */]: \"Symbol.toPrimitive\",\n  [11 /* ToStringTag */]: \"Symbol.toStringTag\",\n  [12 /* Unscopables */]: \"Symbol.unscopables\"\n};\nvar INV_SYMBOL_REF = {\n  [SYM_ASYNC_ITERATOR]: 0 /* AsyncIterator */,\n  [SYM_HAS_INSTANCE]: 1 /* HasInstance */,\n  [SYM_IS_CONCAT_SPREADABLE]: 2 /* IsConcatSpreadable */,\n  [SYM_ITERATOR]: 3 /* Iterator */,\n  [SYM_MATCH]: 4 /* Match */,\n  [SYM_MATCH_ALL]: 5 /* MatchAll */,\n  [SYM_REPLACE]: 6 /* Replace */,\n  [SYM_SEARCH]: 7 /* Search */,\n  [SYM_SPECIES]: 8 /* Species */,\n  [SYM_SPLIT]: 9 /* Split */,\n  [SYM_TO_PRIMITIVE]: 10 /* ToPrimitive */,\n  [SYM_TO_STRING_TAG]: 11 /* ToStringTag */,\n  [SYM_UNSCOPABLES]: 12 /* Unscopables */\n};\nvar SYMBOL_REF = {\n  [0 /* AsyncIterator */]: SYM_ASYNC_ITERATOR,\n  [1 /* HasInstance */]: SYM_HAS_INSTANCE,\n  [2 /* IsConcatSpreadable */]: SYM_IS_CONCAT_SPREADABLE,\n  [3 /* Iterator */]: SYM_ITERATOR,\n  [4 /* Match */]: SYM_MATCH,\n  [5 /* MatchAll */]: SYM_MATCH_ALL,\n  [6 /* Replace */]: SYM_REPLACE,\n  [7 /* Search */]: SYM_SEARCH,\n  [8 /* Species */]: SYM_SPECIES,\n  [9 /* Split */]: SYM_SPLIT,\n  [10 /* ToPrimitive */]: SYM_TO_PRIMITIVE,\n  [11 /* ToStringTag */]: SYM_TO_STRING_TAG,\n  [12 /* Unscopables */]: SYM_UNSCOPABLES\n};\nvar CONSTANT_STRING = {\n  [2 /* True */]: \"!0\",\n  [3 /* False */]: \"!1\",\n  [1 /* Undefined */]: \"void 0\",\n  [0 /* Null */]: \"null\",\n  [4 /* NegZero */]: \"-0\",\n  [5 /* Inf */]: \"1/0\",\n  [6 /* NegInf */]: \"-1/0\",\n  [7 /* Nan */]: \"0/0\"\n};\nvar NIL = void 0;\nvar CONSTANT_VAL = {\n  [2 /* True */]: true,\n  [3 /* False */]: false,\n  [1 /* Undefined */]: NIL,\n  [0 /* Null */]: null,\n  [4 /* NegZero */]: -0,\n  [5 /* Inf */]: Number.POSITIVE_INFINITY,\n  [6 /* NegInf */]: Number.NEGATIVE_INFINITY,\n  [7 /* Nan */]: Number.NaN\n};\nvar ERROR_CONSTRUCTOR_STRING = {\n  [0 /* Error */]: \"Error\",\n  [1 /* EvalError */]: \"EvalError\",\n  [2 /* RangeError */]: \"RangeError\",\n  [3 /* ReferenceError */]: \"ReferenceError\",\n  [4 /* SyntaxError */]: \"SyntaxError\",\n  [5 /* TypeError */]: \"TypeError\",\n  [6 /* URIError */]: \"URIError\"\n};\nvar ERROR_CONSTRUCTOR = {\n  [0 /* Error */]: Error,\n  [1 /* EvalError */]: EvalError,\n  [2 /* RangeError */]: RangeError,\n  [3 /* ReferenceError */]: ReferenceError,\n  [4 /* SyntaxError */]: SyntaxError,\n  [5 /* TypeError */]: TypeError,\n  [6 /* URIError */]: URIError\n};\n\n// src/core/node.ts\nfunction createSerovalNode(t, i, s, c, m, p, e, a, f, b, o, l) {\n  return {\n    t,\n    i,\n    s,\n    c,\n    m,\n    p,\n    e,\n    a,\n    f,\n    b,\n    o,\n    l\n  };\n}\n\n// src/core/literals.ts\nfunction createConstantNode(value) {\n  return createSerovalNode(\n    2 /* Constant */,\n    NIL,\n    value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nvar TRUE_NODE = /* @__PURE__ */ createConstantNode(\n  2 /* True */\n);\nvar FALSE_NODE = /* @__PURE__ */ createConstantNode(\n  3 /* False */\n);\nvar UNDEFINED_NODE = /* @__PURE__ */ createConstantNode(\n  1 /* Undefined */\n);\nvar NULL_NODE = /* @__PURE__ */ createConstantNode(\n  0 /* Null */\n);\nvar NEG_ZERO_NODE = /* @__PURE__ */ createConstantNode(\n  4 /* NegZero */\n);\nvar INFINITY_NODE = /* @__PURE__ */ createConstantNode(\n  5 /* Inf */\n);\nvar NEG_INFINITY_NODE = /* @__PURE__ */ createConstantNode(\n  6 /* NegInf */\n);\nvar NAN_NODE = /* @__PURE__ */ createConstantNode(7 /* Nan */);\n\n// src/core/string.ts\nfunction serializeChar(str) {\n  switch (str) {\n    case '\"':\n      return '\\\\\"';\n    case \"\\\\\":\n      return \"\\\\\\\\\";\n    case \"\\n\":\n      return \"\\\\n\";\n    case \"\\r\":\n      return \"\\\\r\";\n    case \"\\b\":\n      return \"\\\\b\";\n    case \"\t\":\n      return \"\\\\t\";\n    case \"\\f\":\n      return \"\\\\f\";\n    case \"<\":\n      return \"\\\\x3C\";\n    case \"\\u2028\":\n      return \"\\\\u2028\";\n    case \"\\u2029\":\n      return \"\\\\u2029\";\n    default:\n      return NIL;\n  }\n}\nfunction serializeString(str) {\n  let result = \"\";\n  let lastPos = 0;\n  let replacement;\n  for (let i = 0, len = str.length; i < len; i++) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return result;\n}\nfunction deserializeReplacer(str) {\n  switch (str) {\n    case \"\\\\\\\\\":\n      return \"\\\\\";\n    case '\\\\\"':\n      return '\"';\n    case \"\\\\n\":\n      return \"\\n\";\n    case \"\\\\r\":\n      return \"\\r\";\n    case \"\\\\b\":\n      return \"\\b\";\n    case \"\\\\t\":\n      return \"\t\";\n    case \"\\\\f\":\n      return \"\\f\";\n    case \"\\\\x3C\":\n      return \"<\";\n    case \"\\\\u2028\":\n      return \"\\u2028\";\n    case \"\\\\u2029\":\n      return \"\\u2029\";\n    default:\n      return str;\n  }\n}\nfunction deserializeString(str) {\n  return str.replace(\n    /(\\\\\\\\|\\\\\"|\\\\n|\\\\r|\\\\b|\\\\t|\\\\f|\\\\u2028|\\\\u2029|\\\\x3C)/g,\n    deserializeReplacer\n  );\n}\n\n// src/core/keys.ts\nvar REFERENCES_KEY = \"__SEROVAL_REFS__\";\nvar GLOBAL_CONTEXT_REFERENCES = \"$R\";\nvar GLOBAL_CONTEXT_R = `self.${GLOBAL_CONTEXT_REFERENCES}`;\nfunction getCrossReferenceHeader(id) {\n  if (id == null) {\n    return `${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||[]`;\n  }\n  return `(${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||{})[\"${serializeString(\n    id\n  )}\"]=[]`;\n}\n\n// src/core/reference.ts\nvar REFERENCE = /* @__PURE__ */ new Map();\nvar INV_REFERENCE = /* @__PURE__ */ new Map();\nfunction createReference(id, value) {\n  REFERENCE.set(value, id);\n  INV_REFERENCE.set(id, value);\n  return value;\n}\nfunction hasReferenceID(value) {\n  return REFERENCE.has(value);\n}\nfunction hasReference(id) {\n  return INV_REFERENCE.has(id);\n}\nfunction getReferenceID(value) {\n  if (hasReferenceID(value)) {\n    return REFERENCE.get(value);\n  }\n  throw new SerovalMissingReferenceError(value);\n}\nfunction getReference(id) {\n  if (hasReference(id)) {\n    return INV_REFERENCE.get(id);\n  }\n  throw new SerovalMissingReferenceForIdError(id);\n}\nif (typeof globalThis !== \"undefined\") {\n  Object.defineProperty(globalThis, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof window !== \"undefined\") {\n  Object.defineProperty(window, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof self !== \"undefined\") {\n  Object.defineProperty(self, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof global !== \"undefined\") {\n  Object.defineProperty(global, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n}\n\n// src/core/utils/error.ts\nfunction getErrorConstructor(error) {\n  if (error instanceof EvalError) {\n    return 1 /* EvalError */;\n  }\n  if (error instanceof RangeError) {\n    return 2 /* RangeError */;\n  }\n  if (error instanceof ReferenceError) {\n    return 3 /* ReferenceError */;\n  }\n  if (error instanceof SyntaxError) {\n    return 4 /* SyntaxError */;\n  }\n  if (error instanceof TypeError) {\n    return 5 /* TypeError */;\n  }\n  if (error instanceof URIError) {\n    return 6 /* URIError */;\n  }\n  return 0 /* Error */;\n}\nfunction getInitialErrorOptions(error) {\n  const construct = ERROR_CONSTRUCTOR_STRING[getErrorConstructor(error)];\n  if (error.name !== construct) {\n    return { name: error.name };\n  }\n  if (error.constructor.name !== construct) {\n    return { name: error.constructor.name };\n  }\n  return {};\n}\nfunction getErrorOptions(error, features) {\n  let options = getInitialErrorOptions(error);\n  const names = Object.getOwnPropertyNames(error);\n  for (let i = 0, len = names.length, name; i < len; i++) {\n    name = names[i];\n    if (name !== \"name\" && name !== \"message\") {\n      if (name === \"stack\") {\n        if (features & 4 /* ErrorPrototypeStack */) {\n          options = options || {};\n          options[name] = error[name];\n        }\n      } else {\n        options = options || {};\n        options[name] = error[name];\n      }\n    }\n  }\n  return options;\n}\n\n// src/core/utils/get-object-flag.ts\nfunction getObjectFlag(obj) {\n  if (Object.isFrozen(obj)) {\n    return 3 /* Frozen */;\n  }\n  if (Object.isSealed(obj)) {\n    return 2 /* Sealed */;\n  }\n  if (Object.isExtensible(obj)) {\n    return 0 /* None */;\n  }\n  return 1 /* NonExtensible */;\n}\n\n// src/core/base-primitives.ts\nfunction createNumberNode(value) {\n  switch (value) {\n    case Number.POSITIVE_INFINITY:\n      return INFINITY_NODE;\n    case Number.NEGATIVE_INFINITY:\n      return NEG_INFINITY_NODE;\n  }\n  if (value !== value) {\n    return NAN_NODE;\n  }\n  if (Object.is(value, -0)) {\n    return NEG_ZERO_NODE;\n  }\n  return createSerovalNode(\n    0 /* Number */,\n    NIL,\n    value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createStringNode(value) {\n  return createSerovalNode(\n    1 /* String */,\n    NIL,\n    serializeString(value),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createBigIntNode(current) {\n  return createSerovalNode(\n    3 /* BigInt */,\n    NIL,\n    \"\" + current,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createIndexedValueNode(id) {\n  return createSerovalNode(\n    4 /* IndexedValue */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createDateNode(id, current) {\n  const timestamp = current.valueOf();\n  return createSerovalNode(\n    5 /* Date */,\n    id,\n    timestamp !== timestamp ? \"\" : current.toISOString(),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createRegExpNode(id, current) {\n  return createSerovalNode(\n    6 /* RegExp */,\n    id,\n    NIL,\n    serializeString(current.source),\n    current.flags,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createWKSymbolNode(id, current) {\n  return createSerovalNode(\n    17 /* WKSymbol */,\n    id,\n    INV_SYMBOL_REF[current],\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createReferenceNode(id, ref) {\n  return createSerovalNode(\n    18 /* Reference */,\n    id,\n    serializeString(getReferenceID(ref)),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createPluginNode(id, tag, value) {\n  return createSerovalNode(\n    25 /* Plugin */,\n    id,\n    value,\n    serializeString(tag),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createArrayNode(id, current, parsedItems) {\n  return createSerovalNode(\n    9 /* Array */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsedItems,\n    NIL,\n    NIL,\n    getObjectFlag(current),\n    NIL\n  );\n}\nfunction createBoxedNode(id, boxed) {\n  return createSerovalNode(\n    21 /* Boxed */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    boxed,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createTypedArrayNode(id, current, buffer) {\n  return createSerovalNode(\n    15 /* TypedArray */,\n    id,\n    NIL,\n    current.constructor.name,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n    current.length\n  );\n}\nfunction createBigIntTypedArrayNode(id, current, buffer) {\n  return createSerovalNode(\n    16 /* BigIntTypedArray */,\n    id,\n    NIL,\n    current.constructor.name,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n    current.byteLength\n  );\n}\nfunction createDataViewNode(id, current, buffer) {\n  return createSerovalNode(\n    20 /* DataView */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n    current.byteLength\n  );\n}\nfunction createErrorNode(id, current, options) {\n  return createSerovalNode(\n    13 /* Error */,\n    id,\n    getErrorConstructor(current),\n    NIL,\n    serializeString(current.message),\n    options,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createAggregateErrorNode(id, current, options) {\n  return createSerovalNode(\n    14 /* AggregateError */,\n    id,\n    getErrorConstructor(current),\n    NIL,\n    serializeString(current.message),\n    options,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createSetNode(id, items) {\n  return createSerovalNode(\n    7 /* Set */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    items,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createIteratorFactoryInstanceNode(factory, items) {\n  return createSerovalNode(\n    28 /* IteratorFactoryInstance */,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [factory, items],\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createAsyncIteratorFactoryInstanceNode(factory, items) {\n  return createSerovalNode(\n    30 /* AsyncIteratorFactoryInstance */,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [factory, items],\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createStreamConstructorNode(id, factory, sequence) {\n  return createSerovalNode(\n    31 /* StreamConstructor */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    sequence,\n    factory,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createStreamNextNode(id, parsed) {\n  return createSerovalNode(\n    32 /* StreamNext */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createStreamThrowNode(id, parsed) {\n  return createSerovalNode(\n    33 /* StreamThrow */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createStreamReturnNode(id, parsed) {\n  return createSerovalNode(\n    34 /* StreamReturn */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n    NIL\n  );\n}\n\n// src/core/errors.ts\nvar { toString: objectToString } = Object.prototype;\nfunction getErrorMessageDev(type, cause) {\n  if (cause instanceof Error) {\n    return `Seroval caught an error during the ${type} process.\n  \n${cause.name}\n${cause.message}\n\n- For more information, please check the \"cause\" property of this error.\n- If you believe this is an error in Seroval, please submit an issue at https://github.com/lxsmnsyc/seroval/issues/new`;\n  }\n  return `Seroval caught an error during the ${type} process.\n\n\"${objectToString.call(cause)}\"\n\nFor more information, please check the \"cause\" property of this error.`;\n}\nvar getErrorMessage = (type, cause) => false ? getErrorMessageProd(type) : getErrorMessageDev(type, cause);\nvar SerovalError = class extends Error {\n  constructor(type, cause) {\n    super(getErrorMessage(type, cause));\n    this.cause = cause;\n  }\n};\nvar SerovalParserError = class extends SerovalError {\n  constructor(cause) {\n    super(\"parsing\", cause);\n  }\n};\nvar SerovalSerializationError = class extends SerovalError {\n  constructor(cause) {\n    super(\"serialization\", cause);\n  }\n};\nvar SerovalDeserializationError = class extends SerovalError {\n  constructor(cause) {\n    super(\"deserialization\", cause);\n  }\n};\nvar SerovalUnsupportedTypeError = class extends Error {\n  constructor(value) {\n    super(\n      false ? getSpecificErrorMessage(1 /* UnsupportedType */) : `The value ${objectToString.call(value)} of type \"${typeof value}\" cannot be parsed/serialized.\n      \nThere are few workarounds for this problem:\n- Transform the value in a way that it can be serialized.\n- If the reference is present on multiple runtimes (isomorphic), you can use the Reference API to map the references.`\n    );\n    this.value = value;\n  }\n};\nvar SerovalUnsupportedNodeError = class extends Error {\n  constructor(node) {\n    super(\n      false ? getSpecificErrorMessage(2 /* UnsupportedNode */) : 'Unsupported node type \"' + node.t + '\".'\n    );\n  }\n};\nvar SerovalMissingPluginError = class extends Error {\n  constructor(tag) {\n    super(\n      false ? getSpecificErrorMessage(3 /* MissingPlugin */) : 'Missing plugin for tag \"' + tag + '\".'\n    );\n  }\n};\nvar SerovalMissingInstanceError = class extends Error {\n  constructor(tag) {\n    super(\n      false ? getSpecificErrorMessage(4 /* MissingInstance */) : 'Missing \"' + tag + '\" instance.'\n    );\n  }\n};\nvar SerovalMissingReferenceError = class extends Error {\n  constructor(value) {\n    super(\n      false ? getSpecificErrorMessage(5 /* MissingReference */) : 'Missing reference for the value \"' + objectToString.call(value) + '\" of type \"' + typeof value + '\"'\n    );\n    this.value = value;\n  }\n};\nvar SerovalMissingReferenceForIdError = class extends Error {\n  constructor(id) {\n    super(\n      false ? getSpecificErrorMessage(6 /* MissingReferenceForId */) : 'Missing reference for id \"' + serializeString(id) + '\"'\n    );\n  }\n};\nvar SerovalUnknownTypedArrayError = class extends Error {\n  constructor(name) {\n    super(\n      false ? getSpecificErrorMessage(7 /* UnknownTypedArray */) : 'Unknown TypedArray \"' + name + '\"'\n    );\n  }\n};\nvar SerovalMalformedNodeError = class extends Error {\n  constructor(node) {\n    super(\n      false ? getSpecificErrorMessage(8 /* MalformedNode */) : 'Malformed node type \"' + node.t + '\".'\n    );\n  }\n};\nvar SerovalConflictedNodeIdError = class extends Error {\n  constructor(node) {\n    super(\n      false ? getSpecificErrorMessage(9 /* ConflictedNodeId */) : 'Conflicted node id \"' + node.i + '\".'\n    );\n  }\n};\nvar SerovalDepthLimitError = class extends Error {\n  constructor(limit) {\n    super(\n      false ? getSpecificErrorMessage(9 /* ConflictedNodeId */) : \"Depth limit of \" + limit + \" reached\"\n    );\n  }\n};\n\n// src/core/opaque-reference.ts\nvar OpaqueReference = class {\n  constructor(value, replacement) {\n    this.value = value;\n    this.replacement = replacement;\n  }\n};\n\n// src/core/constructors.ts\nvar PROMISE_CONSTRUCTOR = () => {\n  const resolver = {\n    p: 0,\n    s: 0,\n    f: 0\n  };\n  resolver.p = new Promise((resolve, reject) => {\n    resolver.s = resolve;\n    resolver.f = reject;\n  });\n  return resolver;\n};\nvar PROMISE_SUCCESS = (resolver, data) => {\n  resolver.s(data);\n  resolver.p.s = 1;\n  resolver.p.v = data;\n};\nvar PROMISE_FAILURE = (resolver, data) => {\n  resolver.f(data);\n  resolver.p.s = 2;\n  resolver.p.v = data;\n};\nvar SERIALIZED_PROMISE_CONSTRUCTOR = /* @__PURE__ */ PROMISE_CONSTRUCTOR.toString();\nvar SERIALIZED_PROMISE_SUCCESS = /* @__PURE__ */ PROMISE_SUCCESS.toString();\nvar SERIALIZED_PROMISE_FAILURE = /* @__PURE__ */ PROMISE_FAILURE.toString();\nvar STREAM_CONSTRUCTOR = () => {\n  const buffer = [];\n  const listeners = [];\n  let alive = true;\n  let success = false;\n  let count = 0;\n  const flush = (value, mode, x) => {\n    for (x = 0; x < count; x++) {\n      if (listeners[x]) {\n        listeners[x][mode](value);\n      }\n    }\n  };\n  const up = (listener, x, z, current) => {\n    for (x = 0, z = buffer.length; x < z; x++) {\n      current = buffer[x];\n      if (!alive && x === z - 1) {\n        listener[success ? \"return\" : \"throw\"](current);\n      } else {\n        listener.next(current);\n      }\n    }\n  };\n  const on = (listener, temp) => {\n    if (alive) {\n      temp = count++;\n      listeners[temp] = listener;\n    }\n    up(listener);\n    return () => {\n      if (alive) {\n        listeners[temp] = listeners[count];\n        listeners[count--] = void 0;\n      }\n    };\n  };\n  return {\n    __SEROVAL_STREAM__: true,\n    on: (listener) => on(listener),\n    next: (value) => {\n      if (alive) {\n        buffer.push(value);\n        flush(value, \"next\");\n      }\n    },\n    throw: (value) => {\n      if (alive) {\n        buffer.push(value);\n        flush(value, \"throw\");\n        alive = false;\n        success = false;\n        listeners.length = 0;\n      }\n    },\n    return: (value) => {\n      if (alive) {\n        buffer.push(value);\n        flush(value, \"return\");\n        alive = false;\n        success = true;\n        listeners.length = 0;\n      }\n    }\n  };\n};\nvar SERIALIZED_STREAM_CONSTRUCTOR = /* @__PURE__ */ STREAM_CONSTRUCTOR.toString();\nvar ITERATOR_CONSTRUCTOR = (symbol) => (sequence) => () => {\n  let index = 0;\n  const instance = {\n    [symbol]: () => instance,\n    next: () => {\n      if (index > sequence.d) {\n        return {\n          done: true,\n          value: void 0\n        };\n      }\n      const currentIndex = index++;\n      const data = sequence.v[currentIndex];\n      if (currentIndex === sequence.t) {\n        throw data;\n      }\n      return {\n        done: currentIndex === sequence.d,\n        value: data\n      };\n    }\n  };\n  return instance;\n};\nvar SERIALIZED_ITERATOR_CONSTRUCTOR = /* @__PURE__ */ ITERATOR_CONSTRUCTOR.toString();\nvar ASYNC_ITERATOR_CONSTRUCTOR = (symbol, createPromise) => (stream) => () => {\n  let count = 0;\n  let doneAt = -1;\n  let isThrow = false;\n  const buffer = [];\n  const pending = [];\n  const finalize = (i = 0, len = pending.length) => {\n    for (; i < len; i++) {\n      pending[i].s({\n        done: true,\n        value: void 0\n      });\n    }\n  };\n  stream.on({\n    next: (value) => {\n      const temp = pending.shift();\n      if (temp) {\n        temp.s({ done: false, value });\n      }\n      buffer.push(value);\n    },\n    throw: (value) => {\n      const temp = pending.shift();\n      if (temp) {\n        temp.f(value);\n      }\n      finalize();\n      doneAt = buffer.length;\n      isThrow = true;\n      buffer.push(value);\n    },\n    return: (value) => {\n      const temp = pending.shift();\n      if (temp) {\n        temp.s({ done: true, value });\n      }\n      finalize();\n      doneAt = buffer.length;\n      buffer.push(value);\n    }\n  });\n  const instance = {\n    [symbol]: () => instance,\n    next: () => {\n      if (doneAt === -1) {\n        const index2 = count++;\n        if (index2 >= buffer.length) {\n          const temp = createPromise();\n          pending.push(temp);\n          return temp.p;\n        }\n        return {\n          done: false,\n          value: buffer[index2]\n        };\n      }\n      if (count > doneAt) {\n        return {\n          done: true,\n          value: void 0\n        };\n      }\n      const index = count++;\n      const value = buffer[index];\n      if (index !== doneAt) {\n        return {\n          done: false,\n          value\n        };\n      }\n      if (isThrow) {\n        throw value;\n      }\n      return {\n        done: true,\n        value\n      };\n    }\n  };\n  return instance;\n};\nvar SERIALIZED_ASYNC_ITERATOR_CONSTRUCTOR = /* @__PURE__ */ ASYNC_ITERATOR_CONSTRUCTOR.toString();\nvar ARRAY_BUFFER_CONSTRUCTOR = (b64) => {\n  const decoded = atob(b64);\n  const length = decoded.length;\n  const arr = new Uint8Array(length);\n  for (let i = 0; i < length; i++) {\n    arr[i] = decoded.charCodeAt(i);\n  }\n  return arr.buffer;\n};\nvar SERIALIZED_ARRAY_BUFFER_CONSTRUCTOR = /* @__PURE__ */ ARRAY_BUFFER_CONSTRUCTOR.toString();\n\n// src/core/special-reference.ts\nvar ITERATOR = {};\nvar ASYNC_ITERATOR = {};\nvar SPECIAL_REFS = {\n  [0 /* MapSentinel */]: {},\n  [1 /* PromiseConstructor */]: {},\n  [2 /* PromiseSuccess */]: {},\n  [3 /* PromiseFailure */]: {},\n  [4 /* StreamConstructor */]: {},\n  [5 /* ArrayBufferConstructor */]: {}\n};\nvar SPECIAL_REF_STRING = {\n  [0 /* MapSentinel */]: \"[]\",\n  [1 /* PromiseConstructor */]: SERIALIZED_PROMISE_CONSTRUCTOR,\n  [2 /* PromiseSuccess */]: SERIALIZED_PROMISE_SUCCESS,\n  [3 /* PromiseFailure */]: SERIALIZED_PROMISE_FAILURE,\n  [4 /* StreamConstructor */]: SERIALIZED_STREAM_CONSTRUCTOR,\n  [5 /* ArrayBufferConstructor */]: SERIALIZED_ARRAY_BUFFER_CONSTRUCTOR\n};\n\n// src/core/stream.ts\nfunction isStream(value) {\n  return \"__SEROVAL_STREAM__\" in value;\n}\nfunction createStream() {\n  return STREAM_CONSTRUCTOR();\n}\nfunction createStreamFromAsyncIterable(iterable) {\n  const stream = createStream();\n  const iterator = iterable[SYM_ASYNC_ITERATOR]();\n  async function push() {\n    try {\n      const value = await iterator.next();\n      if (value.done) {\n        stream.return(value.value);\n      } else {\n        stream.next(value.value);\n        await push();\n      }\n    } catch (error) {\n      stream.throw(error);\n    }\n  }\n  push().catch(() => {\n  });\n  return stream;\n}\nvar createAsyncIterable = ASYNC_ITERATOR_CONSTRUCTOR(\n  SYM_ASYNC_ITERATOR,\n  PROMISE_CONSTRUCTOR\n);\nfunction streamToAsyncIterable(stream) {\n  return createAsyncIterable(\n    stream\n  );\n}\n\n// src/core/utils/iterator-to-sequence.ts\nfunction iteratorToSequence(source) {\n  const values = [];\n  let throwsAt = -1;\n  let doneAt = -1;\n  const iterator = source[SYM_ITERATOR]();\n  while (true) {\n    try {\n      const value = iterator.next();\n      values.push(value.value);\n      if (value.done) {\n        doneAt = values.length - 1;\n        break;\n      }\n    } catch (error) {\n      throwsAt = values.length;\n      values.push(error);\n    }\n  }\n  return {\n    v: values,\n    t: throwsAt,\n    d: doneAt\n  };\n}\nvar createIterator = ITERATOR_CONSTRUCTOR(SYM_ITERATOR);\nfunction sequenceToIterator(sequence) {\n  return createIterator(sequence);\n}\n\n// src/core/utils/promise-to-result.ts\nasync function promiseToResult(current) {\n  try {\n    return [1, await current];\n  } catch (e) {\n    return [0, e];\n  }\n}\n\n// src/core/context/parser.ts\nfunction createBaseParserContext(mode, options) {\n  return {\n    plugins: options.plugins,\n    mode,\n    marked: /* @__PURE__ */ new Set(),\n    features: ALL_ENABLED ^ (options.disabledFeatures || 0),\n    refs: options.refs || /* @__PURE__ */ new Map(),\n    depthLimit: options.depthLimit || 1e3\n  };\n}\nfunction markParserRef(ctx, id) {\n  ctx.marked.add(id);\n}\nfunction createIndexForValue(ctx, current) {\n  const id = ctx.refs.size;\n  ctx.refs.set(current, id);\n  return id;\n}\nfunction getNodeForIndexedValue(ctx, current) {\n  const registeredId = ctx.refs.get(current);\n  if (registeredId != null) {\n    markParserRef(ctx, registeredId);\n    return {\n      type: 1 /* Indexed */,\n      value: createIndexedValueNode(registeredId)\n    };\n  }\n  return {\n    type: 0 /* Fresh */,\n    value: createIndexForValue(ctx, current)\n  };\n}\nfunction getReferenceNode(ctx, current) {\n  const indexed = getNodeForIndexedValue(ctx, current);\n  if (indexed.type === 1 /* Indexed */) {\n    return indexed;\n  }\n  if (hasReferenceID(current)) {\n    return {\n      type: 2 /* Referenced */,\n      value: createReferenceNode(indexed.value, current)\n    };\n  }\n  return indexed;\n}\nfunction parseWellKnownSymbol(ctx, current) {\n  const ref = getReferenceNode(ctx, current);\n  if (ref.type !== 0 /* Fresh */) {\n    return ref.value;\n  }\n  if (current in INV_SYMBOL_REF) {\n    return createWKSymbolNode(ref.value, current);\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\nfunction parseSpecialReference(ctx, ref) {\n  const result = getNodeForIndexedValue(ctx, SPECIAL_REFS[ref]);\n  if (result.type === 1 /* Indexed */) {\n    return result.value;\n  }\n  return createSerovalNode(\n    26 /* SpecialReference */,\n    result.value,\n    ref,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction parseIteratorFactory(ctx) {\n  const result = getNodeForIndexedValue(ctx, ITERATOR);\n  if (result.type === 1 /* Indexed */) {\n    return result.value;\n  }\n  return createSerovalNode(\n    27 /* IteratorFactory */,\n    result.value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parseWellKnownSymbol(ctx, SYM_ITERATOR),\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction parseAsyncIteratorFactory(ctx) {\n  const result = getNodeForIndexedValue(ctx, ASYNC_ITERATOR);\n  if (result.type === 1 /* Indexed */) {\n    return result.value;\n  }\n  return createSerovalNode(\n    29 /* AsyncIteratorFactory */,\n    result.value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [\n      parseSpecialReference(ctx, 1 /* PromiseConstructor */),\n      parseWellKnownSymbol(ctx, SYM_ASYNC_ITERATOR)\n    ],\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createObjectNode(id, current, empty, record) {\n  return createSerovalNode(\n    empty ? 11 /* NullConstructor */ : 10 /* Object */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    record,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    getObjectFlag(current),\n    NIL\n  );\n}\nfunction createMapNode(ctx, id, k, v) {\n  return createSerovalNode(\n    8 /* Map */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    { k, v },\n    NIL,\n    parseSpecialReference(ctx, 0 /* MapSentinel */),\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createPromiseConstructorNode(ctx, id, resolver) {\n  return createSerovalNode(\n    22 /* PromiseConstructor */,\n    id,\n    resolver,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parseSpecialReference(ctx, 1 /* PromiseConstructor */),\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createArrayBufferNode(ctx, id, current) {\n  const bytes = new Uint8Array(current);\n  let result = \"\";\n  for (let i = 0, len = bytes.length; i < len; i++) {\n    result += String.fromCharCode(bytes[i]);\n  }\n  return createSerovalNode(\n    19 /* ArrayBuffer */,\n    id,\n    serializeString(btoa(result)),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parseSpecialReference(ctx, 5 /* ArrayBufferConstructor */),\n    NIL,\n    NIL,\n    NIL\n  );\n}\n\n// src/core/context/async-parser.ts\nfunction createAsyncParserContext(mode, options) {\n  return {\n    base: createBaseParserContext(mode, options),\n    child: void 0\n  };\n}\nvar AsyncParsePluginContext = class {\n  constructor(_p, depth) {\n    this._p = _p;\n    this.depth = depth;\n  }\n  parse(current) {\n    return parseAsync(this._p, this.depth, current);\n  }\n};\nasync function parseItems(ctx, depth, current) {\n  const nodes = [];\n  for (let i = 0, len = current.length; i < len; i++) {\n    if (i in current) {\n      nodes[i] = await parseAsync(ctx, depth, current[i]);\n    } else {\n      nodes[i] = 0;\n    }\n  }\n  return nodes;\n}\nasync function parseArray(ctx, depth, id, current) {\n  return createArrayNode(id, current, await parseItems(ctx, depth, current));\n}\nasync function parseProperties(ctx, depth, properties) {\n  const entries = Object.entries(properties);\n  const keyNodes = [];\n  const valueNodes = [];\n  for (let i = 0, len = entries.length; i < len; i++) {\n    keyNodes.push(serializeString(entries[i][0]));\n    valueNodes.push(await parseAsync(ctx, depth, entries[i][1]));\n  }\n  if (SYM_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ITERATOR));\n    valueNodes.push(\n      createIteratorFactoryInstanceNode(\n        parseIteratorFactory(ctx.base),\n        await parseAsync(\n          ctx,\n          depth,\n          iteratorToSequence(properties)\n        )\n      )\n    );\n  }\n  if (SYM_ASYNC_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ASYNC_ITERATOR));\n    valueNodes.push(\n      createAsyncIteratorFactoryInstanceNode(\n        parseAsyncIteratorFactory(ctx.base),\n        await parseAsync(\n          ctx,\n          depth,\n          createStreamFromAsyncIterable(\n            properties\n          )\n        )\n      )\n    );\n  }\n  if (SYM_TO_STRING_TAG in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_TO_STRING_TAG));\n    valueNodes.push(createStringNode(properties[SYM_TO_STRING_TAG]));\n  }\n  if (SYM_IS_CONCAT_SPREADABLE in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_IS_CONCAT_SPREADABLE));\n    valueNodes.push(\n      properties[SYM_IS_CONCAT_SPREADABLE] ? TRUE_NODE : FALSE_NODE\n    );\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes\n  };\n}\nasync function parsePlainObject(ctx, depth, id, current, empty) {\n  return createObjectNode(\n    id,\n    current,\n    empty,\n    await parseProperties(ctx, depth, current)\n  );\n}\nasync function parseBoxed(ctx, depth, id, current) {\n  return createBoxedNode(id, await parseAsync(ctx, depth, current.valueOf()));\n}\nasync function parseTypedArray(ctx, depth, id, current) {\n  return createTypedArrayNode(\n    id,\n    current,\n    await parseAsync(ctx, depth, current.buffer)\n  );\n}\nasync function parseBigIntTypedArray(ctx, depth, id, current) {\n  return createBigIntTypedArrayNode(\n    id,\n    current,\n    await parseAsync(ctx, depth, current.buffer)\n  );\n}\nasync function parseDataView(ctx, depth, id, current) {\n  return createDataViewNode(\n    id,\n    current,\n    await parseAsync(ctx, depth, current.buffer)\n  );\n}\nasync function parseError(ctx, depth, id, current) {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createErrorNode(\n    id,\n    current,\n    options ? await parseProperties(ctx, depth, options) : NIL\n  );\n}\nasync function parseAggregateError(ctx, depth, id, current) {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createAggregateErrorNode(\n    id,\n    current,\n    options ? await parseProperties(ctx, depth, options) : NIL\n  );\n}\nasync function parseMap(ctx, depth, id, current) {\n  const keyNodes = [];\n  const valueNodes = [];\n  for (const [key, value] of current.entries()) {\n    keyNodes.push(await parseAsync(ctx, depth, key));\n    valueNodes.push(await parseAsync(ctx, depth, value));\n  }\n  return createMapNode(ctx.base, id, keyNodes, valueNodes);\n}\nasync function parseSet(ctx, depth, id, current) {\n  const items = [];\n  for (const item of current.keys()) {\n    items.push(await parseAsync(ctx, depth, item));\n  }\n  return createSetNode(id, items);\n}\nasync function parsePlugin(ctx, depth, id, current) {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    for (let i = 0, len = currentPlugins.length; i < len; i++) {\n      const plugin = currentPlugins[i];\n      if (plugin.parse.async && plugin.test(current)) {\n        return createPluginNode(\n          id,\n          plugin.tag,\n          await plugin.parse.async(\n            current,\n            new AsyncParsePluginContext(ctx, depth),\n            {\n              id\n            }\n          )\n        );\n      }\n    }\n  }\n  return NIL;\n}\nasync function parsePromise(ctx, depth, id, current) {\n  const [status, result] = await promiseToResult(current);\n  return createSerovalNode(\n    12 /* Promise */,\n    id,\n    status,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    await parseAsync(ctx, depth, result),\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction parseStreamHandle(depth, id, current, resolve, reject) {\n  const sequence = [];\n  const cleanup = current.on({\n    next: (value) => {\n      markParserRef(this.base, id);\n      parseAsync(this, depth, value).then(\n        (data) => {\n          sequence.push(createStreamNextNode(id, data));\n        },\n        (data) => {\n          reject(data);\n          cleanup();\n        }\n      );\n    },\n    throw: (value) => {\n      markParserRef(this.base, id);\n      parseAsync(this, depth, value).then(\n        (data) => {\n          sequence.push(createStreamThrowNode(id, data));\n          resolve(sequence);\n          cleanup();\n        },\n        (data) => {\n          reject(data);\n          cleanup();\n        }\n      );\n    },\n    return: (value) => {\n      markParserRef(this.base, id);\n      parseAsync(this, depth, value).then(\n        (data) => {\n          sequence.push(createStreamReturnNode(id, data));\n          resolve(sequence);\n          cleanup();\n        },\n        (data) => {\n          reject(data);\n          cleanup();\n        }\n      );\n    }\n  });\n}\nasync function parseStream(ctx, depth, id, current) {\n  return createStreamConstructorNode(\n    id,\n    parseSpecialReference(ctx.base, 4 /* StreamConstructor */),\n    await new Promise(\n      parseStreamHandle.bind(ctx, depth, id, current)\n    )\n  );\n}\nasync function parseObjectAsync(ctx, depth, id, current) {\n  if (Array.isArray(current)) {\n    return parseArray(ctx, depth, id, current);\n  }\n  if (isStream(current)) {\n    return parseStream(ctx, depth, id, current);\n  }\n  const currentClass = current.constructor;\n  if (currentClass === OpaqueReference) {\n    return parseAsync(\n      ctx,\n      depth,\n      current.replacement\n    );\n  }\n  const parsed = await parsePlugin(ctx, depth, id, current);\n  if (parsed) {\n    return parsed;\n  }\n  switch (currentClass) {\n    case Object:\n      return parsePlainObject(\n        ctx,\n        depth,\n        id,\n        current,\n        false\n      );\n    case NIL:\n      return parsePlainObject(\n        ctx,\n        depth,\n        id,\n        current,\n        true\n      );\n    case Date:\n      return createDateNode(id, current);\n    case Error:\n    case EvalError:\n    case RangeError:\n    case ReferenceError:\n    case SyntaxError:\n    case TypeError:\n    case URIError:\n      return parseError(ctx, depth, id, current);\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n      return parseBoxed(ctx, depth, id, current);\n    case ArrayBuffer:\n      return createArrayBufferNode(\n        ctx.base,\n        id,\n        current\n      );\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n      return parseTypedArray(\n        ctx,\n        depth,\n        id,\n        current\n      );\n    case DataView:\n      return parseDataView(ctx, depth, id, current);\n    case Map:\n      return parseMap(\n        ctx,\n        depth,\n        id,\n        current\n      );\n    case Set:\n      return parseSet(ctx, depth, id, current);\n    default:\n      break;\n  }\n  if (currentClass === Promise || current instanceof Promise) {\n    return parsePromise(ctx, depth, id, current);\n  }\n  const currentFeatures = ctx.base.features;\n  if (currentFeatures & 32 /* RegExp */ && currentClass === RegExp) {\n    return createRegExpNode(id, current);\n  }\n  if (currentFeatures & 16 /* BigIntTypedArray */) {\n    switch (currentClass) {\n      case BigInt64Array:\n      case BigUint64Array:\n        return parseBigIntTypedArray(\n          ctx,\n          depth,\n          id,\n          current\n        );\n      default:\n        break;\n    }\n  }\n  if (currentFeatures & 1 /* AggregateError */ && typeof AggregateError !== \"undefined\" && (currentClass === AggregateError || current instanceof AggregateError)) {\n    return parseAggregateError(\n      ctx,\n      depth,\n      id,\n      current\n    );\n  }\n  if (current instanceof Error) {\n    return parseError(ctx, depth, id, current);\n  }\n  if (SYM_ITERATOR in current || SYM_ASYNC_ITERATOR in current) {\n    return parsePlainObject(ctx, depth, id, current, !!currentClass);\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\nasync function parseFunctionAsync(ctx, depth, current) {\n  const ref = getReferenceNode(ctx.base, current);\n  if (ref.type !== 0 /* Fresh */) {\n    return ref.value;\n  }\n  const plugin = await parsePlugin(ctx, depth, ref.value, current);\n  if (plugin) {\n    return plugin;\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\nasync function parseAsync(ctx, depth, current) {\n  switch (typeof current) {\n    case \"boolean\":\n      return current ? TRUE_NODE : FALSE_NODE;\n    case \"undefined\":\n      return UNDEFINED_NODE;\n    case \"string\":\n      return createStringNode(current);\n    case \"number\":\n      return createNumberNode(current);\n    case \"bigint\":\n      return createBigIntNode(current);\n    case \"object\": {\n      if (current) {\n        const ref = getReferenceNode(ctx.base, current);\n        return ref.type === 0 ? await parseObjectAsync(ctx, depth + 1, ref.value, current) : ref.value;\n      }\n      return NULL_NODE;\n    }\n    case \"symbol\":\n      return parseWellKnownSymbol(ctx.base, current);\n    case \"function\":\n      return parseFunctionAsync(ctx, depth, current);\n    default:\n      throw new SerovalUnsupportedTypeError(current);\n  }\n}\nasync function parseTopAsync(ctx, current) {\n  try {\n    return await parseAsync(ctx, 0, current);\n  } catch (error) {\n    throw error instanceof SerovalParserError ? error : new SerovalParserError(error);\n  }\n}\n\n// src/core/plugin.ts\nvar SerovalMode = /* @__PURE__ */ ((SerovalMode2) => {\n  SerovalMode2[SerovalMode2[\"Vanilla\"] = 1] = \"Vanilla\";\n  SerovalMode2[SerovalMode2[\"Cross\"] = 2] = \"Cross\";\n  return SerovalMode2;\n})(SerovalMode || {});\nfunction createPlugin(plugin) {\n  return plugin;\n}\nfunction dedupePlugins(deduped, plugins) {\n  for (let i = 0, len = plugins.length; i < len; i++) {\n    const current = plugins[i];\n    if (!deduped.has(current)) {\n      deduped.add(current);\n      if (current.extends) {\n        dedupePlugins(deduped, current.extends);\n      }\n    }\n  }\n}\nfunction resolvePlugins(plugins) {\n  if (plugins) {\n    const deduped = /* @__PURE__ */ new Set();\n    dedupePlugins(deduped, plugins);\n    return [...deduped];\n  }\n  return void 0;\n}\n\n// src/core/utils/typed-array.ts\nfunction getTypedArrayConstructor(name) {\n  switch (name) {\n    case \"Int8Array\":\n      return Int8Array;\n    case \"Int16Array\":\n      return Int16Array;\n    case \"Int32Array\":\n      return Int32Array;\n    case \"Uint8Array\":\n      return Uint8Array;\n    case \"Uint16Array\":\n      return Uint16Array;\n    case \"Uint32Array\":\n      return Uint32Array;\n    case \"Uint8ClampedArray\":\n      return Uint8ClampedArray;\n    case \"Float32Array\":\n      return Float32Array;\n    case \"Float64Array\":\n      return Float64Array;\n    case \"BigInt64Array\":\n      return BigInt64Array;\n    case \"BigUint64Array\":\n      return BigUint64Array;\n    default:\n      throw new SerovalUnknownTypedArrayError(name);\n  }\n}\n\n// src/core/context/deserializer.ts\nvar MAX_BASE64_LENGTH = 1e6;\nvar MAX_BIGINT_LENGTH = 1e4;\nvar MAX_REGEXP_SOURCE_LENGTH = 2e4;\nfunction applyObjectFlag(obj, flag) {\n  switch (flag) {\n    case 3 /* Frozen */:\n      return Object.freeze(obj);\n    case 1 /* NonExtensible */:\n      return Object.preventExtensions(obj);\n    case 2 /* Sealed */:\n      return Object.seal(obj);\n    default:\n      return obj;\n  }\n}\nvar DEFAULT_DEPTH_LIMIT = 1e3;\nfunction createBaseDeserializerContext(mode, options) {\n  var _a;\n  return {\n    mode,\n    plugins: options.plugins,\n    refs: options.refs || /* @__PURE__ */ new Map(),\n    features: (_a = options.features) != null ? _a : ALL_ENABLED ^ (options.disabledFeatures || 0),\n    depthLimit: options.depthLimit || DEFAULT_DEPTH_LIMIT\n  };\n}\nfunction createVanillaDeserializerContext(options) {\n  return {\n    mode: 1 /* Vanilla */,\n    base: createBaseDeserializerContext(1 /* Vanilla */, options),\n    child: NIL,\n    state: {\n      marked: new Set(options.markedRefs)\n    }\n  };\n}\nfunction createCrossDeserializerContext(options) {\n  return {\n    mode: 2 /* Cross */,\n    base: createBaseDeserializerContext(2 /* Cross */, options),\n    child: NIL\n  };\n}\nvar DeserializePluginContext = class {\n  constructor(_p, depth) {\n    this._p = _p;\n    this.depth = depth;\n  }\n  deserialize(node) {\n    return deserialize(this._p, this.depth, node);\n  }\n};\nfunction guardIndexedValue(ctx, id) {\n  if (id < 0 || !Number.isFinite(id) || !Number.isInteger(id)) {\n    throw new SerovalMalformedNodeError({\n      t: 4 /* IndexedValue */,\n      i: id\n    });\n  }\n  if (ctx.refs.has(id)) {\n    throw new Error(\"Conflicted ref id: \" + id);\n  }\n}\nfunction assignIndexedValueVanilla(ctx, id, value) {\n  guardIndexedValue(ctx.base, id);\n  if (ctx.state.marked.has(id)) {\n    ctx.base.refs.set(id, value);\n  }\n  return value;\n}\nfunction assignIndexedValueCross(ctx, id, value) {\n  guardIndexedValue(ctx.base, id);\n  ctx.base.refs.set(id, value);\n  return value;\n}\nfunction assignIndexedValue(ctx, id, value) {\n  return ctx.mode === 1 /* Vanilla */ ? assignIndexedValueVanilla(ctx, id, value) : assignIndexedValueCross(ctx, id, value);\n}\nfunction deserializeKnownValue(node, record, key) {\n  if (Object.hasOwn(record, key)) {\n    return record[key];\n  }\n  throw new SerovalMalformedNodeError(node);\n}\nfunction deserializeReference(ctx, node) {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    getReference(deserializeString(node.s))\n  );\n}\nfunction deserializeArray(ctx, depth, node) {\n  const items = node.a;\n  const len = items.length;\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new Array(len)\n  );\n  for (let i = 0, item; i < len; i++) {\n    item = items[i];\n    if (item) {\n      result[i] = deserialize(ctx, depth, item);\n    }\n  }\n  applyObjectFlag(result, node.o);\n  return result;\n}\nfunction isValidKey(key) {\n  switch (key) {\n    case \"constructor\":\n    case \"__proto__\":\n    case \"prototype\":\n    case \"__defineGetter__\":\n    case \"__defineSetter__\":\n    case \"__lookupGetter__\":\n    case \"__lookupSetter__\":\n      return false;\n    default:\n      return true;\n  }\n}\nfunction isValidSymbol(symbol) {\n  switch (symbol) {\n    case SYM_ASYNC_ITERATOR:\n    case SYM_IS_CONCAT_SPREADABLE:\n    case SYM_TO_STRING_TAG:\n    case SYM_ITERATOR:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction assignStringProperty(object, key, value) {\n  if (isValidKey(key)) {\n    object[key] = value;\n  } else {\n    Object.defineProperty(object, key, {\n      value,\n      configurable: true,\n      enumerable: true,\n      writable: true\n    });\n  }\n}\nfunction assignProperty(ctx, depth, object, key, value) {\n  if (typeof key === \"string\") {\n    assignStringProperty(object, key, deserialize(ctx, depth, value));\n  } else {\n    const actual = deserialize(ctx, depth, key);\n    switch (typeof actual) {\n      case \"string\":\n        assignStringProperty(object, actual, deserialize(ctx, depth, value));\n        break;\n      case \"symbol\":\n        if (isValidSymbol(actual)) {\n          object[actual] = deserialize(ctx, depth, value);\n        }\n        break;\n      default:\n        throw new SerovalMalformedNodeError(key);\n    }\n  }\n}\nfunction deserializeProperties(ctx, depth, node, result) {\n  const keys = node.k;\n  const len = keys.length;\n  if (len > 0) {\n    for (let i = 0, vals = node.v, len2 = keys.length; i < len2; i++) {\n      assignProperty(ctx, depth, result, keys[i], vals[i]);\n    }\n  }\n  return result;\n}\nfunction deserializeObject(ctx, depth, node) {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    node.t === 10 /* Object */ ? {} : /* @__PURE__ */ Object.create(null)\n  );\n  deserializeProperties(ctx, depth, node.p, result);\n  applyObjectFlag(result, node.o);\n  return result;\n}\nfunction deserializeDate(ctx, node) {\n  return assignIndexedValue(ctx, node.i, new Date(node.s));\n}\nfunction deserializeRegExp(ctx, node) {\n  if (ctx.base.features & 32 /* RegExp */) {\n    const source = deserializeString(node.c);\n    if (source.length > MAX_REGEXP_SOURCE_LENGTH) {\n      throw new SerovalMalformedNodeError(node);\n    }\n    return assignIndexedValue(ctx, node.i, new RegExp(source, node.m));\n  }\n  throw new SerovalUnsupportedNodeError(node);\n}\nfunction deserializeSet(ctx, depth, node) {\n  const result = assignIndexedValue(ctx, node.i, /* @__PURE__ */ new Set());\n  for (let i = 0, items = node.a, len = items.length; i < len; i++) {\n    result.add(deserialize(ctx, depth, items[i]));\n  }\n  return result;\n}\nfunction deserializeMap(ctx, depth, node) {\n  const result = assignIndexedValue(ctx, node.i, /* @__PURE__ */ new Map());\n  for (let i = 0, keys = node.e.k, vals = node.e.v, len = keys.length; i < len; i++) {\n    result.set(\n      deserialize(ctx, depth, keys[i]),\n      deserialize(ctx, depth, vals[i])\n    );\n  }\n  return result;\n}\nfunction deserializeArrayBuffer(ctx, node) {\n  if (node.s.length > MAX_BASE64_LENGTH) {\n    throw new SerovalMalformedNodeError(node);\n  }\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    ARRAY_BUFFER_CONSTRUCTOR(deserializeString(node.s))\n  );\n  return result;\n}\nfunction deserializeTypedArray(ctx, depth, node) {\n  var _a;\n  const construct = getTypedArrayConstructor(node.c);\n  const source = deserialize(ctx, depth, node.f);\n  const offset = (_a = node.b) != null ? _a : 0;\n  if (offset < 0 || offset > source.byteLength) {\n    throw new SerovalMalformedNodeError(node);\n  }\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new construct(source, offset, node.l)\n  );\n  return result;\n}\nfunction deserializeDataView(ctx, depth, node) {\n  var _a;\n  const source = deserialize(ctx, depth, node.f);\n  const offset = (_a = node.b) != null ? _a : 0;\n  if (offset < 0 || offset > source.byteLength) {\n    throw new SerovalMalformedNodeError(node);\n  }\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new DataView(source, offset, node.l)\n  );\n  return result;\n}\nfunction deserializeDictionary(ctx, depth, node, result) {\n  if (node.p) {\n    const fields = deserializeProperties(ctx, depth, node.p, {});\n    Object.defineProperties(result, Object.getOwnPropertyDescriptors(fields));\n  }\n  return result;\n}\nfunction deserializeAggregateError(ctx, depth, node) {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new AggregateError([], deserializeString(node.m))\n  );\n  return deserializeDictionary(ctx, depth, node, result);\n}\nfunction deserializeError(ctx, depth, node) {\n  const construct = deserializeKnownValue(node, ERROR_CONSTRUCTOR, node.s);\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new construct(deserializeString(node.m))\n  );\n  return deserializeDictionary(ctx, depth, node, result);\n}\nfunction deserializePromise(ctx, depth, node) {\n  const deferred = PROMISE_CONSTRUCTOR();\n  const result = assignIndexedValue(ctx, node.i, deferred.p);\n  const deserialized = deserialize(ctx, depth, node.f);\n  if (node.s) {\n    deferred.s(deserialized);\n  } else {\n    deferred.f(deserialized);\n  }\n  return result;\n}\nfunction deserializeBoxed(ctx, depth, node) {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    // biome-ignore lint/style/useConsistentBuiltinInstantiation: intended\n    Object(deserialize(ctx, depth, node.f))\n  );\n}\nfunction deserializePlugin(ctx, depth, node) {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    const tag = deserializeString(node.c);\n    for (let i = 0, len = currentPlugins.length; i < len; i++) {\n      const plugin = currentPlugins[i];\n      if (plugin.tag === tag) {\n        return assignIndexedValue(\n          ctx,\n          node.i,\n          plugin.deserialize(node.s, new DeserializePluginContext(ctx, depth), {\n            id: node.i\n          })\n        );\n      }\n    }\n  }\n  throw new SerovalMissingPluginError(node.c);\n}\nfunction deserializePromiseConstructor(ctx, node) {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    assignIndexedValue(ctx, node.s, PROMISE_CONSTRUCTOR()).p\n  );\n}\nfunction deserializePromiseResolve(ctx, depth, node) {\n  const deferred = ctx.base.refs.get(node.i);\n  if (deferred) {\n    deferred.s(deserialize(ctx, depth, node.a[1]));\n    return NIL;\n  }\n  throw new SerovalMissingInstanceError(\"Promise\");\n}\nfunction deserializePromiseReject(ctx, depth, node) {\n  const deferred = ctx.base.refs.get(node.i);\n  if (deferred) {\n    deferred.f(deserialize(ctx, depth, node.a[1]));\n    return NIL;\n  }\n  throw new SerovalMissingInstanceError(\"Promise\");\n}\nfunction deserializeIteratorFactoryInstance(ctx, depth, node) {\n  deserialize(ctx, depth, node.a[0]);\n  const source = deserialize(ctx, depth, node.a[1]);\n  return sequenceToIterator(source);\n}\nfunction deserializeAsyncIteratorFactoryInstance(ctx, depth, node) {\n  deserialize(ctx, depth, node.a[0]);\n  const source = deserialize(ctx, depth, node.a[1]);\n  return streamToAsyncIterable(source);\n}\nfunction deserializeStreamConstructor(ctx, depth, node) {\n  const result = assignIndexedValue(ctx, node.i, createStream());\n  const items = node.a;\n  const len = items.length;\n  if (len) {\n    for (let i = 0; i < len; i++) {\n      deserialize(ctx, depth, items[i]);\n    }\n  }\n  return result;\n}\nfunction deserializeStreamNext(ctx, depth, node) {\n  const deferred = ctx.base.refs.get(node.i);\n  if (deferred && isStream(deferred)) {\n    deferred.next(deserialize(ctx, depth, node.f));\n    return NIL;\n  }\n  throw new SerovalMissingInstanceError(\"Stream\");\n}\nfunction deserializeStreamThrow(ctx, depth, node) {\n  const deferred = ctx.base.refs.get(node.i);\n  if (deferred && isStream(deferred)) {\n    deferred.throw(deserialize(ctx, depth, node.f));\n    return NIL;\n  }\n  throw new SerovalMissingInstanceError(\"Stream\");\n}\nfunction deserializeStreamReturn(ctx, depth, node) {\n  const deferred = ctx.base.refs.get(node.i);\n  if (deferred && isStream(deferred)) {\n    deferred.return(deserialize(ctx, depth, node.f));\n    return NIL;\n  }\n  throw new SerovalMissingInstanceError(\"Stream\");\n}\nfunction deserializeIteratorFactory(ctx, depth, node) {\n  deserialize(ctx, depth, node.f);\n  return NIL;\n}\nfunction deserializeAsyncIteratorFactory(ctx, depth, node) {\n  deserialize(ctx, depth, node.a[1]);\n  return NIL;\n}\nfunction deserialize(ctx, depth, node) {\n  if (depth > ctx.base.depthLimit) {\n    throw new SerovalDepthLimitError(ctx.base.depthLimit);\n  }\n  depth += 1;\n  switch (node.t) {\n    case 2 /* Constant */:\n      return deserializeKnownValue(node, CONSTANT_VAL, node.s);\n    case 0 /* Number */:\n      return Number(node.s);\n    case 1 /* String */:\n      return deserializeString(String(node.s));\n    case 3 /* BigInt */:\n      if (String(node.s).length > MAX_BIGINT_LENGTH) {\n        throw new SerovalMalformedNodeError(node);\n      }\n      return BigInt(node.s);\n    case 4 /* IndexedValue */:\n      return ctx.base.refs.get(node.i);\n    case 18 /* Reference */:\n      return deserializeReference(ctx, node);\n    case 9 /* Array */:\n      return deserializeArray(ctx, depth, node);\n    case 10 /* Object */:\n    case 11 /* NullConstructor */:\n      return deserializeObject(ctx, depth, node);\n    case 5 /* Date */:\n      return deserializeDate(ctx, node);\n    case 6 /* RegExp */:\n      return deserializeRegExp(ctx, node);\n    case 7 /* Set */:\n      return deserializeSet(ctx, depth, node);\n    case 8 /* Map */:\n      return deserializeMap(ctx, depth, node);\n    case 19 /* ArrayBuffer */:\n      return deserializeArrayBuffer(ctx, node);\n    case 16 /* BigIntTypedArray */:\n    case 15 /* TypedArray */:\n      return deserializeTypedArray(ctx, depth, node);\n    case 20 /* DataView */:\n      return deserializeDataView(ctx, depth, node);\n    case 14 /* AggregateError */:\n      return deserializeAggregateError(ctx, depth, node);\n    case 13 /* Error */:\n      return deserializeError(ctx, depth, node);\n    case 12 /* Promise */:\n      return deserializePromise(ctx, depth, node);\n    case 17 /* WKSymbol */:\n      return deserializeKnownValue(node, SYMBOL_REF, node.s);\n    case 21 /* Boxed */:\n      return deserializeBoxed(ctx, depth, node);\n    case 25 /* Plugin */:\n      return deserializePlugin(ctx, depth, node);\n    case 22 /* PromiseConstructor */:\n      return deserializePromiseConstructor(ctx, node);\n    case 23 /* PromiseSuccess */:\n      return deserializePromiseResolve(ctx, depth, node);\n    case 24 /* PromiseFailure */:\n      return deserializePromiseReject(ctx, depth, node);\n    case 28 /* IteratorFactoryInstance */:\n      return deserializeIteratorFactoryInstance(ctx, depth, node);\n    case 30 /* AsyncIteratorFactoryInstance */:\n      return deserializeAsyncIteratorFactoryInstance(ctx, depth, node);\n    case 31 /* StreamConstructor */:\n      return deserializeStreamConstructor(ctx, depth, node);\n    case 32 /* StreamNext */:\n      return deserializeStreamNext(ctx, depth, node);\n    case 33 /* StreamThrow */:\n      return deserializeStreamThrow(ctx, depth, node);\n    case 34 /* StreamReturn */:\n      return deserializeStreamReturn(ctx, depth, node);\n    case 27 /* IteratorFactory */:\n      return deserializeIteratorFactory(ctx, depth, node);\n    case 29 /* AsyncIteratorFactory */:\n      return deserializeAsyncIteratorFactory(ctx, depth, node);\n    // case SerovalNodeType.SpecialReference:\n    default:\n      throw new SerovalUnsupportedNodeError(node);\n  }\n}\nfunction deserializeTop(ctx, node) {\n  try {\n    return deserialize(ctx, 0, node);\n  } catch (error) {\n    throw new SerovalDeserializationError(error);\n  }\n}\n\n// src/core/function-string.ts\nvar RETURN = () => T;\nvar SERIALIZED_RETURN = /* @__PURE__ */ RETURN.toString();\nvar IS_MODERN = /* @__PURE__ */ /=>/.test(SERIALIZED_RETURN);\nfunction createFunction(parameters, body) {\n  if (IS_MODERN) {\n    const joined = parameters.length === 1 ? parameters[0] : \"(\" + parameters.join(\",\") + \")\";\n    return joined + \"=>\" + (body.startsWith(\"{\") ? \"(\" + body + \")\" : body);\n  }\n  return \"function(\" + parameters.join(\",\") + \"){return \" + body + \"}\";\n}\nfunction createEffectfulFunction(parameters, body) {\n  if (IS_MODERN) {\n    const joined = parameters.length === 1 ? parameters[0] : \"(\" + parameters.join(\",\") + \")\";\n    return joined + \"=>{\" + body + \"}\";\n  }\n  return \"function(\" + parameters.join(\",\") + \"){\" + body + \"}\";\n}\n\n// src/core/utils/get-identifier.ts\nvar REF_START_CHARS = \"hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_\";\nvar REF_START_CHARS_LEN = REF_START_CHARS.length;\nvar REF_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_\";\nvar REF_CHARS_LEN = REF_CHARS.length;\nfunction getIdentifier(index) {\n  let mod = index % REF_START_CHARS_LEN;\n  let ref = REF_START_CHARS[mod];\n  index = (index - mod) / REF_START_CHARS_LEN;\n  while (index > 0) {\n    mod = index % REF_CHARS_LEN;\n    ref += REF_CHARS[mod];\n    index = (index - mod) / REF_CHARS_LEN;\n  }\n  return ref;\n}\n\n// src/core/utils/is-valid-identifier.ts\nvar IDENTIFIER_CHECK = /^[$A-Z_][0-9A-Z_$]*$/i;\nfunction isValidIdentifier(name) {\n  const char = name[0];\n  return (char === \"$\" || char === \"_\" || char >= \"A\" && char <= \"Z\" || char >= \"a\" && char <= \"z\") && IDENTIFIER_CHECK.test(name);\n}\n\n// src/core/context/serializer.ts\nfunction getAssignmentExpression(assignment) {\n  switch (assignment.t) {\n    case 0 /* Index */:\n      return assignment.s + \"=\" + assignment.v;\n    case 2 /* Set */:\n      return assignment.s + \".set(\" + assignment.k + \",\" + assignment.v + \")\";\n    case 1 /* Add */:\n      return assignment.s + \".add(\" + assignment.v + \")\";\n    case 3 /* Delete */:\n      return assignment.s + \".delete(\" + assignment.k + \")\";\n  }\n}\nfunction mergeAssignments(assignments) {\n  const newAssignments = [];\n  let current = assignments[0];\n  for (let i = 1, len = assignments.length, item, prev = current; i < len; i++) {\n    item = assignments[i];\n    if (item.t === 0 /* Index */ && item.v === prev.v) {\n      current = {\n        t: 0 /* Index */,\n        s: item.s,\n        k: NIL,\n        v: getAssignmentExpression(current)\n      };\n    } else if (item.t === 2 /* Set */ && item.s === prev.s) {\n      current = {\n        t: 2 /* Set */,\n        s: getAssignmentExpression(current),\n        k: item.k,\n        v: item.v\n      };\n    } else if (item.t === 1 /* Add */ && item.s === prev.s) {\n      current = {\n        t: 1 /* Add */,\n        s: getAssignmentExpression(current),\n        k: NIL,\n        v: item.v\n      };\n    } else if (item.t === 3 /* Delete */ && item.s === prev.s) {\n      current = {\n        t: 3 /* Delete */,\n        s: getAssignmentExpression(current),\n        k: item.k,\n        v: NIL\n      };\n    } else {\n      newAssignments.push(current);\n      current = item;\n    }\n    prev = item;\n  }\n  newAssignments.push(current);\n  return newAssignments;\n}\nfunction resolveAssignments(assignments) {\n  if (assignments.length) {\n    let result = \"\";\n    const merged = mergeAssignments(assignments);\n    for (let i = 0, len = merged.length; i < len; i++) {\n      result += getAssignmentExpression(merged[i]) + \",\";\n    }\n    return result;\n  }\n  return NIL;\n}\nvar NULL_CONSTRUCTOR = \"Object.create(null)\";\nvar SET_CONSTRUCTOR = \"new Set\";\nvar MAP_CONSTRUCTOR = \"new Map\";\nvar PROMISE_RESOLVE = \"Promise.resolve\";\nvar PROMISE_REJECT = \"Promise.reject\";\nvar OBJECT_FLAG_CONSTRUCTOR = {\n  [3 /* Frozen */]: \"Object.freeze\",\n  [2 /* Sealed */]: \"Object.seal\",\n  [1 /* NonExtensible */]: \"Object.preventExtensions\",\n  [0 /* None */]: NIL\n};\nfunction createBaseSerializerContext(mode, options) {\n  return {\n    mode,\n    plugins: options.plugins,\n    features: options.features,\n    marked: new Set(options.markedRefs),\n    stack: [],\n    flags: [],\n    assignments: []\n  };\n}\nfunction createVanillaSerializerState() {\n  return {\n    valid: /* @__PURE__ */ new Map(),\n    vars: []\n  };\n}\nfunction createVanillaSerializerContext(options) {\n  return {\n    mode: 1 /* Vanilla */,\n    base: createBaseSerializerContext(1 /* Vanilla */, options),\n    state: createVanillaSerializerState(),\n    child: NIL\n  };\n}\nfunction createCrossSerializerContext(options) {\n  return {\n    mode: 2 /* Cross */,\n    base: createBaseSerializerContext(2 /* Cross */, options),\n    state: options,\n    child: NIL\n  };\n}\nvar SerializePluginContext = class {\n  constructor(_p) {\n    this._p = _p;\n  }\n  serialize(node) {\n    return serialize(this._p, node);\n  }\n};\nfunction getVanillaRefParam(state, index) {\n  let actualIndex = state.valid.get(index);\n  if (actualIndex == null) {\n    actualIndex = state.valid.size;\n    state.valid.set(index, actualIndex);\n  }\n  let identifier = state.vars[actualIndex];\n  if (identifier == null) {\n    identifier = getIdentifier(actualIndex);\n    state.vars[actualIndex] = identifier;\n  }\n  return identifier;\n}\nfunction getCrossRefParam(id) {\n  return GLOBAL_CONTEXT_REFERENCES + \"[\" + id + \"]\";\n}\nfunction getRefParam(ctx, id) {\n  return ctx.mode === 1 /* Vanilla */ ? getVanillaRefParam(ctx.state, id) : getCrossRefParam(id);\n}\nfunction markSerializerRef(ctx, id) {\n  ctx.marked.add(id);\n}\nfunction isSerializerRefMarked(ctx, id) {\n  return ctx.marked.has(id);\n}\nfunction pushObjectFlag(ctx, flag, id) {\n  if (flag !== 0 /* None */) {\n    markSerializerRef(ctx.base, id);\n    ctx.base.flags.push({\n      type: flag,\n      value: getRefParam(ctx, id)\n    });\n  }\n}\nfunction resolveFlags(ctx) {\n  let result = \"\";\n  for (let i = 0, current = ctx.flags, len = current.length; i < len; i++) {\n    const flag = current[i];\n    result += OBJECT_FLAG_CONSTRUCTOR[flag.type] + \"(\" + flag.value + \"),\";\n  }\n  return result;\n}\nfunction resolvePatches(ctx) {\n  const assignments = resolveAssignments(ctx.assignments);\n  const flags = resolveFlags(ctx);\n  if (assignments) {\n    if (flags) {\n      return assignments + flags;\n    }\n    return assignments;\n  }\n  return flags;\n}\nfunction createAssignment(ctx, source, value) {\n  ctx.assignments.push({\n    t: 0 /* Index */,\n    s: source,\n    k: NIL,\n    v: value\n  });\n}\nfunction createAddAssignment(ctx, ref, value) {\n  ctx.base.assignments.push({\n    t: 1 /* Add */,\n    s: getRefParam(ctx, ref),\n    k: NIL,\n    v: value\n  });\n}\nfunction createSetAssignment(ctx, ref, key, value) {\n  ctx.base.assignments.push({\n    t: 2 /* Set */,\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: value\n  });\n}\nfunction createDeleteAssignment(ctx, ref, key) {\n  ctx.base.assignments.push({\n    t: 3 /* Delete */,\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: NIL\n  });\n}\nfunction createArrayAssign(ctx, ref, index, value) {\n  createAssignment(ctx.base, getRefParam(ctx, ref) + \"[\" + index + \"]\", value);\n}\nfunction createObjectAssign(ctx, ref, key, value) {\n  createAssignment(ctx.base, getRefParam(ctx, ref) + \".\" + key, value);\n}\nfunction isIndexedValueInStack(ctx, node) {\n  return node.t === 4 /* IndexedValue */ && ctx.stack.includes(node.i);\n}\nfunction assignIndexedValue2(ctx, index, value) {\n  if (ctx.mode === 1 /* Vanilla */ && !isSerializerRefMarked(ctx.base, index)) {\n    return value;\n  }\n  return getRefParam(ctx, index) + \"=\" + value;\n}\nfunction serializeReference(node) {\n  return REFERENCES_KEY + '.get(\"' + node.s + '\")';\n}\nfunction serializeArrayItem(ctx, id, item, index) {\n  if (item) {\n    if (isIndexedValueInStack(ctx.base, item)) {\n      markSerializerRef(ctx.base, id);\n      createArrayAssign(\n        ctx,\n        id,\n        index,\n        getRefParam(ctx, item.i)\n      );\n      return \"\";\n    }\n    return serialize(ctx, item);\n  }\n  return \"\";\n}\nfunction serializeArray(ctx, node) {\n  const id = node.i;\n  const list = node.a;\n  const len = list.length;\n  if (len > 0) {\n    ctx.base.stack.push(id);\n    let values = serializeArrayItem(ctx, id, list[0], 0);\n    let isHoley = values === \"\";\n    for (let i = 1, item; i < len; i++) {\n      item = serializeArrayItem(ctx, id, list[i], i);\n      values += \",\" + item;\n      isHoley = item === \"\";\n    }\n    ctx.base.stack.pop();\n    pushObjectFlag(ctx, node.o, node.i);\n    return \"[\" + values + (isHoley ? \",]\" : \"]\");\n  }\n  return \"[]\";\n}\nfunction serializeProperty(ctx, source, key, val) {\n  if (typeof key === \"string\") {\n    const check = Number(key);\n    const isIdentifier = (\n      // Test if key is a valid positive number or JS identifier\n      // so that we don't have to serialize the key and wrap with brackets\n      check >= 0 && // It's also important to consider that if the key is\n      // indeed numeric, we need to make sure that when\n      // converted back into a string, it's still the same\n      // to the original key. This allows us to differentiate\n      // keys that has numeric formats but in a different\n      // format, which can cause unintentional key declaration\n      // Example: { 0x1: 1 } vs { '0x1': 1 }\n      check.toString() === key || isValidIdentifier(key)\n    );\n    if (isIndexedValueInStack(ctx.base, val)) {\n      const refParam = getRefParam(ctx, val.i);\n      markSerializerRef(ctx.base, source.i);\n      if (isIdentifier && check !== check) {\n        createObjectAssign(ctx, source.i, key, refParam);\n      } else {\n        createArrayAssign(\n          ctx,\n          source.i,\n          isIdentifier ? key : '\"' + key + '\"',\n          refParam\n        );\n      }\n      return \"\";\n    }\n    return (isIdentifier ? key : '\"' + key + '\"') + \":\" + serialize(ctx, val);\n  }\n  return \"[\" + serialize(ctx, key) + \"]:\" + serialize(ctx, val);\n}\nfunction serializeProperties(ctx, source, record) {\n  const keys = record.k;\n  const len = keys.length;\n  if (len > 0) {\n    const values = record.v;\n    ctx.base.stack.push(source.i);\n    let result = serializeProperty(ctx, source, keys[0], values[0]);\n    for (let i = 1, item = result; i < len; i++) {\n      item = serializeProperty(ctx, source, keys[i], values[i]);\n      result += (item && result && \",\") + item;\n    }\n    ctx.base.stack.pop();\n    return \"{\" + result + \"}\";\n  }\n  return \"{}\";\n}\nfunction serializeObject(ctx, node) {\n  pushObjectFlag(ctx, node.o, node.i);\n  return serializeProperties(ctx, node, node.p);\n}\nfunction serializeWithObjectAssign(ctx, source, value, serialized) {\n  const fields = serializeProperties(ctx, source, value);\n  if (fields !== \"{}\") {\n    return \"Object.assign(\" + serialized + \",\" + fields + \")\";\n  }\n  return serialized;\n}\nfunction serializeStringKeyAssignment(ctx, source, mainAssignments, key, value) {\n  const base = ctx.base;\n  const serialized = serialize(ctx, value);\n  const check = Number(key);\n  const isIdentifier = (\n    // Test if key is a valid positive number or JS identifier\n    // so that we don't have to serialize the key and wrap with brackets\n    check >= 0 && // It's also important to consider that if the key is\n    // indeed numeric, we need to make sure that when\n    // converted back into a string, it's still the same\n    // to the original key. This allows us to differentiate\n    // keys that has numeric formats but in a different\n    // format, which can cause unintentional key declaration\n    // Example: { 0x1: 1 } vs { '0x1': 1 }\n    check.toString() === key || isValidIdentifier(key)\n  );\n  if (isIndexedValueInStack(base, value)) {\n    if (isIdentifier && check !== check) {\n      createObjectAssign(ctx, source.i, key, serialized);\n    } else {\n      createArrayAssign(\n        ctx,\n        source.i,\n        isIdentifier ? key : '\"' + key + '\"',\n        serialized\n      );\n    }\n  } else {\n    const parentAssignment = base.assignments;\n    base.assignments = mainAssignments;\n    if (isIdentifier && check !== check) {\n      createObjectAssign(ctx, source.i, key, serialized);\n    } else {\n      createArrayAssign(\n        ctx,\n        source.i,\n        isIdentifier ? key : '\"' + key + '\"',\n        serialized\n      );\n    }\n    base.assignments = parentAssignment;\n  }\n}\nfunction serializeAssignment(ctx, source, mainAssignments, key, value) {\n  if (typeof key === \"string\") {\n    serializeStringKeyAssignment(ctx, source, mainAssignments, key, value);\n  } else {\n    const base = ctx.base;\n    const parent = base.stack;\n    base.stack = [];\n    const serialized = serialize(ctx, value);\n    base.stack = parent;\n    const parentAssignment = base.assignments;\n    base.assignments = mainAssignments;\n    createArrayAssign(ctx, source.i, serialize(ctx, key), serialized);\n    base.assignments = parentAssignment;\n  }\n}\nfunction serializeAssignments(ctx, source, node) {\n  const keys = node.k;\n  const len = keys.length;\n  if (len > 0) {\n    const mainAssignments = [];\n    const values = node.v;\n    ctx.base.stack.push(source.i);\n    for (let i = 0; i < len; i++) {\n      serializeAssignment(ctx, source, mainAssignments, keys[i], values[i]);\n    }\n    ctx.base.stack.pop();\n    return resolveAssignments(mainAssignments);\n  }\n  return NIL;\n}\nfunction serializeDictionary(ctx, node, init) {\n  if (node.p) {\n    const base = ctx.base;\n    if (base.features & 8 /* ObjectAssign */) {\n      init = serializeWithObjectAssign(ctx, node, node.p, init);\n    } else {\n      markSerializerRef(base, node.i);\n      const assignments = serializeAssignments(ctx, node, node.p);\n      if (assignments) {\n        return \"(\" + assignIndexedValue2(ctx, node.i, init) + \",\" + assignments + getRefParam(ctx, node.i) + \")\";\n      }\n    }\n  }\n  return init;\n}\nfunction serializeNullConstructor(ctx, node) {\n  pushObjectFlag(ctx, node.o, node.i);\n  return serializeDictionary(ctx, node, NULL_CONSTRUCTOR);\n}\nfunction serializeDate(node) {\n  return 'new Date(\"' + node.s + '\")';\n}\nfunction serializeRegExp(ctx, node) {\n  if (ctx.base.features & 32 /* RegExp */) {\n    return \"/\" + node.c + \"/\" + node.m;\n  }\n  throw new SerovalUnsupportedNodeError(node);\n}\nfunction serializeSetItem(ctx, id, item) {\n  const base = ctx.base;\n  if (isIndexedValueInStack(base, item)) {\n    markSerializerRef(base, id);\n    createAddAssignment(\n      ctx,\n      id,\n      getRefParam(ctx, item.i)\n    );\n    return \"\";\n  }\n  return serialize(ctx, item);\n}\nfunction serializeSet(ctx, node) {\n  let serialized = SET_CONSTRUCTOR;\n  const items = node.a;\n  const size = items.length;\n  const id = node.i;\n  if (size > 0) {\n    ctx.base.stack.push(id);\n    let result = serializeSetItem(ctx, id, items[0]);\n    for (let i = 1, item = result; i < size; i++) {\n      item = serializeSetItem(ctx, id, items[i]);\n      result += (item && result && \",\") + item;\n    }\n    ctx.base.stack.pop();\n    if (result) {\n      serialized += \"([\" + result + \"])\";\n    }\n  }\n  return serialized;\n}\nfunction serializeMapEntry(ctx, id, key, val, sentinel) {\n  const base = ctx.base;\n  if (isIndexedValueInStack(base, key)) {\n    const keyRef = getRefParam(ctx, key.i);\n    markSerializerRef(base, id);\n    if (isIndexedValueInStack(base, val)) {\n      const valueRef = getRefParam(ctx, val.i);\n      createSetAssignment(ctx, id, keyRef, valueRef);\n      return \"\";\n    }\n    if (val.t !== 4 /* IndexedValue */ && val.i != null && isSerializerRefMarked(base, val.i)) {\n      const serialized = \"(\" + serialize(ctx, val) + \",[\" + sentinel + \",\" + sentinel + \"])\";\n      createSetAssignment(ctx, id, keyRef, getRefParam(ctx, val.i));\n      createDeleteAssignment(ctx, id, sentinel);\n      return serialized;\n    }\n    const parent = base.stack;\n    base.stack = [];\n    createSetAssignment(ctx, id, keyRef, serialize(ctx, val));\n    base.stack = parent;\n    return \"\";\n  }\n  if (isIndexedValueInStack(base, val)) {\n    const valueRef = getRefParam(ctx, val.i);\n    markSerializerRef(base, id);\n    if (key.t !== 4 /* IndexedValue */ && key.i != null && isSerializerRefMarked(base, key.i)) {\n      const serialized = \"(\" + serialize(ctx, key) + \",[\" + sentinel + \",\" + sentinel + \"])\";\n      createSetAssignment(ctx, id, getRefParam(ctx, key.i), valueRef);\n      createDeleteAssignment(ctx, id, sentinel);\n      return serialized;\n    }\n    const parent = base.stack;\n    base.stack = [];\n    createSetAssignment(ctx, id, serialize(ctx, key), valueRef);\n    base.stack = parent;\n    return \"\";\n  }\n  return \"[\" + serialize(ctx, key) + \",\" + serialize(ctx, val) + \"]\";\n}\nfunction serializeMap(ctx, node) {\n  let serialized = MAP_CONSTRUCTOR;\n  const keys = node.e.k;\n  const size = keys.length;\n  const id = node.i;\n  const sentinel = node.f;\n  const sentinelId = getRefParam(ctx, sentinel.i);\n  const base = ctx.base;\n  if (size > 0) {\n    const vals = node.e.v;\n    base.stack.push(id);\n    let result = serializeMapEntry(ctx, id, keys[0], vals[0], sentinelId);\n    for (let i = 1, item = result; i < size; i++) {\n      item = serializeMapEntry(ctx, id, keys[i], vals[i], sentinelId);\n      result += (item && result && \",\") + item;\n    }\n    base.stack.pop();\n    if (result) {\n      serialized += \"([\" + result + \"])\";\n    }\n  }\n  if (sentinel.t === 26 /* SpecialReference */) {\n    markSerializerRef(base, sentinel.i);\n    serialized = \"(\" + serialize(ctx, sentinel) + \",\" + serialized + \")\";\n  }\n  return serialized;\n}\nfunction serializeArrayBuffer(ctx, node) {\n  return getConstructor(ctx, node.f) + '(\"' + node.s + '\")';\n}\nfunction serializeTypedArray(ctx, node) {\n  return \"new \" + node.c + \"(\" + serialize(ctx, node.f) + \",\" + node.b + \",\" + node.l + \")\";\n}\nfunction serializeDataView(ctx, node) {\n  return \"new DataView(\" + serialize(ctx, node.f) + \",\" + node.b + \",\" + node.l + \")\";\n}\nfunction serializeAggregateError(ctx, node) {\n  const id = node.i;\n  ctx.base.stack.push(id);\n  const serialized = serializeDictionary(\n    ctx,\n    node,\n    'new AggregateError([],\"' + node.m + '\")'\n  );\n  ctx.base.stack.pop();\n  return serialized;\n}\nfunction serializeError(ctx, node) {\n  return serializeDictionary(\n    ctx,\n    node,\n    \"new \" + ERROR_CONSTRUCTOR_STRING[node.s] + '(\"' + node.m + '\")'\n  );\n}\nfunction serializePromise(ctx, node) {\n  let serialized;\n  const fulfilled = node.f;\n  const id = node.i;\n  const promiseConstructor = node.s ? PROMISE_RESOLVE : PROMISE_REJECT;\n  const base = ctx.base;\n  if (isIndexedValueInStack(base, fulfilled)) {\n    const ref = getRefParam(ctx, fulfilled.i);\n    serialized = promiseConstructor + (node.s ? \"().then(\" + createFunction([], ref) + \")\" : \"().catch(\" + createEffectfulFunction([], \"throw \" + ref) + \")\");\n  } else {\n    base.stack.push(id);\n    const result = serialize(ctx, fulfilled);\n    base.stack.pop();\n    serialized = promiseConstructor + \"(\" + result + \")\";\n  }\n  return serialized;\n}\nfunction serializeBoxed(ctx, node) {\n  return \"Object(\" + serialize(ctx, node.f) + \")\";\n}\nfunction getConstructor(ctx, node) {\n  const current = serialize(ctx, node);\n  return node.t === 4 /* IndexedValue */ ? current : \"(\" + current + \")\";\n}\nfunction serializePromiseConstructor(ctx, node) {\n  if (ctx.mode === 1 /* Vanilla */) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  const resolver = assignIndexedValue2(\n    ctx,\n    node.s,\n    getConstructor(ctx, node.f) + \"()\"\n  );\n  return \"(\" + resolver + \").p\";\n}\nfunction serializePromiseResolve(ctx, node) {\n  if (ctx.mode === 1 /* Vanilla */) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  return getConstructor(ctx, node.a[0]) + \"(\" + getRefParam(ctx, node.i) + \",\" + serialize(ctx, node.a[1]) + \")\";\n}\nfunction serializePromiseReject(ctx, node) {\n  if (ctx.mode === 1 /* Vanilla */) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  return getConstructor(ctx, node.a[0]) + \"(\" + getRefParam(ctx, node.i) + \",\" + serialize(ctx, node.a[1]) + \")\";\n}\nfunction serializePlugin(ctx, node) {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    for (let i = 0, len = currentPlugins.length; i < len; i++) {\n      const plugin = currentPlugins[i];\n      if (plugin.tag === node.c) {\n        if (ctx.child == null) {\n          ctx.child = new SerializePluginContext(ctx);\n        }\n        return plugin.serialize(node.s, ctx.child, {\n          id: node.i\n        });\n      }\n    }\n  }\n  throw new SerovalMissingPluginError(node.c);\n}\nfunction serializeIteratorFactory(ctx, node) {\n  let result = \"\";\n  let initialized = false;\n  if (node.f.t !== 4 /* IndexedValue */) {\n    markSerializerRef(ctx.base, node.f.i);\n    result = \"(\" + serialize(ctx, node.f) + \",\";\n    initialized = true;\n  }\n  result += assignIndexedValue2(\n    ctx,\n    node.i,\n    \"(\" + SERIALIZED_ITERATOR_CONSTRUCTOR + \")(\" + getRefParam(ctx, node.f.i) + \")\"\n  );\n  if (initialized) {\n    result += \")\";\n  }\n  return result;\n}\nfunction serializeIteratorFactoryInstance(ctx, node) {\n  return getConstructor(ctx, node.a[0]) + \"(\" + serialize(ctx, node.a[1]) + \")\";\n}\nfunction serializeAsyncIteratorFactory(ctx, node) {\n  const promise = node.a[0];\n  const symbol = node.a[1];\n  const base = ctx.base;\n  let result = \"\";\n  if (promise.t !== 4 /* IndexedValue */) {\n    markSerializerRef(base, promise.i);\n    result += \"(\" + serialize(ctx, promise);\n  }\n  if (symbol.t !== 4 /* IndexedValue */) {\n    markSerializerRef(base, symbol.i);\n    result += (result ? \",\" : \"(\") + serialize(ctx, symbol);\n  }\n  if (result) {\n    result += \",\";\n  }\n  const iterator = assignIndexedValue2(\n    ctx,\n    node.i,\n    \"(\" + SERIALIZED_ASYNC_ITERATOR_CONSTRUCTOR + \")(\" + getRefParam(ctx, symbol.i) + \",\" + getRefParam(ctx, promise.i) + \")\"\n  );\n  if (result) {\n    return result + iterator + \")\";\n  }\n  return iterator;\n}\nfunction serializeAsyncIteratorFactoryInstance(ctx, node) {\n  return getConstructor(ctx, node.a[0]) + \"(\" + serialize(ctx, node.a[1]) + \")\";\n}\nfunction serializeStreamConstructor(ctx, node) {\n  const result = assignIndexedValue2(\n    ctx,\n    node.i,\n    getConstructor(ctx, node.f) + \"()\"\n  );\n  const len = node.a.length;\n  if (len) {\n    let values = serialize(ctx, node.a[0]);\n    for (let i = 1; i < len; i++) {\n      values += \",\" + serialize(ctx, node.a[i]);\n    }\n    return \"(\" + result + \",\" + values + \",\" + getRefParam(ctx, node.i) + \")\";\n  }\n  return result;\n}\nfunction serializeStreamNext(ctx, node) {\n  return getRefParam(ctx, node.i) + \".next(\" + serialize(ctx, node.f) + \")\";\n}\nfunction serializeStreamThrow(ctx, node) {\n  return getRefParam(ctx, node.i) + \".throw(\" + serialize(ctx, node.f) + \")\";\n}\nfunction serializeStreamReturn(ctx, node) {\n  return getRefParam(ctx, node.i) + \".return(\" + serialize(ctx, node.f) + \")\";\n}\nfunction serializeAssignable(ctx, node) {\n  switch (node.t) {\n    case 17 /* WKSymbol */:\n      return SYMBOL_STRING[node.s];\n    case 18 /* Reference */:\n      return serializeReference(node);\n    case 9 /* Array */:\n      return serializeArray(ctx, node);\n    case 10 /* Object */:\n      return serializeObject(ctx, node);\n    case 11 /* NullConstructor */:\n      return serializeNullConstructor(ctx, node);\n    case 5 /* Date */:\n      return serializeDate(node);\n    case 6 /* RegExp */:\n      return serializeRegExp(ctx, node);\n    case 7 /* Set */:\n      return serializeSet(ctx, node);\n    case 8 /* Map */:\n      return serializeMap(ctx, node);\n    case 19 /* ArrayBuffer */:\n      return serializeArrayBuffer(ctx, node);\n    case 16 /* BigIntTypedArray */:\n    case 15 /* TypedArray */:\n      return serializeTypedArray(ctx, node);\n    case 20 /* DataView */:\n      return serializeDataView(ctx, node);\n    case 14 /* AggregateError */:\n      return serializeAggregateError(ctx, node);\n    case 13 /* Error */:\n      return serializeError(ctx, node);\n    case 12 /* Promise */:\n      return serializePromise(ctx, node);\n    case 21 /* Boxed */:\n      return serializeBoxed(ctx, node);\n    case 22 /* PromiseConstructor */:\n      return serializePromiseConstructor(ctx, node);\n    case 25 /* Plugin */:\n      return serializePlugin(ctx, node);\n    case 26 /* SpecialReference */:\n      return SPECIAL_REF_STRING[node.s];\n    default:\n      throw new SerovalUnsupportedNodeError(node);\n  }\n}\nfunction serialize(ctx, node) {\n  switch (node.t) {\n    case 2 /* Constant */:\n      return CONSTANT_STRING[node.s];\n    case 0 /* Number */:\n      return \"\" + node.s;\n    case 1 /* String */:\n      return '\"' + node.s + '\"';\n    case 3 /* BigInt */:\n      return node.s + \"n\";\n    case 4 /* IndexedValue */:\n      return getRefParam(ctx, node.i);\n    case 23 /* PromiseSuccess */:\n      return serializePromiseResolve(ctx, node);\n    case 24 /* PromiseFailure */:\n      return serializePromiseReject(ctx, node);\n    case 27 /* IteratorFactory */:\n      return serializeIteratorFactory(ctx, node);\n    case 28 /* IteratorFactoryInstance */:\n      return serializeIteratorFactoryInstance(ctx, node);\n    case 29 /* AsyncIteratorFactory */:\n      return serializeAsyncIteratorFactory(ctx, node);\n    case 30 /* AsyncIteratorFactoryInstance */:\n      return serializeAsyncIteratorFactoryInstance(ctx, node);\n    case 31 /* StreamConstructor */:\n      return serializeStreamConstructor(ctx, node);\n    case 32 /* StreamNext */:\n      return serializeStreamNext(ctx, node);\n    case 33 /* StreamThrow */:\n      return serializeStreamThrow(ctx, node);\n    case 34 /* StreamReturn */:\n      return serializeStreamReturn(ctx, node);\n    default:\n      return assignIndexedValue2(ctx, node.i, serializeAssignable(ctx, node));\n  }\n}\nfunction serializeTopVanilla(ctx, tree) {\n  const result = serialize(ctx, tree);\n  if (tree.i != null && ctx.state.vars.length) {\n    const patches = resolvePatches(ctx.base);\n    let body = result;\n    if (patches) {\n      const index = getRefParam(ctx, tree.i);\n      body = result + \",\" + patches + index;\n      if (!result.startsWith(index + \"=\")) {\n        body = index + \"=\" + body;\n      }\n      body = \"(\" + body + \")\";\n    }\n    return \"(\" + createFunction(ctx.state.vars, body) + \")()\";\n  }\n  if (tree.t === 10 /* Object */) {\n    return \"(\" + result + \")\";\n  }\n  return result;\n}\nfunction serializeTopCross(ctx, tree) {\n  const result = serialize(ctx, tree);\n  const id = tree.i;\n  if (id == null) {\n    return result;\n  }\n  const patches = resolvePatches(ctx.base);\n  const ref = getRefParam(ctx, id);\n  const scopeId = ctx.state.scopeId;\n  const params = scopeId == null ? \"\" : GLOBAL_CONTEXT_REFERENCES;\n  const body = patches ? \"(\" + result + \",\" + patches + ref + \")\" : result;\n  if (params === \"\") {\n    if (tree.t === 10 /* Object */ && !patches) {\n      return \"(\" + body + \")\";\n    }\n    return body;\n  }\n  const args = scopeId == null ? \"()\" : \"(\" + GLOBAL_CONTEXT_REFERENCES + '[\"' + serializeString(scopeId) + '\"])';\n  return \"(\" + createFunction([params], body) + \")\" + args;\n}\n\n// src/core/context/sync-parser.ts\nfunction createSyncParserContext(mode, options) {\n  return {\n    type: 1 /* Sync */,\n    base: createBaseParserContext(mode, options),\n    child: NIL\n  };\n}\nvar SyncParsePluginContext = class {\n  constructor(_p, depth) {\n    this._p = _p;\n    this.depth = depth;\n  }\n  parse(current) {\n    return parseSOS(this._p, this.depth, current);\n  }\n};\nvar StreamParsePluginContext = class {\n  constructor(_p, depth) {\n    this._p = _p;\n    this.depth = depth;\n  }\n  parse(current) {\n    return parseSOS(this._p, this.depth, current);\n  }\n  parseWithError(current) {\n    return parseWithError(this._p, this.depth, current);\n  }\n  isAlive() {\n    return this._p.state.alive;\n  }\n  pushPendingState() {\n    pushPendingState(this._p);\n  }\n  popPendingState() {\n    popPendingState(this._p);\n  }\n  onParse(node) {\n    onParse(this._p, node);\n  }\n  onError(error) {\n    onError(this._p, error);\n  }\n};\nfunction createStreamParserState(options) {\n  return {\n    alive: true,\n    pending: 0,\n    initial: true,\n    buffer: [],\n    onParse: options.onParse,\n    onError: options.onError,\n    onDone: options.onDone\n  };\n}\nfunction createStreamParserContext(options) {\n  return {\n    type: 2 /* Stream */,\n    base: createBaseParserContext(2 /* Cross */, options),\n    state: createStreamParserState(options)\n  };\n}\nfunction parseItems2(ctx, depth, current) {\n  const nodes = [];\n  for (let i = 0, len = current.length; i < len; i++) {\n    if (i in current) {\n      nodes[i] = parseSOS(ctx, depth, current[i]);\n    } else {\n      nodes[i] = 0;\n    }\n  }\n  return nodes;\n}\nfunction parseArray2(ctx, depth, id, current) {\n  return createArrayNode(id, current, parseItems2(ctx, depth, current));\n}\nfunction parseProperties2(ctx, depth, properties) {\n  const entries = Object.entries(properties);\n  const keyNodes = [];\n  const valueNodes = [];\n  for (let i = 0, len = entries.length; i < len; i++) {\n    keyNodes.push(serializeString(entries[i][0]));\n    valueNodes.push(parseSOS(ctx, depth, entries[i][1]));\n  }\n  if (SYM_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ITERATOR));\n    valueNodes.push(\n      createIteratorFactoryInstanceNode(\n        parseIteratorFactory(ctx.base),\n        parseSOS(\n          ctx,\n          depth,\n          iteratorToSequence(properties)\n        )\n      )\n    );\n  }\n  if (SYM_ASYNC_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ASYNC_ITERATOR));\n    valueNodes.push(\n      createAsyncIteratorFactoryInstanceNode(\n        parseAsyncIteratorFactory(ctx.base),\n        parseSOS(\n          ctx,\n          depth,\n          ctx.type === 1 /* Sync */ ? createStream() : createStreamFromAsyncIterable(\n            properties\n          )\n        )\n      )\n    );\n  }\n  if (SYM_TO_STRING_TAG in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_TO_STRING_TAG));\n    valueNodes.push(createStringNode(properties[SYM_TO_STRING_TAG]));\n  }\n  if (SYM_IS_CONCAT_SPREADABLE in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_IS_CONCAT_SPREADABLE));\n    valueNodes.push(\n      properties[SYM_IS_CONCAT_SPREADABLE] ? TRUE_NODE : FALSE_NODE\n    );\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes\n  };\n}\nfunction parsePlainObject2(ctx, depth, id, current, empty) {\n  return createObjectNode(\n    id,\n    current,\n    empty,\n    parseProperties2(ctx, depth, current)\n  );\n}\nfunction parseBoxed2(ctx, depth, id, current) {\n  return createBoxedNode(id, parseSOS(ctx, depth, current.valueOf()));\n}\nfunction parseTypedArray2(ctx, depth, id, current) {\n  return createTypedArrayNode(\n    id,\n    current,\n    parseSOS(ctx, depth, current.buffer)\n  );\n}\nfunction parseBigIntTypedArray2(ctx, depth, id, current) {\n  return createBigIntTypedArrayNode(\n    id,\n    current,\n    parseSOS(ctx, depth, current.buffer)\n  );\n}\nfunction parseDataView2(ctx, depth, id, current) {\n  return createDataViewNode(id, current, parseSOS(ctx, depth, current.buffer));\n}\nfunction parseError2(ctx, depth, id, current) {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createErrorNode(\n    id,\n    current,\n    options ? parseProperties2(ctx, depth, options) : NIL\n  );\n}\nfunction parseAggregateError2(ctx, depth, id, current) {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createAggregateErrorNode(\n    id,\n    current,\n    options ? parseProperties2(ctx, depth, options) : NIL\n  );\n}\nfunction parseMap2(ctx, depth, id, current) {\n  const keyNodes = [];\n  const valueNodes = [];\n  for (const [key, value] of current.entries()) {\n    keyNodes.push(parseSOS(ctx, depth, key));\n    valueNodes.push(parseSOS(ctx, depth, value));\n  }\n  return createMapNode(ctx.base, id, keyNodes, valueNodes);\n}\nfunction parseSet2(ctx, depth, id, current) {\n  const items = [];\n  for (const item of current.keys()) {\n    items.push(parseSOS(ctx, depth, item));\n  }\n  return createSetNode(id, items);\n}\nfunction parseStream2(ctx, depth, id, current) {\n  const result = createStreamConstructorNode(\n    id,\n    parseSpecialReference(ctx.base, 4 /* StreamConstructor */),\n    []\n  );\n  if (ctx.type === 1 /* Sync */) {\n    return result;\n  }\n  pushPendingState(ctx);\n  current.on({\n    next: (value) => {\n      if (ctx.state.alive) {\n        const parsed = parseWithError(ctx, depth, value);\n        if (parsed) {\n          onParse(ctx, createStreamNextNode(id, parsed));\n        }\n      }\n    },\n    throw: (value) => {\n      if (ctx.state.alive) {\n        const parsed = parseWithError(ctx, depth, value);\n        if (parsed) {\n          onParse(ctx, createStreamThrowNode(id, parsed));\n        }\n      }\n      popPendingState(ctx);\n    },\n    return: (value) => {\n      if (ctx.state.alive) {\n        const parsed = parseWithError(ctx, depth, value);\n        if (parsed) {\n          onParse(ctx, createStreamReturnNode(id, parsed));\n        }\n      }\n      popPendingState(ctx);\n    }\n  });\n  return result;\n}\nfunction handlePromiseSuccess(id, depth, data) {\n  if (this.state.alive) {\n    const parsed = parseWithError(this, depth, data);\n    if (parsed) {\n      onParse(\n        this,\n        createSerovalNode(\n          23 /* PromiseSuccess */,\n          id,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          [\n            parseSpecialReference(this.base, 2 /* PromiseSuccess */),\n            parsed\n          ],\n          NIL,\n          NIL,\n          NIL,\n          NIL\n        )\n      );\n    }\n    popPendingState(this);\n  }\n}\nfunction handlePromiseFailure(id, depth, data) {\n  if (this.state.alive) {\n    const parsed = parseWithError(this, depth, data);\n    if (parsed) {\n      onParse(\n        this,\n        createSerovalNode(\n          24 /* PromiseFailure */,\n          id,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          [\n            parseSpecialReference(this.base, 3 /* PromiseFailure */),\n            parsed\n          ],\n          NIL,\n          NIL,\n          NIL,\n          NIL\n        )\n      );\n    }\n  }\n  popPendingState(this);\n}\nfunction parsePromise2(ctx, depth, id, current) {\n  const resolver = createIndexForValue(ctx.base, {});\n  if (ctx.type === 2 /* Stream */) {\n    pushPendingState(ctx);\n    current.then(\n      handlePromiseSuccess.bind(ctx, resolver, depth),\n      handlePromiseFailure.bind(ctx, resolver, depth)\n    );\n  }\n  return createPromiseConstructorNode(ctx.base, id, resolver);\n}\nfunction parsePluginSync(ctx, depth, id, current, currentPlugins) {\n  for (let i = 0, len = currentPlugins.length; i < len; i++) {\n    const plugin = currentPlugins[i];\n    if (plugin.parse.sync && plugin.test(current)) {\n      return createPluginNode(\n        id,\n        plugin.tag,\n        plugin.parse.sync(current, new SyncParsePluginContext(ctx, depth), {\n          id\n        })\n      );\n    }\n  }\n  return NIL;\n}\nfunction parsePluginStream(ctx, depth, id, current, currentPlugins) {\n  for (let i = 0, len = currentPlugins.length; i < len; i++) {\n    const plugin = currentPlugins[i];\n    if (plugin.parse.stream && plugin.test(current)) {\n      return createPluginNode(\n        id,\n        plugin.tag,\n        plugin.parse.stream(current, new StreamParsePluginContext(ctx, depth), {\n          id\n        })\n      );\n    }\n  }\n  return NIL;\n}\nfunction parsePlugin2(ctx, depth, id, current) {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    return ctx.type === 1 /* Sync */ ? parsePluginSync(ctx, depth, id, current, currentPlugins) : parsePluginStream(ctx, depth, id, current, currentPlugins);\n  }\n  return NIL;\n}\nfunction parseObjectPhase2(ctx, depth, id, current, currentClass) {\n  switch (currentClass) {\n    case Object:\n      return parsePlainObject2(\n        ctx,\n        depth,\n        id,\n        current,\n        false\n      );\n    case NIL:\n      return parsePlainObject2(\n        ctx,\n        depth,\n        id,\n        current,\n        true\n      );\n    case Date:\n      return createDateNode(id, current);\n    case Error:\n    case EvalError:\n    case RangeError:\n    case ReferenceError:\n    case SyntaxError:\n    case TypeError:\n    case URIError:\n      return parseError2(ctx, depth, id, current);\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n      return parseBoxed2(ctx, depth, id, current);\n    case ArrayBuffer:\n      return createArrayBufferNode(\n        ctx.base,\n        id,\n        current\n      );\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n      return parseTypedArray2(\n        ctx,\n        depth,\n        id,\n        current\n      );\n    case DataView:\n      return parseDataView2(ctx, depth, id, current);\n    case Map:\n      return parseMap2(\n        ctx,\n        depth,\n        id,\n        current\n      );\n    case Set:\n      return parseSet2(ctx, depth, id, current);\n    default:\n      break;\n  }\n  if (currentClass === Promise || current instanceof Promise) {\n    return parsePromise2(ctx, depth, id, current);\n  }\n  const currentFeatures = ctx.base.features;\n  if (currentFeatures & 32 /* RegExp */ && currentClass === RegExp) {\n    return createRegExpNode(id, current);\n  }\n  if (currentFeatures & 16 /* BigIntTypedArray */) {\n    switch (currentClass) {\n      case BigInt64Array:\n      case BigUint64Array:\n        return parseBigIntTypedArray2(\n          ctx,\n          depth,\n          id,\n          current\n        );\n      default:\n        break;\n    }\n  }\n  if (currentFeatures & 1 /* AggregateError */ && typeof AggregateError !== \"undefined\" && (currentClass === AggregateError || current instanceof AggregateError)) {\n    return parseAggregateError2(\n      ctx,\n      depth,\n      id,\n      current\n    );\n  }\n  if (current instanceof Error) {\n    return parseError2(ctx, depth, id, current);\n  }\n  if (SYM_ITERATOR in current || SYM_ASYNC_ITERATOR in current) {\n    return parsePlainObject2(ctx, depth, id, current, !!currentClass);\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\nfunction parseObject(ctx, depth, id, current) {\n  if (Array.isArray(current)) {\n    return parseArray2(ctx, depth, id, current);\n  }\n  if (isStream(current)) {\n    return parseStream2(ctx, depth, id, current);\n  }\n  const currentClass = current.constructor;\n  if (currentClass === OpaqueReference) {\n    return parseSOS(\n      ctx,\n      depth,\n      current.replacement\n    );\n  }\n  const parsed = parsePlugin2(ctx, depth, id, current);\n  if (parsed) {\n    return parsed;\n  }\n  return parseObjectPhase2(ctx, depth, id, current, currentClass);\n}\nfunction parseFunction(ctx, depth, current) {\n  const ref = getReferenceNode(ctx.base, current);\n  if (ref.type !== 0 /* Fresh */) {\n    return ref.value;\n  }\n  const plugin = parsePlugin2(ctx, depth, ref.value, current);\n  if (plugin) {\n    return plugin;\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\nfunction parseSOS(ctx, depth, current) {\n  if (depth >= ctx.base.depthLimit) {\n    throw new SerovalDepthLimitError(ctx.base.depthLimit);\n  }\n  switch (typeof current) {\n    case \"boolean\":\n      return current ? TRUE_NODE : FALSE_NODE;\n    case \"undefined\":\n      return UNDEFINED_NODE;\n    case \"string\":\n      return createStringNode(current);\n    case \"number\":\n      return createNumberNode(current);\n    case \"bigint\":\n      return createBigIntNode(current);\n    case \"object\": {\n      if (current) {\n        const ref = getReferenceNode(ctx.base, current);\n        return ref.type === 0 /* Fresh */ ? parseObject(ctx, depth + 1, ref.value, current) : ref.value;\n      }\n      return NULL_NODE;\n    }\n    case \"symbol\":\n      return parseWellKnownSymbol(ctx.base, current);\n    case \"function\": {\n      return parseFunction(ctx, depth, current);\n    }\n    default:\n      throw new SerovalUnsupportedTypeError(current);\n  }\n}\nfunction parseTop(ctx, current) {\n  try {\n    return parseSOS(ctx, 0, current);\n  } catch (error) {\n    throw error instanceof SerovalParserError ? error : new SerovalParserError(error);\n  }\n}\nfunction onParse(ctx, node) {\n  if (ctx.state.initial) {\n    ctx.state.buffer.push(node);\n  } else {\n    onParseInternal(ctx, node, false);\n  }\n}\nfunction onError(ctx, error) {\n  if (ctx.state.onError) {\n    ctx.state.onError(error);\n  } else {\n    throw error instanceof SerovalParserError ? error : new SerovalParserError(error);\n  }\n}\nfunction onDone(ctx) {\n  if (ctx.state.onDone) {\n    ctx.state.onDone();\n  }\n}\nfunction onParseInternal(ctx, node, initial) {\n  try {\n    ctx.state.onParse(node, initial);\n  } catch (error) {\n    onError(ctx, error);\n  }\n}\nfunction pushPendingState(ctx) {\n  ctx.state.pending++;\n}\nfunction popPendingState(ctx) {\n  if (--ctx.state.pending <= 0) {\n    onDone(ctx);\n  }\n}\nfunction parseWithError(ctx, depth, current) {\n  try {\n    return parseSOS(ctx, depth, current);\n  } catch (err) {\n    onError(ctx, err);\n    return NIL;\n  }\n}\nfunction startStreamParse(ctx, current) {\n  const parsed = parseWithError(ctx, 0, current);\n  if (parsed) {\n    onParseInternal(ctx, parsed, true);\n    ctx.state.initial = false;\n    flushStreamParse(ctx, ctx.state);\n    if (ctx.state.pending <= 0) {\n      destroyStreamParse(ctx);\n    }\n  }\n}\nfunction flushStreamParse(ctx, state) {\n  for (let i = 0, len = state.buffer.length; i < len; i++) {\n    onParseInternal(ctx, state.buffer[i], false);\n  }\n}\nfunction destroyStreamParse(ctx) {\n  if (ctx.state.alive) {\n    onDone(ctx);\n    ctx.state.alive = false;\n  }\n}\n\n// src/core/cross/index.ts\nfunction crossSerialize(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(2 /* Cross */, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs\n  });\n  const tree = parseTop(ctx, source);\n  const serial = createCrossSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    scopeId: options.scopeId,\n    markedRefs: ctx.base.marked\n  });\n  return serializeTopCross(serial, tree);\n}\nasync function crossSerializeAsync(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(2 /* Cross */, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs\n  });\n  const tree = await parseTopAsync(ctx, source);\n  const serial = createCrossSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    scopeId: options.scopeId,\n    markedRefs: ctx.base.marked\n  });\n  return serializeTopCross(serial, tree);\n}\nfunction toCrossJSON(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(2 /* Cross */, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs\n  });\n  return parseTop(ctx, source);\n}\nasync function toCrossJSONAsync(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(2 /* Cross */, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs\n  });\n  return await parseTopAsync(ctx, source);\n}\nfunction crossSerializeStream(source, options) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createStreamParserContext({\n    plugins,\n    refs: options.refs,\n    disabledFeatures: options.disabledFeatures,\n    onParse(node, initial) {\n      const serial = createCrossSerializerContext({\n        plugins,\n        features: ctx.base.features,\n        scopeId: options.scopeId,\n        markedRefs: ctx.base.marked\n      });\n      let serialized;\n      try {\n        serialized = serializeTopCross(serial, node);\n      } catch (err) {\n        if (options.onError) {\n          options.onError(err);\n        }\n        return;\n      }\n      options.onSerialize(serialized, initial);\n    },\n    onError: options.onError,\n    onDone: options.onDone\n  });\n  startStreamParse(ctx, source);\n  return destroyStreamParse.bind(null, ctx);\n}\nfunction toCrossJSONStream(source, options) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createStreamParserContext({\n    plugins,\n    refs: options.refs,\n    disabledFeatures: options.disabledFeatures,\n    onParse: options.onParse,\n    onError: options.onError,\n    onDone: options.onDone\n  });\n  startStreamParse(ctx, source);\n  return destroyStreamParse.bind(null, ctx);\n}\nfunction fromCrossJSON(source, options) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createCrossDeserializerContext({\n    plugins,\n    refs: options.refs,\n    features: options.features,\n    disabledFeatures: options.disabledFeatures\n  });\n  return deserializeTop(ctx, source);\n}\n\n// src/core/Serializer.ts\nvar Serializer = class {\n  constructor(options) {\n    this.options = options;\n    this.alive = true;\n    this.flushed = false;\n    this.done = false;\n    this.pending = 0;\n    this.cleanups = [];\n    this.refs = /* @__PURE__ */ new Map();\n    this.keys = /* @__PURE__ */ new Set();\n    this.ids = 0;\n    this.plugins = resolvePlugins(options.plugins);\n  }\n  write(key, value) {\n    if (this.alive && !this.flushed) {\n      this.pending++;\n      this.keys.add(key);\n      this.cleanups.push(\n        crossSerializeStream(value, {\n          plugins: this.plugins,\n          scopeId: this.options.scopeId,\n          refs: this.refs,\n          disabledFeatures: this.options.disabledFeatures,\n          onError: this.options.onError,\n          onSerialize: (data, initial) => {\n            if (this.alive) {\n              this.options.onData(\n                initial ? this.options.globalIdentifier + '[\"' + serializeString(key) + '\"]=' + data : data\n              );\n            }\n          },\n          onDone: () => {\n            if (this.alive) {\n              this.pending--;\n              if (this.pending <= 0 && this.flushed && !this.done && this.options.onDone) {\n                this.options.onDone();\n                this.done = true;\n              }\n            }\n          }\n        })\n      );\n    }\n  }\n  getNextID() {\n    while (this.keys.has(\"\" + this.ids)) {\n      this.ids++;\n    }\n    return \"\" + this.ids;\n  }\n  push(value) {\n    const newID = this.getNextID();\n    this.write(newID, value);\n    return newID;\n  }\n  flush() {\n    if (this.alive) {\n      this.flushed = true;\n      if (this.pending <= 0 && !this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n    }\n  }\n  close() {\n    if (this.alive) {\n      for (let i = 0, len = this.cleanups.length; i < len; i++) {\n        this.cleanups[i]();\n      }\n      if (!this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n      this.alive = false;\n    }\n  }\n};\n\n// src/core/tree/index.ts\nfunction serialize2(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(1 /* Vanilla */, {\n    plugins,\n    disabledFeatures: options.disabledFeatures\n  });\n  const tree = parseTop(ctx, source);\n  const serial = createVanillaSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    markedRefs: ctx.base.marked\n  });\n  return serializeTopVanilla(serial, tree);\n}\nasync function serializeAsync(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(1 /* Vanilla */, {\n    plugins,\n    disabledFeatures: options.disabledFeatures\n  });\n  const tree = await parseTopAsync(ctx, source);\n  const serial = createVanillaSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    markedRefs: ctx.base.marked\n  });\n  return serializeTopVanilla(serial, tree);\n}\nfunction deserialize2(source) {\n  return (0, eval)(source);\n}\nfunction toJSON(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(1 /* Vanilla */, {\n    plugins,\n    disabledFeatures: options.disabledFeatures\n  });\n  return {\n    t: parseTop(ctx, source),\n    f: ctx.base.features,\n    m: Array.from(ctx.base.marked)\n  };\n}\nasync function toJSONAsync(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(1 /* Vanilla */, {\n    plugins,\n    disabledFeatures: options.disabledFeatures\n  });\n  return {\n    t: await parseTopAsync(ctx, source),\n    f: ctx.base.features,\n    m: Array.from(ctx.base.marked)\n  };\n}\nfunction compileJSON(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createVanillaSerializerContext({\n    plugins,\n    features: source.f,\n    markedRefs: source.m\n  });\n  return serializeTopVanilla(ctx, source.t);\n}\nfunction fromJSON(source, options = {}) {\n  var _a;\n  const plugins = resolvePlugins(options.plugins);\n  const disabledFeatures = options.disabledFeatures || 0;\n  const sourceFeatures = (_a = source.f) != null ? _a : ALL_ENABLED;\n  const ctx = createVanillaDeserializerContext({\n    plugins,\n    markedRefs: source.m,\n    features: sourceFeatures & ~disabledFeatures,\n    disabledFeatures\n  });\n  return deserializeTop(ctx, source.t);\n}\nexport {\n  Feature,\n  OpaqueReference,\n  Serializer,\n  SerovalConflictedNodeIdError,\n  SerovalDepthLimitError,\n  SerovalDeserializationError,\n  SerovalError,\n  SerovalMalformedNodeError,\n  SerovalMissingInstanceError,\n  SerovalMissingPluginError,\n  SerovalMissingReferenceError,\n  SerovalMissingReferenceForIdError,\n  SerovalMode,\n  SerovalParserError,\n  SerovalSerializationError,\n  SerovalUnknownTypedArrayError,\n  SerovalUnsupportedNodeError,\n  SerovalUnsupportedTypeError,\n  compileJSON,\n  createPlugin,\n  createReference,\n  createStream,\n  crossSerialize,\n  crossSerializeAsync,\n  crossSerializeStream,\n  deserialize2 as deserialize,\n  fromCrossJSON,\n  fromJSON,\n  getCrossReferenceHeader,\n  resolvePlugins,\n  serialize2 as serialize,\n  serializeAsync,\n  toCrossJSON,\n  toCrossJSONAsync,\n  toCrossJSONStream,\n  toJSON,\n  toJSONAsync\n};\n//# sourceMappingURL=index.mjs.map\n","import { createPlugin } from \"seroval\";\nimport { GLOBAL_TSR } from \"../constants.js\";\nfunction createSerializationAdapter(opts) {\n  return opts;\n}\nfunction makeSsrSerovalPlugin(serializationAdapter, options) {\n  return createPlugin({\n    tag: \"$TSR/t/\" + serializationAdapter.key,\n    test: serializationAdapter.test,\n    parse: {\n      stream(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value));\n      }\n    },\n    serialize(node, ctx) {\n      options.didRun = true;\n      return GLOBAL_TSR + '.t.get(\"' + serializationAdapter.key + '\")(' + ctx.serialize(node) + \")\";\n    },\n    // we never deserialize on the server during SSR\n    deserialize: void 0\n  });\n}\nfunction makeSerovalPlugin(serializationAdapter) {\n  return createPlugin({\n    tag: \"$TSR/t/\" + serializationAdapter.key,\n    test: serializationAdapter.test,\n    parse: {\n      sync(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value));\n      },\n      async async(value, ctx) {\n        return await ctx.parse(serializationAdapter.toSerializable(value));\n      },\n      stream(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value));\n      }\n    },\n    // we don't generate JS code outside of SSR (for now)\n    serialize: void 0,\n    deserialize(node, ctx) {\n      return serializationAdapter.fromSerializable(ctx.deserialize(node));\n    }\n  });\n}\nexport {\n  createSerializationAdapter,\n  makeSerovalPlugin,\n  makeSsrSerovalPlugin\n};\n//# sourceMappingURL=transformer.js.map\n","import * as React from \"react\";\nconst REACT_USE = \"use\";\nconst reactUse = React[REACT_USE];\nfunction useStableCallback(fn) {\n  const fnRef = React.useRef(fn);\n  fnRef.current = fn;\n  const ref = React.useRef((...args) => fnRef.current(...args));\n  return ref.current;\n}\nconst useLayoutEffect = typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction usePrevious(value) {\n  const ref = React.useRef({\n    value,\n    prev: null\n  });\n  const current = ref.current.value;\n  if (value !== current) {\n    ref.current = {\n      value,\n      prev: current\n    };\n  }\n  return ref.current.prev;\n}\nfunction useIntersectionObserver(ref, callback, intersectionObserverOptions = {}, options = {}) {\n  React.useEffect(() => {\n    if (!ref.current || options.disabled || typeof IntersectionObserver !== \"function\") {\n      return;\n    }\n    const observer = new IntersectionObserver(([entry]) => {\n      callback(entry);\n    }, intersectionObserverOptions);\n    observer.observe(ref.current);\n    return () => {\n      observer.disconnect();\n    };\n  }, [callback, intersectionObserverOptions, options.disabled, ref]);\n}\nfunction useForwardedRef(ref) {\n  const innerRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => innerRef.current, []);\n  return innerRef;\n}\nexport {\n  reactUse,\n  useForwardedRef,\n  useIntersectionObserver,\n  useLayoutEffect,\n  usePrevious,\n  useStableCallback\n};\n//# sourceMappingURL=utils.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { defer, TSR_DEFERRED_PROMISE } from \"@tanstack/router-core\";\nimport { reactUse } from \"./utils.js\";\nfunction useAwaited({ promise: _promise }) {\n  if (reactUse) {\n    const data = reactUse(_promise);\n    return data;\n  }\n  const promise = defer(_promise);\n  if (promise[TSR_DEFERRED_PROMISE].status === \"pending\") {\n    throw promise;\n  }\n  if (promise[TSR_DEFERRED_PROMISE].status === \"error\") {\n    throw promise[TSR_DEFERRED_PROMISE].error;\n  }\n  return promise[TSR_DEFERRED_PROMISE].data;\n}\nfunction Await(props) {\n  const inner = /* @__PURE__ */ jsx(AwaitInner, { ...props });\n  if (props.fallback) {\n    return /* @__PURE__ */ jsx(React.Suspense, { fallback: props.fallback, children: inner });\n  }\n  return inner;\n}\nfunction AwaitInner(props) {\n  const data = useAwaited(props);\n  return props.children(data);\n}\nexport {\n  Await,\n  useAwaited\n};\n//# sourceMappingURL=awaited.js.map\n","import { jsx, jsxs } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nfunction CatchBoundary(props) {\n  const errorComponent = props.errorComponent ?? ErrorComponent;\n  return /* @__PURE__ */ jsx(\n    CatchBoundaryImpl,\n    {\n      getResetKey: props.getResetKey,\n      onCatch: props.onCatch,\n      children: ({ error, reset }) => {\n        if (error) {\n          return React.createElement(errorComponent, {\n            error,\n            reset\n          });\n        }\n        return props.children;\n      }\n    }\n  );\n}\nclass CatchBoundaryImpl extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.state = { error: null };\n  }\n  static getDerivedStateFromProps(props) {\n    return { resetKey: props.getResetKey() };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  reset() {\n    this.setState({ error: null });\n  }\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.error && prevState.resetKey !== this.state.resetKey) {\n      this.reset();\n    }\n  }\n  componentDidCatch(error, errorInfo) {\n    if (this.props.onCatch) {\n      this.props.onCatch(error, errorInfo);\n    }\n  }\n  render() {\n    return this.props.children({\n      error: this.state.resetKey !== this.props.getResetKey() ? null : this.state.error,\n      reset: () => {\n        this.reset();\n      }\n    });\n  }\n}\nfunction ErrorComponent({ error }) {\n  const [show, setShow] = React.useState(process.env.NODE_ENV !== \"production\");\n  return /* @__PURE__ */ jsxs(\"div\", { style: { padding: \".5rem\", maxWidth: \"100%\" }, children: [\n    /* @__PURE__ */ jsxs(\"div\", { style: { display: \"flex\", alignItems: \"center\", gap: \".5rem\" }, children: [\n      /* @__PURE__ */ jsx(\"strong\", { style: { fontSize: \"1rem\" }, children: \"Something went wrong!\" }),\n      /* @__PURE__ */ jsx(\n        \"button\",\n        {\n          style: {\n            appearance: \"none\",\n            fontSize: \".6em\",\n            border: \"1px solid currentColor\",\n            padding: \".1rem .2rem\",\n            fontWeight: \"bold\",\n            borderRadius: \".25rem\"\n          },\n          onClick: () => setShow((d) => !d),\n          children: show ? \"Hide Error\" : \"Show Error\"\n        }\n      )\n    ] }),\n    /* @__PURE__ */ jsx(\"div\", { style: { height: \".25rem\" } }),\n    show ? /* @__PURE__ */ jsx(\"div\", { children: /* @__PURE__ */ jsx(\n      \"pre\",\n      {\n        style: {\n          fontSize: \".7em\",\n          border: \"1px solid red\",\n          borderRadius: \".25rem\",\n          padding: \".3rem\",\n          color: \"red\",\n          overflow: \"auto\"\n        },\n        children: error.message ? /* @__PURE__ */ jsx(\"code\", { children: error.message }) : null\n      }\n    ) }) : null\n  ] });\n}\nexport {\n  CatchBoundary,\n  ErrorComponent\n};\n//# sourceMappingURL=CatchBoundary.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport React__default from \"react\";\nfunction ClientOnly({ children, fallback = null }) {\n  return useHydrated() ? /* @__PURE__ */ jsx(React__default.Fragment, { children }) : /* @__PURE__ */ jsx(React__default.Fragment, { children: fallback });\n}\nfunction useHydrated() {\n  return React__default.useSyncExternalStore(\n    subscribe,\n    () => true,\n    () => false\n  );\n}\nfunction subscribe() {\n  return () => {\n  };\n}\nexport {\n  ClientOnly,\n  useHydrated\n};\n//# sourceMappingURL=ClientOnly.js.map\n","var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      shim = require(\"use-sync-external-store/shim\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = shim.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","import { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\nexport * from \"@tanstack/store\";\nfunction useStore(store, selector = (d) => d, options = {}) {\n  const equal = options.equal ?? shallow;\n  const slice = useSyncExternalStoreWithSelector(\n    store.subscribe,\n    () => store.state,\n    () => store.state,\n    selector,\n    equal\n  );\n  return slice;\n}\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false;\n    for (const [k, v] of objA) {\n      if (!objB.has(k) || !Object.is(v, objB.get(k))) return false;\n    }\n    return true;\n  }\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false;\n    for (const v of objA) {\n      if (!objB.has(v)) return false;\n    }\n    return true;\n  }\n  if (objA instanceof Date && objB instanceof Date) {\n    if (objA.getTime() !== objB.getTime()) return false;\n    return true;\n  }\n  const keysA = getOwnKeys(objA);\n  if (keysA.length !== getOwnKeys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getOwnKeys(obj) {\n  return Object.keys(obj).concat(\n    Object.getOwnPropertySymbols(obj)\n  );\n}\nexport {\n  shallow,\n  useStore\n};\n//# sourceMappingURL=index.js.map\n","import * as React from \"react\";\nconst routerContext = React.createContext(null);\nfunction getRouterContext() {\n  if (typeof document === \"undefined\") {\n    return routerContext;\n  }\n  if (window.__TSR_ROUTER_CONTEXT__) {\n    return window.__TSR_ROUTER_CONTEXT__;\n  }\n  window.__TSR_ROUTER_CONTEXT__ = routerContext;\n  return routerContext;\n}\nexport {\n  getRouterContext\n};\n//# sourceMappingURL=routerContext.js.map\n","import * as React from \"react\";\nimport warning from \"tiny-warning\";\nimport { getRouterContext } from \"./routerContext.js\";\nfunction useRouter(opts) {\n  const value = React.useContext(getRouterContext());\n  warning(\n    !((opts?.warn ?? true) && !value),\n    \"useRouter must be used inside a <RouterProvider> component!\"\n  );\n  return value;\n}\nexport {\n  useRouter\n};\n//# sourceMappingURL=useRouter.js.map\n","import { useStore } from \"@tanstack/react-store\";\nimport { useRef } from \"react\";\nimport { replaceEqualDeep } from \"@tanstack/router-core\";\nimport { useRouter } from \"./useRouter.js\";\nfunction useRouterState(opts) {\n  const contextRouter = useRouter({\n    warn: opts?.router === void 0\n  });\n  const router = opts?.router || contextRouter;\n  const previousResult = useRef(void 0);\n  return useStore(router.__store, (state) => {\n    if (opts?.select) {\n      if (opts.structuralSharing ?? router.options.defaultStructuralSharing) {\n        const newSlice = replaceEqualDeep(\n          previousResult.current,\n          opts.select(state)\n        );\n        previousResult.current = newSlice;\n        return newSlice;\n      }\n      return opts.select(state);\n    }\n    return state;\n  });\n}\nexport {\n  useRouterState\n};\n//# sourceMappingURL=useRouterState.js.map\n","import * as React from \"react\";\nconst matchContext = React.createContext(void 0);\nconst dummyMatchContext = React.createContext(\n  void 0\n);\nexport {\n  dummyMatchContext,\n  matchContext\n};\n//# sourceMappingURL=matchContext.js.map\n","import * as React from \"react\";\nimport invariant from \"tiny-invariant\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { dummyMatchContext, matchContext } from \"./matchContext.js\";\nfunction useMatch(opts) {\n  const nearestMatchId = React.useContext(\n    opts.from ? dummyMatchContext : matchContext\n  );\n  const matchSelection = useRouterState({\n    select: (state) => {\n      const match = state.matches.find(\n        (d) => opts.from ? opts.from === d.routeId : d.id === nearestMatchId\n      );\n      invariant(\n        !((opts.shouldThrow ?? true) && !match),\n        `Could not find ${opts.from ? `an active match from \"${opts.from}\"` : \"a nearest match!\"}`\n      );\n      if (match === void 0) {\n        return void 0;\n      }\n      return opts.select ? opts.select(match) : match;\n    },\n    structuralSharing: opts.structuralSharing\n  });\n  return matchSelection;\n}\nexport {\n  useMatch\n};\n//# sourceMappingURL=useMatch.js.map\n","import { useMatch } from \"./useMatch.js\";\nfunction useLoaderData(opts) {\n  return useMatch({\n    from: opts.from,\n    strict: opts.strict,\n    structuralSharing: opts.structuralSharing,\n    select: (s) => {\n      return opts.select ? opts.select(s.loaderData) : s.loaderData;\n    }\n  });\n}\nexport {\n  useLoaderData\n};\n//# sourceMappingURL=useLoaderData.js.map\n","import { useMatch } from \"./useMatch.js\";\nfunction useLoaderDeps(opts) {\n  const { select, ...rest } = opts;\n  return useMatch({\n    ...rest,\n    select: (s) => {\n      return select ? select(s.loaderDeps) : s.loaderDeps;\n    }\n  });\n}\nexport {\n  useLoaderDeps\n};\n//# sourceMappingURL=useLoaderDeps.js.map\n","import { useMatch } from \"./useMatch.js\";\nfunction useParams(opts) {\n  return useMatch({\n    from: opts.from,\n    shouldThrow: opts.shouldThrow,\n    structuralSharing: opts.structuralSharing,\n    strict: opts.strict,\n    select: (match) => {\n      const params = opts.strict === false ? match.params : match._strictParams;\n      return opts.select ? opts.select(params) : params;\n    }\n  });\n}\nexport {\n  useParams\n};\n//# sourceMappingURL=useParams.js.map\n","import { useMatch } from \"./useMatch.js\";\nfunction useSearch(opts) {\n  return useMatch({\n    from: opts.from,\n    strict: opts.strict,\n    shouldThrow: opts.shouldThrow,\n    structuralSharing: opts.structuralSharing,\n    select: (match) => {\n      return opts.select ? opts.select(match.search) : match.search;\n    }\n  });\n}\nexport {\n  useSearch\n};\n//# sourceMappingURL=useSearch.js.map\n","import * as React from \"react\";\nimport { useLayoutEffect } from \"./utils.js\";\nimport { useRouter } from \"./useRouter.js\";\nfunction useNavigate(_defaultOpts) {\n  const router = useRouter();\n  return React.useCallback(\n    (options) => {\n      return router.navigate({\n        ...options,\n        from: options.from ?? _defaultOpts?.from\n      });\n    },\n    [_defaultOpts?.from, router]\n  );\n}\nfunction Navigate(props) {\n  const router = useRouter();\n  const navigate = useNavigate();\n  const previousPropsRef = React.useRef(null);\n  useLayoutEffect(() => {\n    if (previousPropsRef.current !== props) {\n      navigate(props);\n      previousPropsRef.current = props;\n    }\n  }, [router, props, navigate]);\n  return null;\n}\nexport {\n  Navigate,\n  useNavigate\n};\n//# sourceMappingURL=useNavigate.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { isDangerousProtocol, preloadWarning, functionalUpdate, exactPathTest, removeTrailingSlash, deepEqual } from \"@tanstack/router-core\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { useForwardedRef, useIntersectionObserver } from \"./utils.js\";\nimport { useHydrated } from \"./ClientOnly.js\";\nfunction useLinkProps(options, forwardedRef) {\n  const router = useRouter();\n  const [isTransitioning, setIsTransitioning] = React.useState(false);\n  const hasRenderFetched = React.useRef(false);\n  const innerRef = useForwardedRef(forwardedRef);\n  const isHydrated = useHydrated();\n  const {\n    // custom props\n    activeProps,\n    inactiveProps,\n    activeOptions,\n    to,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    hashScrollIntoView,\n    replace,\n    startTransition,\n    resetScroll,\n    viewTransition,\n    // element props\n    children,\n    target,\n    disabled,\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ignoreBlocker,\n    // prevent these from being returned\n    params: _params,\n    search: _search,\n    hash: _hash,\n    state: _state,\n    mask: _mask,\n    reloadDocument: _reloadDocument,\n    unsafeRelative: _unsafeRelative,\n    from: _from,\n    _fromLocation,\n    ...propsSafeToSpread\n  } = options;\n  const currentSearch = useRouterState({\n    select: (s) => s.location.search,\n    structuralSharing: true\n  });\n  const from = options.from;\n  const _options = React.useMemo(\n    () => {\n      return { ...options, from };\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      router,\n      currentSearch,\n      from,\n      options._fromLocation,\n      options.hash,\n      options.to,\n      options.search,\n      options.params,\n      options.state,\n      options.mask,\n      options.unsafeRelative\n    ]\n  );\n  const next = React.useMemo(\n    () => router.buildLocation({ ..._options }),\n    [router, _options]\n  );\n  const hrefOption = React.useMemo(() => {\n    if (disabled) {\n      return void 0;\n    }\n    let href = next.maskedLocation ? next.maskedLocation.url.href : next.url.href;\n    let external = false;\n    if (router.origin) {\n      if (href.startsWith(router.origin)) {\n        href = router.history.createHref(href.replace(router.origin, \"\")) || \"/\";\n      } else {\n        external = true;\n      }\n    }\n    return { href, external };\n  }, [disabled, next.maskedLocation, next.url, router.origin, router.history]);\n  const externalLink = React.useMemo(() => {\n    if (hrefOption?.external) {\n      if (isDangerousProtocol(hrefOption.href)) {\n        if (process.env.NODE_ENV !== \"production\") {\n          console.warn(\n            `Blocked Link with dangerous protocol: ${hrefOption.href}`\n          );\n        }\n        return void 0;\n      }\n      return hrefOption.href;\n    }\n    const isSafeInternal = typeof to === \"string\" && to.charCodeAt(0) === 47 && // '/'\n    to.charCodeAt(1) !== 47;\n    if (isSafeInternal) return void 0;\n    try {\n      new URL(to);\n      if (isDangerousProtocol(to)) {\n        if (process.env.NODE_ENV !== \"production\") {\n          console.warn(`Blocked Link with dangerous protocol: ${to}`);\n        }\n        return void 0;\n      }\n      return to;\n    } catch {\n    }\n    return void 0;\n  }, [to, hrefOption]);\n  const preload = options.reloadDocument || externalLink ? false : userPreload ?? router.options.defaultPreload;\n  const preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0;\n  const isActive = useRouterState({\n    select: (s) => {\n      if (externalLink) return false;\n      if (activeOptions?.exact) {\n        const testExact = exactPathTest(\n          s.location.pathname,\n          next.pathname,\n          router.basepath\n        );\n        if (!testExact) {\n          return false;\n        }\n      } else {\n        const currentPathSplit = removeTrailingSlash(\n          s.location.pathname,\n          router.basepath\n        );\n        const nextPathSplit = removeTrailingSlash(\n          next.pathname,\n          router.basepath\n        );\n        const pathIsFuzzyEqual = currentPathSplit.startsWith(nextPathSplit) && (currentPathSplit.length === nextPathSplit.length || currentPathSplit[nextPathSplit.length] === \"/\");\n        if (!pathIsFuzzyEqual) {\n          return false;\n        }\n      }\n      if (activeOptions?.includeSearch ?? true) {\n        const searchTest = deepEqual(s.location.search, next.search, {\n          partial: !activeOptions?.exact,\n          ignoreUndefined: !activeOptions?.explicitUndefined\n        });\n        if (!searchTest) {\n          return false;\n        }\n      }\n      if (activeOptions?.includeHash) {\n        return isHydrated && s.location.hash === next.hash;\n      }\n      return true;\n    }\n  });\n  const doPreload = React.useCallback(() => {\n    router.preloadRoute({ ..._options }).catch((err) => {\n      console.warn(err);\n      console.warn(preloadWarning);\n    });\n  }, [router, _options]);\n  const preloadViewportIoCallback = React.useCallback(\n    (entry) => {\n      if (entry?.isIntersecting) {\n        doPreload();\n      }\n    },\n    [doPreload]\n  );\n  useIntersectionObserver(\n    innerRef,\n    preloadViewportIoCallback,\n    intersectionObserverOptions,\n    { disabled: !!disabled || !(preload === \"viewport\") }\n  );\n  React.useEffect(() => {\n    if (hasRenderFetched.current) {\n      return;\n    }\n    if (!disabled && preload === \"render\") {\n      doPreload();\n      hasRenderFetched.current = true;\n    }\n  }, [disabled, doPreload, preload]);\n  const handleClick = (e) => {\n    const elementTarget = e.currentTarget.getAttribute(\"target\");\n    const effectiveTarget = target !== void 0 ? target : elementTarget;\n    if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!effectiveTarget || effectiveTarget === \"_self\") && e.button === 0) {\n      e.preventDefault();\n      flushSync(() => {\n        setIsTransitioning(true);\n      });\n      const unsub = router.subscribe(\"onResolved\", () => {\n        unsub();\n        setIsTransitioning(false);\n      });\n      router.navigate({\n        ..._options,\n        replace,\n        resetScroll,\n        hashScrollIntoView,\n        startTransition,\n        viewTransition,\n        ignoreBlocker\n      });\n    }\n  };\n  if (externalLink) {\n    return {\n      ...propsSafeToSpread,\n      ref: innerRef,\n      href: externalLink,\n      ...children && { children },\n      ...target && { target },\n      ...disabled && { disabled },\n      ...style && { style },\n      ...className && { className },\n      ...onClick && { onClick },\n      ...onFocus && { onFocus },\n      ...onMouseEnter && { onMouseEnter },\n      ...onMouseLeave && { onMouseLeave },\n      ...onTouchStart && { onTouchStart }\n    };\n  }\n  const handleFocus = (_) => {\n    if (disabled) return;\n    if (preload) {\n      doPreload();\n    }\n  };\n  const handleTouchStart = handleFocus;\n  const handleEnter = (e) => {\n    if (disabled || !preload) return;\n    if (!preloadDelay) {\n      doPreload();\n    } else {\n      const eventTarget = e.target;\n      if (timeoutMap.has(eventTarget)) {\n        return;\n      }\n      const id = setTimeout(() => {\n        timeoutMap.delete(eventTarget);\n        doPreload();\n      }, preloadDelay);\n      timeoutMap.set(eventTarget, id);\n    }\n  };\n  const handleLeave = (e) => {\n    if (disabled || !preload || !preloadDelay) return;\n    const eventTarget = e.target;\n    const id = timeoutMap.get(eventTarget);\n    if (id) {\n      clearTimeout(id);\n      timeoutMap.delete(eventTarget);\n    }\n  };\n  const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? STATIC_ACTIVE_OBJECT : STATIC_EMPTY_OBJECT;\n  const resolvedInactiveProps = isActive ? STATIC_EMPTY_OBJECT : functionalUpdate(inactiveProps, {}) ?? STATIC_EMPTY_OBJECT;\n  const resolvedClassName = [\n    className,\n    resolvedActiveProps.className,\n    resolvedInactiveProps.className\n  ].filter(Boolean).join(\" \");\n  const resolvedStyle = (style || resolvedActiveProps.style || resolvedInactiveProps.style) && {\n    ...style,\n    ...resolvedActiveProps.style,\n    ...resolvedInactiveProps.style\n  };\n  return {\n    ...propsSafeToSpread,\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    href: hrefOption?.href,\n    ref: innerRef,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    disabled: !!disabled,\n    target,\n    ...resolvedStyle && { style: resolvedStyle },\n    ...resolvedClassName && { className: resolvedClassName },\n    ...disabled && STATIC_DISABLED_PROPS,\n    ...isActive && STATIC_ACTIVE_PROPS,\n    ...isTransitioning && STATIC_TRANSITIONING_PROPS\n  };\n}\nconst STATIC_EMPTY_OBJECT = {};\nconst STATIC_ACTIVE_OBJECT = { className: \"active\" };\nconst STATIC_DISABLED_PROPS = { role: \"link\", \"aria-disabled\": true };\nconst STATIC_ACTIVE_PROPS = { \"data-status\": \"active\", \"aria-current\": \"page\" };\nconst STATIC_TRANSITIONING_PROPS = { \"data-transitioning\": \"transitioning\" };\nconst timeoutMap = /* @__PURE__ */ new WeakMap();\nconst intersectionObserverOptions = {\n  rootMargin: \"100px\"\n};\nconst composeHandlers = (handlers) => (e) => {\n  for (const handler of handlers) {\n    if (!handler) continue;\n    if (e.defaultPrevented) return;\n    handler(e);\n  }\n};\nfunction createLink(Comp) {\n  return React.forwardRef(function CreatedLink(props, ref) {\n    return /* @__PURE__ */ jsx(Link, { ...props, _asChild: Comp, ref });\n  });\n}\nconst Link = React.forwardRef(\n  (props, ref) => {\n    const { _asChild, ...rest } = props;\n    const { type: _type, ...linkProps } = useLinkProps(rest, ref);\n    const children = typeof rest.children === \"function\" ? rest.children({\n      isActive: linkProps[\"data-status\"] === \"active\"\n    }) : rest.children;\n    if (!_asChild) {\n      const { disabled: _, ...rest2 } = linkProps;\n      return React.createElement(\"a\", rest2, children);\n    }\n    return React.createElement(_asChild, linkProps, children);\n  }\n);\nfunction isCtrlEvent(e) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n}\nconst linkOptions = (options) => {\n  return options;\n};\nexport {\n  Link,\n  createLink,\n  linkOptions,\n  useLinkProps\n};\n//# sourceMappingURL=link.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { BaseRouteApi, notFound, BaseRoute, BaseRootRoute } from \"@tanstack/router-core\";\nimport React__default from \"react\";\nimport { useLoaderData } from \"./useLoaderData.js\";\nimport { useLoaderDeps } from \"./useLoaderDeps.js\";\nimport { useParams } from \"./useParams.js\";\nimport { useSearch } from \"./useSearch.js\";\nimport { useNavigate } from \"./useNavigate.js\";\nimport { useMatch } from \"./useMatch.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { Link } from \"./link.js\";\nfunction getRouteApi(id) {\n  return new RouteApi({ id });\n}\nclass RouteApi extends BaseRouteApi {\n  /**\n   * @deprecated Use the `getRouteApi` function instead.\n   */\n  constructor({ id }) {\n    super({ id });\n    this.useMatch = (opts) => {\n      return useMatch({\n        select: opts?.select,\n        from: this.id,\n        structuralSharing: opts?.structuralSharing\n      });\n    };\n    this.useRouteContext = (opts) => {\n      return useMatch({\n        from: this.id,\n        select: (d) => opts?.select ? opts.select(d.context) : d.context\n      });\n    };\n    this.useSearch = (opts) => {\n      return useSearch({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useParams = (opts) => {\n      return useParams({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useLoaderDeps = (opts) => {\n      return useLoaderDeps({ ...opts, from: this.id, strict: false });\n    };\n    this.useLoaderData = (opts) => {\n      return useLoaderData({ ...opts, from: this.id, strict: false });\n    };\n    this.useNavigate = () => {\n      const router = useRouter();\n      return useNavigate({ from: router.routesById[this.id].fullPath });\n    };\n    this.notFound = (opts) => {\n      return notFound({ routeId: this.id, ...opts });\n    };\n    this.Link = React__default.forwardRef((props, ref) => {\n      const router = useRouter();\n      const fullPath = router.routesById[this.id].fullPath;\n      return /* @__PURE__ */ jsx(Link, { ref, from: fullPath, ...props });\n    });\n  }\n}\nclass Route extends BaseRoute {\n  /**\n   * @deprecated Use the `createRoute` function instead.\n   */\n  constructor(options) {\n    super(options);\n    this.useMatch = (opts) => {\n      return useMatch({\n        select: opts?.select,\n        from: this.id,\n        structuralSharing: opts?.structuralSharing\n      });\n    };\n    this.useRouteContext = (opts) => {\n      return useMatch({\n        ...opts,\n        from: this.id,\n        select: (d) => opts?.select ? opts.select(d.context) : d.context\n      });\n    };\n    this.useSearch = (opts) => {\n      return useSearch({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useParams = (opts) => {\n      return useParams({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useLoaderDeps = (opts) => {\n      return useLoaderDeps({ ...opts, from: this.id });\n    };\n    this.useLoaderData = (opts) => {\n      return useLoaderData({ ...opts, from: this.id });\n    };\n    this.useNavigate = () => {\n      return useNavigate({ from: this.fullPath });\n    };\n    this.Link = React__default.forwardRef(\n      (props, ref) => {\n        return /* @__PURE__ */ jsx(Link, { ref, from: this.fullPath, ...props });\n      }\n    );\n    this.$$typeof = /* @__PURE__ */ Symbol.for(\"react.memo\");\n  }\n}\nfunction createRoute(options) {\n  return new Route(\n    // TODO: Help us TypeChris, you're our only hope!\n    options\n  );\n}\nfunction createRootRouteWithContext() {\n  return (options) => {\n    return createRootRoute(options);\n  };\n}\nconst rootRouteWithContext = createRootRouteWithContext;\nclass RootRoute extends BaseRootRoute {\n  /**\n   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n   */\n  constructor(options) {\n    super(options);\n    this.useMatch = (opts) => {\n      return useMatch({\n        select: opts?.select,\n        from: this.id,\n        structuralSharing: opts?.structuralSharing\n      });\n    };\n    this.useRouteContext = (opts) => {\n      return useMatch({\n        ...opts,\n        from: this.id,\n        select: (d) => opts?.select ? opts.select(d.context) : d.context\n      });\n    };\n    this.useSearch = (opts) => {\n      return useSearch({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useParams = (opts) => {\n      return useParams({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useLoaderDeps = (opts) => {\n      return useLoaderDeps({ ...opts, from: this.id });\n    };\n    this.useLoaderData = (opts) => {\n      return useLoaderData({ ...opts, from: this.id });\n    };\n    this.useNavigate = () => {\n      return useNavigate({ from: this.fullPath });\n    };\n    this.Link = React__default.forwardRef(\n      (props, ref) => {\n        return /* @__PURE__ */ jsx(Link, { ref, from: this.fullPath, ...props });\n      }\n    );\n    this.$$typeof = /* @__PURE__ */ Symbol.for(\"react.memo\");\n  }\n}\nfunction createRootRoute(options) {\n  return new RootRoute(options);\n}\nfunction createRouteMask(opts) {\n  return opts;\n}\nclass NotFoundRoute extends Route {\n  constructor(options) {\n    super({\n      ...options,\n      id: \"404\"\n    });\n  }\n}\nexport {\n  NotFoundRoute,\n  RootRoute,\n  Route,\n  RouteApi,\n  createRootRoute,\n  createRootRouteWithContext,\n  createRoute,\n  createRouteMask,\n  getRouteApi,\n  rootRouteWithContext\n};\n//# sourceMappingURL=route.js.map\n","import warning from \"tiny-warning\";\nimport { createRoute } from \"./route.js\";\nimport { useMatch } from \"./useMatch.js\";\nimport { useLoaderDeps } from \"./useLoaderDeps.js\";\nimport { useLoaderData } from \"./useLoaderData.js\";\nimport { useSearch } from \"./useSearch.js\";\nimport { useParams } from \"./useParams.js\";\nimport { useNavigate } from \"./useNavigate.js\";\nimport { useRouter } from \"./useRouter.js\";\nfunction createFileRoute(path) {\n  if (typeof path === \"object\") {\n    return new FileRoute(path, {\n      silent: true\n    }).createRoute(path);\n  }\n  return new FileRoute(path, {\n    silent: true\n  }).createRoute;\n}\nclass FileRoute {\n  constructor(path, _opts) {\n    this.path = path;\n    this.createRoute = (options) => {\n      warning(\n        this.silent,\n        \"FileRoute is deprecated and will be removed in the next major version. Use the createFileRoute(path)(options) function instead.\"\n      );\n      const route = createRoute(options);\n      route.isRoot = false;\n      return route;\n    };\n    this.silent = _opts?.silent;\n  }\n}\nfunction FileRouteLoader(_path) {\n  warning(\n    false,\n    `FileRouteLoader is deprecated and will be removed in the next major version. Please place the loader function in the the main route file, inside the \\`createFileRoute('/path/to/file')(options)\\` options`\n  );\n  return (loaderFn) => loaderFn;\n}\nclass LazyRoute {\n  constructor(opts) {\n    this.useMatch = (opts2) => {\n      return useMatch({\n        select: opts2?.select,\n        from: this.options.id,\n        structuralSharing: opts2?.structuralSharing\n      });\n    };\n    this.useRouteContext = (opts2) => {\n      return useMatch({\n        from: this.options.id,\n        select: (d) => opts2?.select ? opts2.select(d.context) : d.context\n      });\n    };\n    this.useSearch = (opts2) => {\n      return useSearch({\n        select: opts2?.select,\n        structuralSharing: opts2?.structuralSharing,\n        from: this.options.id\n      });\n    };\n    this.useParams = (opts2) => {\n      return useParams({\n        select: opts2?.select,\n        structuralSharing: opts2?.structuralSharing,\n        from: this.options.id\n      });\n    };\n    this.useLoaderDeps = (opts2) => {\n      return useLoaderDeps({ ...opts2, from: this.options.id });\n    };\n    this.useLoaderData = (opts2) => {\n      return useLoaderData({ ...opts2, from: this.options.id });\n    };\n    this.useNavigate = () => {\n      const router = useRouter();\n      return useNavigate({ from: router.routesById[this.options.id].fullPath });\n    };\n    this.options = opts;\n    this.$$typeof = /* @__PURE__ */ Symbol.for(\"react.memo\");\n  }\n}\nfunction createLazyRoute(id) {\n  return (opts) => {\n    return new LazyRoute({\n      id,\n      ...opts\n    });\n  };\n}\nfunction createLazyFileRoute(id) {\n  if (typeof id === \"object\") {\n    return new LazyRoute(id);\n  }\n  return (opts) => new LazyRoute({ id, ...opts });\n}\nexport {\n  FileRoute,\n  FileRouteLoader,\n  LazyRoute,\n  createFileRoute,\n  createLazyFileRoute,\n  createLazyRoute\n};\n//# sourceMappingURL=fileRoute.js.map\n","import * as React from \"react\";\nimport { isModuleNotFoundError } from \"@tanstack/router-core\";\nimport { reactUse } from \"./utils.js\";\nfunction lazyRouteComponent(importer, exportName) {\n  let loadPromise;\n  let comp;\n  let error;\n  let reload;\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer().then((res) => {\n        loadPromise = void 0;\n        comp = res[exportName ?? \"default\"];\n      }).catch((err) => {\n        error = err;\n        if (isModuleNotFoundError(error)) {\n          if (error instanceof Error && typeof window !== \"undefined\" && typeof sessionStorage !== \"undefined\") {\n            const storageKey = `tanstack_router_reload:${error.message}`;\n            if (!sessionStorage.getItem(storageKey)) {\n              sessionStorage.setItem(storageKey, \"1\");\n              reload = true;\n            }\n          }\n        }\n      });\n    }\n    return loadPromise;\n  };\n  const lazyComp = function Lazy(props) {\n    if (reload) {\n      window.location.reload();\n      throw new Promise(() => {\n      });\n    }\n    if (error) {\n      throw error;\n    }\n    if (!comp) {\n      if (reactUse) {\n        reactUse(load());\n      } else {\n        throw load();\n      }\n    }\n    return React.createElement(comp, props);\n  };\n  lazyComp.preload = load;\n  return lazyComp;\n}\nexport {\n  lazyRouteComponent\n};\n//# sourceMappingURL=lazyRouteComponent.js.map\n","import * as React from \"react\";\nimport { trimPathRight, getLocationChangeInfo, handleHashScroll } from \"@tanstack/router-core\";\nimport { usePrevious, useLayoutEffect } from \"./utils.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nfunction Transitioner() {\n  const router = useRouter();\n  const mountLoadForRouter = React.useRef({ router, mounted: false });\n  const [isTransitioning, setIsTransitioning] = React.useState(false);\n  const { hasPendingMatches, isLoading } = useRouterState({\n    select: (s) => ({\n      isLoading: s.isLoading,\n      hasPendingMatches: s.matches.some((d) => d.status === \"pending\")\n    }),\n    structuralSharing: true\n  });\n  const previousIsLoading = usePrevious(isLoading);\n  const isAnyPending = isLoading || isTransitioning || hasPendingMatches;\n  const previousIsAnyPending = usePrevious(isAnyPending);\n  const isPagePending = isLoading || hasPendingMatches;\n  const previousIsPagePending = usePrevious(isPagePending);\n  router.startTransition = (fn) => {\n    setIsTransitioning(true);\n    React.startTransition(() => {\n      fn();\n      setIsTransitioning(false);\n    });\n  };\n  React.useEffect(() => {\n    const unsub = router.history.subscribe(\n      ({ navigateOpts }) => {\n        if (navigateOpts?.skipTransitionerLoad) {\n          return;\n        }\n        router.load();\n      }\n    );\n    const nextLocation = router.buildLocation({\n      to: router.latestLocation.pathname,\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n      _includeValidateSearch: true\n    });\n    if (trimPathRight(router.latestLocation.publicHref) !== trimPathRight(nextLocation.publicHref)) {\n      router.commitLocation({ ...nextLocation, replace: true });\n    }\n    return () => {\n      unsub();\n    };\n  }, [router, router.history]);\n  useLayoutEffect(() => {\n    if (\n      // if we are hydrating from SSR, loading is triggered in ssr-client\n      typeof window !== \"undefined\" && router.ssr || mountLoadForRouter.current.router === router && mountLoadForRouter.current.mounted\n    ) {\n      return;\n    }\n    mountLoadForRouter.current = { router, mounted: true };\n    const tryLoad = async () => {\n      try {\n        await router.load();\n      } catch (err) {\n        console.error(err);\n      }\n    };\n    tryLoad();\n  }, [router]);\n  useLayoutEffect(() => {\n    if (previousIsLoading && !isLoading) {\n      router.emit({\n        type: \"onLoad\",\n        // When the new URL has committed, when the new matches have been loaded into state.matches\n        ...getLocationChangeInfo(router.state)\n      });\n    }\n  }, [previousIsLoading, router, isLoading]);\n  useLayoutEffect(() => {\n    if (previousIsPagePending && !isPagePending) {\n      router.emit({\n        type: \"onBeforeRouteMount\",\n        ...getLocationChangeInfo(router.state)\n      });\n    }\n  }, [isPagePending, previousIsPagePending, router]);\n  useLayoutEffect(() => {\n    if (previousIsAnyPending && !isAnyPending) {\n      const changeInfo = getLocationChangeInfo(router.state);\n      router.emit({\n        type: \"onResolved\",\n        ...changeInfo\n      });\n      router.__store.setState((s) => ({\n        ...s,\n        status: \"idle\",\n        resolvedLocation: s.location\n      }));\n      if (changeInfo.hrefChanged) {\n        handleHashScroll(router);\n      }\n    }\n  }, [isAnyPending, previousIsAnyPending, router]);\n  return null;\n}\nexport {\n  Transitioner\n};\n//# sourceMappingURL=Transitioner.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { isNotFound } from \"@tanstack/router-core\";\nimport { CatchBoundary } from \"./CatchBoundary.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nfunction CatchNotFound(props) {\n  const resetKey = useRouterState({\n    select: (s) => `not-found-${s.location.pathname}-${s.status}`\n  });\n  return /* @__PURE__ */ jsx(\n    CatchBoundary,\n    {\n      getResetKey: () => resetKey,\n      onCatch: (error, errorInfo) => {\n        if (isNotFound(error)) {\n          props.onCatch?.(error, errorInfo);\n        } else {\n          throw error;\n        }\n      },\n      errorComponent: ({ error }) => {\n        if (isNotFound(error)) {\n          return props.fallback?.(error);\n        } else {\n          throw error;\n        }\n      },\n      children: props.children\n    }\n  );\n}\nfunction DefaultGlobalNotFound() {\n  return /* @__PURE__ */ jsx(\"p\", { children: \"Not Found\" });\n}\nexport {\n  CatchNotFound,\n  DefaultGlobalNotFound\n};\n//# sourceMappingURL=not-found.js.map\n","import { jsx, Fragment } from \"react/jsx-runtime\";\nfunction SafeFragment(props) {\n  return /* @__PURE__ */ jsx(Fragment, { children: props.children });\n}\nexport {\n  SafeFragment\n};\n//# sourceMappingURL=SafeFragment.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport warning from \"tiny-warning\";\nimport { DefaultGlobalNotFound } from \"./not-found.js\";\nfunction renderRouteNotFound(router, route, data) {\n  if (!route.options.notFoundComponent) {\n    if (router.options.defaultNotFoundComponent) {\n      return /* @__PURE__ */ jsx(router.options.defaultNotFoundComponent, { ...data });\n    }\n    if (process.env.NODE_ENV === \"development\") {\n      warning(\n        route.options.notFoundComponent,\n        `A notFoundError was encountered on the route with ID \"${route.id}\", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<p>Not Found</p>)`\n      );\n    }\n    return /* @__PURE__ */ jsx(DefaultGlobalNotFound, {});\n  }\n  return /* @__PURE__ */ jsx(route.options.notFoundComponent, { ...data });\n}\nexport {\n  renderRouteNotFound\n};\n//# sourceMappingURL=renderRouteNotFound.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { useRouter } from \"./useRouter.js\";\nfunction ScriptOnce({ children }) {\n  const router = useRouter();\n  if (!router.isServer) {\n    return null;\n  }\n  return /* @__PURE__ */ jsx(\n    \"script\",\n    {\n      nonce: router.options.ssr?.nonce,\n      dangerouslySetInnerHTML: {\n        __html: children + \";document.currentScript.remove()\"\n      }\n    }\n  );\n}\nexport {\n  ScriptOnce\n};\n//# sourceMappingURL=ScriptOnce.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { defaultGetScrollRestorationKey, restoreScroll, escapeHtml, storageKey } from \"@tanstack/router-core\";\nimport { useRouter } from \"./useRouter.js\";\nimport { ScriptOnce } from \"./ScriptOnce.js\";\nfunction ScrollRestoration() {\n  const router = useRouter();\n  if (!router.isScrollRestoring || !router.isServer) {\n    return null;\n  }\n  if (typeof router.options.scrollRestoration === \"function\") {\n    const shouldRestore = router.options.scrollRestoration({\n      location: router.latestLocation\n    });\n    if (!shouldRestore) {\n      return null;\n    }\n  }\n  const getKey = router.options.getScrollRestorationKey || defaultGetScrollRestorationKey;\n  const userKey = getKey(router.latestLocation);\n  const resolvedKey = userKey !== defaultGetScrollRestorationKey(router.latestLocation) ? userKey : void 0;\n  const restoreScrollOptions = {\n    storageKey,\n    shouldScrollRestoration: true\n  };\n  if (resolvedKey) {\n    restoreScrollOptions.key = resolvedKey;\n  }\n  return /* @__PURE__ */ jsx(\n    ScriptOnce,\n    {\n      children: `(${restoreScroll.toString()})(${escapeHtml(JSON.stringify(restoreScrollOptions))})`\n    }\n  );\n}\nexport {\n  ScrollRestoration\n};\n//# sourceMappingURL=scroll-restoration.js.map\n","import { jsxs, jsx, Fragment } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\nimport { isNotFound, rootRouteId, createControlledPromise, isRedirect, getLocationChangeInfo } from \"@tanstack/router-core\";\nimport { CatchBoundary, ErrorComponent } from \"./CatchBoundary.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { CatchNotFound } from \"./not-found.js\";\nimport { matchContext } from \"./matchContext.js\";\nimport { SafeFragment } from \"./SafeFragment.js\";\nimport { renderRouteNotFound } from \"./renderRouteNotFound.js\";\nimport { ScrollRestoration } from \"./scroll-restoration.js\";\nimport { ClientOnly } from \"./ClientOnly.js\";\nconst Match = React.memo(function MatchImpl({\n  matchId\n}) {\n  const router = useRouter();\n  const matchState = useRouterState({\n    select: (s) => {\n      const match = s.matches.find((d) => d.id === matchId);\n      invariant(\n        match,\n        `Could not find match for matchId \"${matchId}\". Please file an issue!`\n      );\n      return {\n        routeId: match.routeId,\n        ssr: match.ssr,\n        _displayPending: match._displayPending\n      };\n    },\n    structuralSharing: true\n  });\n  const route = router.routesById[matchState.routeId];\n  const PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent;\n  const pendingElement = PendingComponent ? /* @__PURE__ */ jsx(PendingComponent, {}) : null;\n  const routeErrorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent;\n  const routeOnCatch = route.options.onCatch ?? router.options.defaultOnCatch;\n  const routeNotFoundComponent = route.isRoot ? (\n    // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component\n    route.options.notFoundComponent ?? router.options.notFoundRoute?.options.component\n  ) : route.options.notFoundComponent;\n  const resolvedNoSsr = matchState.ssr === false || matchState.ssr === \"data-only\";\n  const ResolvedSuspenseBoundary = (\n    // If we're on the root route, allow forcefully wrapping in suspense\n    (!route.isRoot || route.options.wrapInSuspense || resolvedNoSsr) && (route.options.wrapInSuspense ?? PendingComponent ?? (route.options.errorComponent?.preload || resolvedNoSsr)) ? React.Suspense : SafeFragment\n  );\n  const ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment;\n  const ResolvedNotFoundBoundary = routeNotFoundComponent ? CatchNotFound : SafeFragment;\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt\n  });\n  const parentRouteId = useRouterState({\n    select: (s) => {\n      const index = s.matches.findIndex((d) => d.id === matchId);\n      return s.matches[index - 1]?.routeId;\n    }\n  });\n  const ShellComponent = route.isRoot ? route.options.shellComponent ?? SafeFragment : SafeFragment;\n  return /* @__PURE__ */ jsxs(ShellComponent, { children: [\n    /* @__PURE__ */ jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsx(ResolvedSuspenseBoundary, { fallback: pendingElement, children: /* @__PURE__ */ jsx(\n      ResolvedCatchBoundary,\n      {\n        getResetKey: () => resetKey,\n        errorComponent: routeErrorComponent || ErrorComponent,\n        onCatch: (error, errorInfo) => {\n          if (isNotFound(error)) throw error;\n          warning(false, `Error in route match: ${matchId}`);\n          routeOnCatch?.(error, errorInfo);\n        },\n        children: /* @__PURE__ */ jsx(\n          ResolvedNotFoundBoundary,\n          {\n            fallback: (error) => {\n              if (!routeNotFoundComponent || error.routeId && error.routeId !== matchState.routeId || !error.routeId && !route.isRoot)\n                throw error;\n              return React.createElement(routeNotFoundComponent, error);\n            },\n            children: resolvedNoSsr || matchState._displayPending ? /* @__PURE__ */ jsx(ClientOnly, { fallback: pendingElement, children: /* @__PURE__ */ jsx(MatchInner, { matchId }) }) : /* @__PURE__ */ jsx(MatchInner, { matchId })\n          }\n        )\n      }\n    ) }) }),\n    parentRouteId === rootRouteId && router.options.scrollRestoration ? /* @__PURE__ */ jsxs(Fragment, { children: [\n      /* @__PURE__ */ jsx(OnRendered, {}),\n      /* @__PURE__ */ jsx(ScrollRestoration, {})\n    ] }) : null\n  ] });\n});\nfunction OnRendered() {\n  const router = useRouter();\n  const prevLocationRef = React.useRef(\n    void 0\n  );\n  return /* @__PURE__ */ jsx(\n    \"script\",\n    {\n      suppressHydrationWarning: true,\n      ref: (el) => {\n        if (el && (prevLocationRef.current === void 0 || prevLocationRef.current.href !== router.latestLocation.href)) {\n          router.emit({\n            type: \"onRendered\",\n            ...getLocationChangeInfo(router.state)\n          });\n          prevLocationRef.current = router.latestLocation;\n        }\n      }\n    },\n    router.latestLocation.state.__TSR_key\n  );\n}\nconst MatchInner = React.memo(function MatchInnerImpl({\n  matchId\n}) {\n  const router = useRouter();\n  const { match, key, routeId } = useRouterState({\n    select: (s) => {\n      const match2 = s.matches.find((d) => d.id === matchId);\n      const routeId2 = match2.routeId;\n      const remountFn = router.routesById[routeId2].options.remountDeps ?? router.options.defaultRemountDeps;\n      const remountDeps = remountFn?.({\n        routeId: routeId2,\n        loaderDeps: match2.loaderDeps,\n        params: match2._strictParams,\n        search: match2._strictSearch\n      });\n      const key2 = remountDeps ? JSON.stringify(remountDeps) : void 0;\n      return {\n        key: key2,\n        routeId: routeId2,\n        match: {\n          id: match2.id,\n          status: match2.status,\n          error: match2.error,\n          invalid: match2.invalid,\n          _forcePending: match2._forcePending,\n          _displayPending: match2._displayPending\n        }\n      };\n    },\n    structuralSharing: true\n  });\n  const route = router.routesById[routeId];\n  const out = React.useMemo(() => {\n    const Comp = route.options.component ?? router.options.defaultComponent;\n    if (Comp) {\n      return /* @__PURE__ */ jsx(Comp, {}, key);\n    }\n    return /* @__PURE__ */ jsx(Outlet, {});\n  }, [key, route.options.component, router.options.defaultComponent]);\n  if (match._displayPending) {\n    throw router.getMatch(match.id)?._nonReactive.displayPendingPromise;\n  }\n  if (match._forcePending) {\n    throw router.getMatch(match.id)?._nonReactive.minPendingPromise;\n  }\n  if (match.status === \"pending\") {\n    const pendingMinMs = route.options.pendingMinMs ?? router.options.defaultPendingMinMs;\n    if (pendingMinMs) {\n      const routerMatch = router.getMatch(match.id);\n      if (routerMatch && !routerMatch._nonReactive.minPendingPromise) {\n        if (!router.isServer) {\n          const minPendingPromise = createControlledPromise();\n          routerMatch._nonReactive.minPendingPromise = minPendingPromise;\n          setTimeout(() => {\n            minPendingPromise.resolve();\n            routerMatch._nonReactive.minPendingPromise = void 0;\n          }, pendingMinMs);\n        }\n      }\n    }\n    throw router.getMatch(match.id)?._nonReactive.loadPromise;\n  }\n  if (match.status === \"notFound\") {\n    invariant(isNotFound(match.error), \"Expected a notFound error\");\n    return renderRouteNotFound(router, route, match.error);\n  }\n  if (match.status === \"redirected\") {\n    invariant(isRedirect(match.error), \"Expected a redirect error\");\n    throw router.getMatch(match.id)?._nonReactive.loadPromise;\n  }\n  if (match.status === \"error\") {\n    if (router.isServer) {\n      const RouteErrorComponent = (route.options.errorComponent ?? router.options.defaultErrorComponent) || ErrorComponent;\n      return /* @__PURE__ */ jsx(\n        RouteErrorComponent,\n        {\n          error: match.error,\n          reset: void 0,\n          info: {\n            componentStack: \"\"\n          }\n        }\n      );\n    }\n    throw match.error;\n  }\n  return out;\n});\nconst Outlet = React.memo(function OutletImpl() {\n  const router = useRouter();\n  const matchId = React.useContext(matchContext);\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId\n  });\n  const route = router.routesById[routeId];\n  const parentGlobalNotFound = useRouterState({\n    select: (s) => {\n      const matches = s.matches;\n      const parentMatch = matches.find((d) => d.id === matchId);\n      invariant(\n        parentMatch,\n        `Could not find parent match for matchId \"${matchId}\"`\n      );\n      return parentMatch.globalNotFound;\n    }\n  });\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = s.matches;\n      const index = matches.findIndex((d) => d.id === matchId);\n      return matches[index + 1]?.id;\n    }\n  });\n  const pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ jsx(router.options.defaultPendingComponent, {}) : null;\n  if (parentGlobalNotFound) {\n    return renderRouteNotFound(router, route, void 0);\n  }\n  if (!childMatchId) {\n    return null;\n  }\n  const nextMatch = /* @__PURE__ */ jsx(Match, { matchId: childMatchId });\n  if (routeId === rootRouteId) {\n    return /* @__PURE__ */ jsx(React.Suspense, { fallback: pendingElement, children: nextMatch });\n  }\n  return nextMatch;\n});\nexport {\n  Match,\n  MatchInner,\n  Outlet\n};\n//# sourceMappingURL=Match.js.map\n","import { jsxs, jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport warning from \"tiny-warning\";\nimport { rootRouteId } from \"@tanstack/router-core\";\nimport { CatchBoundary, ErrorComponent } from \"./CatchBoundary.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { Transitioner } from \"./Transitioner.js\";\nimport { matchContext } from \"./matchContext.js\";\nimport { Match } from \"./Match.js\";\nimport { SafeFragment } from \"./SafeFragment.js\";\nfunction Matches() {\n  const router = useRouter();\n  const rootRoute = router.routesById[rootRouteId];\n  const PendingComponent = rootRoute.options.pendingComponent ?? router.options.defaultPendingComponent;\n  const pendingElement = PendingComponent ? /* @__PURE__ */ jsx(PendingComponent, {}) : null;\n  const ResolvedSuspense = router.isServer || typeof document !== \"undefined\" && router.ssr ? SafeFragment : React.Suspense;\n  const inner = /* @__PURE__ */ jsxs(ResolvedSuspense, { fallback: pendingElement, children: [\n    !router.isServer && /* @__PURE__ */ jsx(Transitioner, {}),\n    /* @__PURE__ */ jsx(MatchesInner, {})\n  ] });\n  return router.options.InnerWrap ? /* @__PURE__ */ jsx(router.options.InnerWrap, { children: inner }) : inner;\n}\nfunction MatchesInner() {\n  const router = useRouter();\n  const matchId = useRouterState({\n    select: (s) => {\n      return s.matches[0]?.id;\n    }\n  });\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt\n  });\n  const matchComponent = matchId ? /* @__PURE__ */ jsx(Match, { matchId }) : null;\n  return /* @__PURE__ */ jsx(matchContext.Provider, { value: matchId, children: router.options.disableGlobalCatchBoundary ? matchComponent : /* @__PURE__ */ jsx(\n    CatchBoundary,\n    {\n      getResetKey: () => resetKey,\n      errorComponent: ErrorComponent,\n      onCatch: (error) => {\n        warning(\n          false,\n          `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`\n        );\n        warning(false, error.message || error.toString());\n      },\n      children: matchComponent\n    }\n  ) });\n}\nfunction useMatchRoute() {\n  const router = useRouter();\n  useRouterState({\n    select: (s) => [s.location.href, s.resolvedLocation?.href, s.status],\n    structuralSharing: true\n  });\n  return React.useCallback(\n    (opts) => {\n      const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts;\n      return router.matchRoute(rest, {\n        pending,\n        caseSensitive,\n        fuzzy,\n        includeSearch\n      });\n    },\n    [router]\n  );\n}\nfunction MatchRoute(props) {\n  const matchRoute = useMatchRoute();\n  const params = matchRoute(props);\n  if (typeof props.children === \"function\") {\n    return props.children(params);\n  }\n  return params ? props.children : null;\n}\nfunction useMatches(opts) {\n  return useRouterState({\n    select: (state) => {\n      const matches = state.matches;\n      return opts?.select ? opts.select(matches) : matches;\n    },\n    structuralSharing: opts?.structuralSharing\n  });\n}\nfunction useParentMatches(opts) {\n  const contextMatchId = React.useContext(matchContext);\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        0,\n        matches.findIndex((d) => d.id === contextMatchId)\n      );\n      return opts?.select ? opts.select(matches) : matches;\n    },\n    structuralSharing: opts?.structuralSharing\n  });\n}\nfunction useChildMatches(opts) {\n  const contextMatchId = React.useContext(matchContext);\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        matches.findIndex((d) => d.id === contextMatchId) + 1\n      );\n      return opts?.select ? opts.select(matches) : matches;\n    },\n    structuralSharing: opts?.structuralSharing\n  });\n}\nexport {\n  MatchRoute,\n  Matches,\n  useChildMatches,\n  useMatchRoute,\n  useMatches,\n  useParentMatches\n};\n//# sourceMappingURL=Matches.js.map\n","import { RouterCore } from \"@tanstack/router-core\";\nimport { createFileRoute, createLazyFileRoute } from \"./fileRoute.js\";\nconst createRouter = (options) => {\n  return new Router(options);\n};\nclass Router extends RouterCore {\n  constructor(options) {\n    super(options);\n  }\n}\nif (typeof globalThis !== \"undefined\") {\n  globalThis.createFileRoute = createFileRoute;\n  globalThis.createLazyFileRoute = createLazyFileRoute;\n} else if (typeof window !== \"undefined\") {\n  window.createFileRoute = createFileRoute;\n  window.createLazyFileRoute = createLazyFileRoute;\n}\nexport {\n  Router,\n  createRouter\n};\n//# sourceMappingURL=router.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { Matches } from \"./Matches.js\";\nimport { getRouterContext } from \"./routerContext.js\";\nfunction RouterContextProvider({\n  router,\n  children,\n  ...rest\n}) {\n  if (Object.keys(rest).length > 0) {\n    router.update({\n      ...router.options,\n      ...rest,\n      context: {\n        ...router.options.context,\n        ...rest.context\n      }\n    });\n  }\n  const routerContext = getRouterContext();\n  const provider = /* @__PURE__ */ jsx(routerContext.Provider, { value: router, children });\n  if (router.options.Wrap) {\n    return /* @__PURE__ */ jsx(router.options.Wrap, { children: provider });\n  }\n  return provider;\n}\nfunction RouterProvider({ router, ...rest }) {\n  return /* @__PURE__ */ jsx(RouterContextProvider, { router, ...rest, children: /* @__PURE__ */ jsx(Matches, {}) });\n}\nexport {\n  RouterContextProvider,\n  RouterProvider\n};\n//# sourceMappingURL=RouterProvider.js.map\n","import { defaultGetScrollRestorationKey, getCssSelector, scrollRestorationCache, setupScrollRestoration } from \"@tanstack/router-core\";\nimport { useRouter } from \"./useRouter.js\";\nfunction useScrollRestoration() {\n  const router = useRouter();\n  setupScrollRestoration(router, true);\n}\nfunction ScrollRestoration(_props) {\n  useScrollRestoration();\n  if (process.env.NODE_ENV === \"development\") {\n    console.warn(\n      \"The ScrollRestoration component is deprecated. Use createRouter's `scrollRestoration` option instead.\"\n    );\n  }\n  return null;\n}\nfunction useElementScrollRestoration(options) {\n  useScrollRestoration();\n  const router = useRouter();\n  const getKey = options.getKey || defaultGetScrollRestorationKey;\n  let elementSelector = \"\";\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`;\n  } else {\n    const element = options.getElement?.();\n    if (!element) {\n      return;\n    }\n    elementSelector = element instanceof Window ? \"window\" : getCssSelector(element);\n  }\n  const restoreKey = getKey(router.latestLocation);\n  const byKey = scrollRestorationCache?.state[restoreKey];\n  return byKey?.[elementSelector];\n}\nexport {\n  ScrollRestoration,\n  useElementScrollRestoration\n};\n//# sourceMappingURL=ScrollRestoration.js.map\n","import * as React from \"react\";\nimport { useRouter } from \"./useRouter.js\";\nfunction _resolveBlockerOpts(opts, condition) {\n  if (opts === void 0) {\n    return {\n      shouldBlockFn: () => true,\n      withResolver: false\n    };\n  }\n  if (\"shouldBlockFn\" in opts) {\n    return opts;\n  }\n  if (typeof opts === \"function\") {\n    const shouldBlock2 = Boolean(condition ?? true);\n    const _customBlockerFn2 = async () => {\n      if (shouldBlock2) return await opts();\n      return false;\n    };\n    return {\n      shouldBlockFn: _customBlockerFn2,\n      enableBeforeUnload: shouldBlock2,\n      withResolver: false\n    };\n  }\n  const shouldBlock = Boolean(opts.condition ?? true);\n  const fn = opts.blockerFn;\n  const _customBlockerFn = async () => {\n    if (shouldBlock && fn !== void 0) {\n      return await fn();\n    }\n    return shouldBlock;\n  };\n  return {\n    shouldBlockFn: _customBlockerFn,\n    enableBeforeUnload: shouldBlock,\n    withResolver: fn === void 0\n  };\n}\nfunction useBlocker(opts, condition) {\n  const {\n    shouldBlockFn,\n    enableBeforeUnload = true,\n    disabled = false,\n    withResolver = false\n  } = _resolveBlockerOpts(opts, condition);\n  const router = useRouter();\n  const { history } = router;\n  const [resolver, setResolver] = React.useState({\n    status: \"idle\",\n    current: void 0,\n    next: void 0,\n    action: void 0,\n    proceed: void 0,\n    reset: void 0\n  });\n  React.useEffect(() => {\n    const blockerFnComposed = async (blockerFnArgs) => {\n      function getLocation(location) {\n        const parsedLocation = router.parseLocation(location);\n        const matchedRoutes = router.getMatchedRoutes(parsedLocation.pathname);\n        if (matchedRoutes.foundRoute === void 0) {\n          return {\n            routeId: \"__notFound__\",\n            fullPath: parsedLocation.pathname,\n            pathname: parsedLocation.pathname,\n            params: matchedRoutes.routeParams,\n            search: router.options.parseSearch(location.search)\n          };\n        }\n        return {\n          routeId: matchedRoutes.foundRoute.id,\n          fullPath: matchedRoutes.foundRoute.fullPath,\n          pathname: parsedLocation.pathname,\n          params: matchedRoutes.routeParams,\n          search: router.options.parseSearch(location.search)\n        };\n      }\n      const current = getLocation(blockerFnArgs.currentLocation);\n      const next = getLocation(blockerFnArgs.nextLocation);\n      if (current.routeId === \"__notFound__\" && next.routeId !== \"__notFound__\") {\n        return false;\n      }\n      const shouldBlock = await shouldBlockFn({\n        action: blockerFnArgs.action,\n        current,\n        next\n      });\n      if (!withResolver) {\n        return shouldBlock;\n      }\n      if (!shouldBlock) {\n        return false;\n      }\n      const promise = new Promise((resolve) => {\n        setResolver({\n          status: \"blocked\",\n          current,\n          next,\n          action: blockerFnArgs.action,\n          proceed: () => resolve(false),\n          reset: () => resolve(true)\n        });\n      });\n      const canNavigateAsync = await promise;\n      setResolver({\n        status: \"idle\",\n        current: void 0,\n        next: void 0,\n        action: void 0,\n        proceed: void 0,\n        reset: void 0\n      });\n      return canNavigateAsync;\n    };\n    return disabled ? void 0 : history.block({ blockerFn: blockerFnComposed, enableBeforeUnload });\n  }, [\n    shouldBlockFn,\n    enableBeforeUnload,\n    disabled,\n    withResolver,\n    history,\n    router\n  ]);\n  return resolver;\n}\nconst _resolvePromptBlockerArgs = (props) => {\n  if (\"shouldBlockFn\" in props) {\n    return { ...props };\n  }\n  const shouldBlock = Boolean(props.condition ?? true);\n  const fn = props.blockerFn;\n  const _customBlockerFn = async () => {\n    if (shouldBlock && fn !== void 0) {\n      return await fn();\n    }\n    return shouldBlock;\n  };\n  return {\n    shouldBlockFn: _customBlockerFn,\n    enableBeforeUnload: shouldBlock,\n    withResolver: fn === void 0\n  };\n};\nfunction Block(opts) {\n  const { children, ...rest } = opts;\n  const args = _resolvePromptBlockerArgs(rest);\n  const resolver = useBlocker(args);\n  return children ? typeof children === \"function\" ? children(resolver) : children : null;\n}\nexport {\n  Block,\n  useBlocker\n};\n//# sourceMappingURL=useBlocker.js.map\n","import { useMatch } from \"./useMatch.js\";\nfunction useRouteContext(opts) {\n  return useMatch({\n    ...opts,\n    select: (match) => opts.select ? opts.select(match.context) : match.context\n  });\n}\nexport {\n  useRouteContext\n};\n//# sourceMappingURL=useRouteContext.js.map\n","import { useRouterState } from \"./useRouterState.js\";\nfunction useLocation(opts) {\n  return useRouterState({\n    select: (state) => opts?.select ? opts.select(state.location) : state.location\n  });\n}\nexport {\n  useLocation\n};\n//# sourceMappingURL=useLocation.js.map\n","import { useRouterState } from \"./useRouterState.js\";\nfunction useCanGoBack() {\n  return useRouterState({ select: (s) => s.location.state.__TSR_index !== 0 });\n}\nexport {\n  useCanGoBack\n};\n//# sourceMappingURL=useCanGoBack.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { useRouter } from \"./useRouter.js\";\nfunction Asset({\n  tag,\n  attrs,\n  children,\n  nonce\n}) {\n  switch (tag) {\n    case \"title\":\n      return /* @__PURE__ */ jsx(\"title\", { ...attrs, suppressHydrationWarning: true, children });\n    case \"meta\":\n      return /* @__PURE__ */ jsx(\"meta\", { ...attrs, suppressHydrationWarning: true });\n    case \"link\":\n      return /* @__PURE__ */ jsx(\"link\", { ...attrs, nonce, suppressHydrationWarning: true });\n    case \"style\":\n      return /* @__PURE__ */ jsx(\n        \"style\",\n        {\n          ...attrs,\n          dangerouslySetInnerHTML: { __html: children },\n          nonce\n        }\n      );\n    case \"script\":\n      return /* @__PURE__ */ jsx(Script, { attrs, children });\n    default:\n      return null;\n  }\n}\nfunction Script({\n  attrs,\n  children\n}) {\n  const router = useRouter();\n  React.useEffect(() => {\n    if (attrs?.src) {\n      const normSrc = (() => {\n        try {\n          const base = document.baseURI || window.location.href;\n          return new URL(attrs.src, base).href;\n        } catch {\n          return attrs.src;\n        }\n      })();\n      const existingScript = Array.from(\n        document.querySelectorAll(\"script[src]\")\n      ).find((el) => el.src === normSrc);\n      if (existingScript) {\n        return;\n      }\n      const script = document.createElement(\"script\");\n      for (const [key, value] of Object.entries(attrs)) {\n        if (key !== \"suppressHydrationWarning\" && value !== void 0 && value !== false) {\n          script.setAttribute(\n            key,\n            typeof value === \"boolean\" ? \"\" : String(value)\n          );\n        }\n      }\n      document.head.appendChild(script);\n      return () => {\n        if (script.parentNode) {\n          script.parentNode.removeChild(script);\n        }\n      };\n    }\n    if (typeof children === \"string\") {\n      const typeAttr = typeof attrs?.type === \"string\" ? attrs.type : \"text/javascript\";\n      const nonceAttr = typeof attrs?.nonce === \"string\" ? attrs.nonce : void 0;\n      const existingScript = Array.from(\n        document.querySelectorAll(\"script:not([src])\")\n      ).find((el) => {\n        if (!(el instanceof HTMLScriptElement)) return false;\n        const sType = el.getAttribute(\"type\") ?? \"text/javascript\";\n        const sNonce = el.getAttribute(\"nonce\") ?? void 0;\n        return el.textContent === children && sType === typeAttr && sNonce === nonceAttr;\n      });\n      if (existingScript) {\n        return;\n      }\n      const script = document.createElement(\"script\");\n      script.textContent = children;\n      if (attrs) {\n        for (const [key, value] of Object.entries(attrs)) {\n          if (key !== \"suppressHydrationWarning\" && value !== void 0 && value !== false) {\n            script.setAttribute(\n              key,\n              typeof value === \"boolean\" ? \"\" : String(value)\n            );\n          }\n        }\n      }\n      document.head.appendChild(script);\n      return () => {\n        if (script.parentNode) {\n          script.parentNode.removeChild(script);\n        }\n      };\n    }\n    return void 0;\n  }, [attrs, children]);\n  if (!router.isServer) {\n    const { src, ...rest } = attrs || {};\n    return /* @__PURE__ */ jsx(\n      \"script\",\n      {\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: { __html: \"\" },\n        ...rest\n      }\n    );\n  }\n  if (attrs?.src && typeof attrs.src === \"string\") {\n    return /* @__PURE__ */ jsx(\"script\", { ...attrs, suppressHydrationWarning: true });\n  }\n  if (typeof children === \"string\") {\n    return /* @__PURE__ */ jsx(\n      \"script\",\n      {\n        ...attrs,\n        dangerouslySetInnerHTML: { __html: children },\n        suppressHydrationWarning: true\n      }\n    );\n  }\n  return null;\n}\nexport {\n  Asset\n};\n//# sourceMappingURL=Asset.js.map\n","import * as React from \"react\";\nimport { escapeHtml } from \"@tanstack/router-core\";\nimport { useRouter } from \"./useRouter.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nconst useTags = () => {\n  const router = useRouter();\n  const nonce = router.options.ssr?.nonce;\n  const routeMeta = useRouterState({\n    select: (state) => {\n      return state.matches.map((match) => match.meta).filter(Boolean);\n    }\n  });\n  const meta = React.useMemo(() => {\n    const resultMeta = [];\n    const metaByAttribute = {};\n    let title;\n    for (let i = routeMeta.length - 1; i >= 0; i--) {\n      const metas = routeMeta[i];\n      for (let j = metas.length - 1; j >= 0; j--) {\n        const m = metas[j];\n        if (!m) continue;\n        if (m.title) {\n          if (!title) {\n            title = {\n              tag: \"title\",\n              children: m.title\n            };\n          }\n        } else if (\"script:ld+json\" in m) {\n          try {\n            const json = JSON.stringify(m[\"script:ld+json\"]);\n            resultMeta.push({\n              tag: \"script\",\n              attrs: {\n                type: \"application/ld+json\"\n              },\n              children: escapeHtml(json)\n            });\n          } catch {\n          }\n        } else {\n          const attribute = m.name ?? m.property;\n          if (attribute) {\n            if (metaByAttribute[attribute]) {\n              continue;\n            } else {\n              metaByAttribute[attribute] = true;\n            }\n          }\n          resultMeta.push({\n            tag: \"meta\",\n            attrs: {\n              ...m,\n              nonce\n            }\n          });\n        }\n      }\n    }\n    if (title) {\n      resultMeta.push(title);\n    }\n    if (nonce) {\n      resultMeta.push({\n        tag: \"meta\",\n        attrs: {\n          property: \"csp-nonce\",\n          content: nonce\n        }\n      });\n    }\n    resultMeta.reverse();\n    return resultMeta;\n  }, [routeMeta, nonce]);\n  const links = useRouterState({\n    select: (state) => {\n      const constructed = state.matches.map((match) => match.links).filter(Boolean).flat(1).map((link) => ({\n        tag: \"link\",\n        attrs: {\n          ...link,\n          nonce\n        }\n      }));\n      const manifest = router.ssr?.manifest;\n      const assets = state.matches.map((match) => manifest?.routes[match.routeId]?.assets ?? []).filter(Boolean).flat(1).filter((asset) => asset.tag === \"link\").map(\n        (asset) => ({\n          tag: \"link\",\n          attrs: {\n            ...asset.attrs,\n            suppressHydrationWarning: true,\n            nonce\n          }\n        })\n      );\n      return [...constructed, ...assets];\n    },\n    structuralSharing: true\n  });\n  const preloadLinks = useRouterState({\n    select: (state) => {\n      const preloadLinks2 = [];\n      state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach(\n        (route) => router.ssr?.manifest?.routes[route.id]?.preloads?.filter(Boolean).forEach((preload) => {\n          preloadLinks2.push({\n            tag: \"link\",\n            attrs: {\n              rel: \"modulepreload\",\n              href: preload,\n              nonce\n            }\n          });\n        })\n      );\n      return preloadLinks2;\n    },\n    structuralSharing: true\n  });\n  const styles = useRouterState({\n    select: (state) => state.matches.map((match) => match.styles).flat(1).filter(Boolean).map(({ children, ...attrs }) => ({\n      tag: \"style\",\n      attrs: {\n        ...attrs,\n        nonce\n      },\n      children\n    })),\n    structuralSharing: true\n  });\n  const headScripts = useRouterState({\n    select: (state) => state.matches.map((match) => match.headScripts).flat(1).filter(Boolean).map(({ children, ...script }) => ({\n      tag: \"script\",\n      attrs: {\n        ...script,\n        nonce\n      },\n      children\n    })),\n    structuralSharing: true\n  });\n  return uniqBy(\n    [\n      ...meta,\n      ...preloadLinks,\n      ...links,\n      ...styles,\n      ...headScripts\n    ],\n    (d) => {\n      return JSON.stringify(d);\n    }\n  );\n};\nfunction uniqBy(arr, fn) {\n  const seen = /* @__PURE__ */ new Set();\n  return arr.filter((item) => {\n    const key = fn(item);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.add(key);\n    return true;\n  });\n}\nexport {\n  uniqBy,\n  useTags\n};\n//# sourceMappingURL=headContentUtils.js.map\n","import { jsx, Fragment } from \"react/jsx-runtime\";\nimport { createElement } from \"react\";\nimport { Asset } from \"./Asset.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nconst Scripts = () => {\n  const router = useRouter();\n  const nonce = router.options.ssr?.nonce;\n  const assetScripts = useRouterState({\n    select: (state) => {\n      const assetScripts2 = [];\n      const manifest = router.ssr?.manifest;\n      if (!manifest) {\n        return [];\n      }\n      state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach(\n        (route) => manifest.routes[route.id]?.assets?.filter((d) => d.tag === \"script\").forEach((asset) => {\n          assetScripts2.push({\n            tag: \"script\",\n            attrs: { ...asset.attrs, nonce },\n            children: asset.children\n          });\n        })\n      );\n      return assetScripts2;\n    },\n    structuralSharing: true\n  });\n  const { scripts } = useRouterState({\n    select: (state) => ({\n      scripts: state.matches.map((match) => match.scripts).flat(1).filter(Boolean).map(({ children, ...script }) => ({\n        tag: \"script\",\n        attrs: {\n          ...script,\n          suppressHydrationWarning: true,\n          nonce\n        },\n        children\n      }))\n    }),\n    structuralSharing: true\n  });\n  let serverBufferedScript = void 0;\n  if (router.serverSsr) {\n    serverBufferedScript = router.serverSsr.takeBufferedScripts();\n  }\n  const allScripts = [...scripts, ...assetScripts];\n  if (serverBufferedScript) {\n    allScripts.unshift(serverBufferedScript);\n  }\n  return /* @__PURE__ */ jsx(Fragment, { children: allScripts.map((asset, i) => /* @__PURE__ */ createElement(Asset, { ...asset, key: `tsr-scripts-${asset.tag}-${i}` })) });\n};\nexport {\n  Scripts\n};\n//# sourceMappingURL=Scripts.js.map\n","import { jsx, Fragment } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { createElement } from \"react\";\nimport { Asset } from \"./Asset.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { useHydrated } from \"./ClientOnly.js\";\nimport { useTags } from \"./headContentUtils.js\";\nconst DEV_STYLES_ATTR = \"data-tanstack-router-dev-styles\";\nfunction HeadContent() {\n  const tags = useTags();\n  const router = useRouter();\n  const nonce = router.options.ssr?.nonce;\n  const hydrated = useHydrated();\n  React.useEffect(() => {\n    if (hydrated) {\n      document.querySelectorAll(`link[${DEV_STYLES_ATTR}]`).forEach((el) => el.remove());\n    }\n  }, [hydrated]);\n  const filteredTags = hydrated ? tags.filter((tag) => !tag.attrs?.[DEV_STYLES_ATTR]) : tags;\n  return /* @__PURE__ */ jsx(Fragment, { children: filteredTags.map((tag) => /* @__PURE__ */ createElement(Asset, { ...tag, key: `tsr-meta-${JSON.stringify(tag)}`, nonce })) });\n}\nexport {\n  HeadContent\n};\n//# sourceMappingURL=HeadContent.dev.js.map\n"],"mappings":"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"}