{"version":3,"file":"@tanstack_react-virtual.js","names":[],"sources":["../../@tanstack/virtual-core/dist/esm/utils.js","../../@tanstack/virtual-core/dist/esm/index.js","../../@tanstack/react-virtual/dist/esm/index.js"],"sourcesContent":["function memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  let isInitial = true;\n  function memoizedFunction() {\n    var _a, _b, _c;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    if ((opts == null ? void 0 : opts.onChange) && !(isInitial && opts.skipInitialOnChange)) {\n      opts.onChange(result);\n    }\n    isInitial = false;\n    return result;\n  }\n  memoizedFunction.updateDeps = (newDeps) => {\n    deps = newDeps;\n  };\n  return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) < 1.01;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\nexport {\n  approxEqual,\n  debounce,\n  memo,\n  notUndefined\n};\n//# sourceMappingURL=utils.js.map\n","import { debounce, memo, notUndefined, approxEqual } from \"./utils.js\";\nconst getRect = (element) => {\n  const { offsetWidth, offsetHeight } = element;\n  return { width: offsetWidth, height: offsetHeight };\n};\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(getRect(element));\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0];\n      if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize });\n          return;\n        }\n      }\n      handler(getRect(element));\n    };\n    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst addEventListenerOptions = {\n  passive: true\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    const { horizontal, isRtl } = instance.options;\n    offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return element[instance.options.horizontal ? \"offsetWidth\" : \"offsetHeight\"];\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.currentScrollToIndex = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.laneAssignments = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.prevLanes = void 0;\n    this.lanesChangedFlag = false;\n    this.lanesSettling = false;\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            const run = () => {\n              this._measureElement(entry.target, entry);\n            };\n            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          (_a = get()) == null ? void 0 : _a.disconnect();\n          _ro = null;\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        useScrollendEvent: false,\n        useAnimationFrameWithResizeObserver: false,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.observer.disconnect();\n      this.scrollElement = null;\n      this.targetWindow = null;\n    };\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a;\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        if (!scrollElement) {\n          this.maybeNotify();\n          return;\n        }\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n        this.elementsCache.forEach((cached) => {\n          this.observer.observe(cached);\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset;\n            this.isScrolling = isScrolling;\n            this.maybeNotify();\n          })\n        );\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n      }\n    };\n    this.getSize = () => {\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n      this.scrollRect = this.scrollRect ?? this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getScrollOffset = () => {\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n      return this.scrollOffset;\n    };\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurementOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled,\n        this.options.lanes\n      ],\n      (count, paddingStart, scrollMargin, getItemKey, enabled, lanes) => {\n        const lanesChanged = this.prevLanes !== void 0 && this.prevLanes !== lanes;\n        if (lanesChanged) {\n          this.lanesChangedFlag = true;\n        }\n        this.prevLanes = lanes;\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey,\n          enabled,\n          lanes\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getMeasurements = memo(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey, enabled, lanes }, itemSizeCache) => {\n        if (!enabled) {\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          this.laneAssignments.clear();\n          return [];\n        }\n        if (this.laneAssignments.size > count) {\n          for (const index of this.laneAssignments.keys()) {\n            if (index >= count) {\n              this.laneAssignments.delete(index);\n            }\n          }\n        }\n        if (this.lanesChangedFlag) {\n          this.lanesChangedFlag = false;\n          this.lanesSettling = true;\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          this.laneAssignments.clear();\n          this.pendingMeasuredCacheIndexes = [];\n        }\n        if (this.measurementsCache.length === 0 && !this.lanesSettling) {\n          this.measurementsCache = this.options.initialMeasurementsCache;\n          this.measurementsCache.forEach((item) => {\n            this.itemSizeCache.set(item.key, item.size);\n          });\n        }\n        const min = this.lanesSettling ? 0 : this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        if (this.lanesSettling && this.measurementsCache.length === count) {\n          this.lanesSettling = false;\n        }\n        const measurements = this.measurementsCache.slice(0, min);\n        const laneLastIndex = new Array(lanes).fill(\n          void 0\n        );\n        for (let m = 0; m < min; m++) {\n          const item = measurements[m];\n          if (item) {\n            laneLastIndex[item.lane] = m;\n          }\n        }\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const cachedLane = this.laneAssignments.get(i);\n          let lane;\n          let start;\n          if (cachedLane !== void 0 && this.options.lanes > 1) {\n            lane = cachedLane;\n            const prevIndex = laneLastIndex[lane];\n            const prevInLane = prevIndex !== void 0 ? measurements[prevIndex] : void 0;\n            start = prevInLane ? prevInLane.end + this.options.gap : paddingStart + scrollMargin;\n          } else {\n            const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n            start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n            lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n            if (this.options.lanes > 1) {\n              this.laneAssignments.set(i, lane);\n            }\n          }\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n          laneLastIndex[lane] = i;\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [\n        this.getMeasurements(),\n        this.getSize(),\n        this.getScrollOffset(),\n        this.options.lanes\n      ],\n      (measurements, outerSize, scrollOffset, lanes) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset,\n          lanes\n        }) : null;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualIndexes = memo(\n      () => {\n        let startIndex = null;\n        let endIndex = null;\n        const range = this.calculateRange();\n        if (range) {\n          startIndex = range.startIndex;\n          endIndex = range.endIndex;\n        }\n        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);\n        return [\n          this.options.rangeExtractor,\n          this.options.overscan,\n          this.options.count,\n          startIndex,\n          endIndex\n        ];\n      },\n      (rangeExtractor, overscan, count, startIndex, endIndex) => {\n        return startIndex === null || endIndex === null ? [] : rangeExtractor({\n          startIndex,\n          endIndex,\n          overscan,\n          count\n        });\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const index = this.indexFromElement(node);\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const key = item.key;\n      const prevNode = this.elementsCache.get(key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n      if (node.isConnected) {\n        this.resizeItem(index, this.options.measureElement(node, entry, this));\n      }\n    };\n    this.resizeItem = (index, size) => {\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getVirtualIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualItems\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      if (measurements.length === 0) {\n        return void 0;\n      }\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => notUndefined(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getMaxScrollOffset = () => {\n      if (!this.scrollElement) return 0;\n      if (\"scrollHeight\" in this.scrollElement) {\n        return this.options.horizontal ? this.scrollElement.scrollWidth - this.scrollElement.clientWidth : this.scrollElement.scrollHeight - this.scrollElement.clientHeight;\n      } else {\n        const doc = this.scrollElement.document.documentElement;\n        return this.options.horizontal ? doc.scrollWidth - this.scrollElement.innerWidth : doc.scrollHeight - this.scrollElement.innerHeight;\n      }\n    };\n    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {\n      if (!this.scrollElement) return 0;\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        align = toOffset >= scrollOffset + size ? \"end\" : \"start\";\n      }\n      if (align === \"center\") {\n        toOffset += (itemSize - size) / 2;\n      } else if (align === \"end\") {\n        toOffset -= size;\n      }\n      const maxOffset = this.getMaxScrollOffset();\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return void 0;\n      }\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n      if (align === \"end\" && index === this.options.count - 1) {\n        return [this.getMaxScrollOffset(), align];\n      }\n      const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n      return [\n        this.getOffsetForAlignment(toOffset, align, item.size),\n        align\n      ];\n    };\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.currentScrollToIndex = index;\n      let attempts = 0;\n      const maxAttempts = 10;\n      const tryScroll = (currentAlign) => {\n        if (!this.targetWindow) return;\n        const offsetInfo = this.getOffsetForIndex(index, currentAlign);\n        if (!offsetInfo) {\n          console.warn(\"Failed to get offset for index:\", index);\n          return;\n        }\n        const [offset, align] = offsetInfo;\n        this._scrollToOffset(offset, { adjustments: void 0, behavior });\n        this.targetWindow.requestAnimationFrame(() => {\n          const verify = () => {\n            if (this.currentScrollToIndex !== index) return;\n            const currentOffset = this.getScrollOffset();\n            const afterInfo = this.getOffsetForIndex(index, align);\n            if (!afterInfo) {\n              console.warn(\"Failed to get offset for index:\", index);\n              return;\n            }\n            if (!approxEqual(afterInfo[0], currentOffset)) {\n              scheduleRetry(align);\n            }\n          };\n          if (this.isDynamicMode()) {\n            this.targetWindow.requestAnimationFrame(verify);\n          } else {\n            verify();\n          }\n        });\n      };\n      const scheduleRetry = (align) => {\n        if (!this.targetWindow) return;\n        if (this.currentScrollToIndex !== index) return;\n        attempts++;\n        if (attempts < maxAttempts) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"Schedule retry\", attempts, maxAttempts);\n          }\n          this.targetWindow.requestAnimationFrame(() => tryScroll(align));\n        } else {\n          console.warn(\n            `Failed to scroll to index ${index} after ${maxAttempts} attempts.`\n          );\n        }\n      };\n      tryScroll(initialAlign);\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else if (this.options.lanes === 1) {\n        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;\n      } else {\n        const endByLane = Array(this.options.lanes).fill(null);\n        let endIndex = measurements.length - 1;\n        while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n          const item = measurements[endIndex];\n          if (endByLane[item.lane] === null) {\n            endByLane[item.lane] = item.end;\n          }\n          endIndex--;\n        }\n        end = Math.max(...endByLane.filter((val) => val !== null));\n      }\n      return Math.max(\n        end - this.options.scrollMargin + this.options.paddingEnd,\n        0\n      );\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.laneAssignments = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes\n}) {\n  const lastIndex = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex\n    };\n  }\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset\n  );\n  let endIndex = startIndex;\n  if (lanes === 1) {\n    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {\n      endIndex++;\n    }\n  } else if (lanes > 1) {\n    const endPerLane = Array(lanes).fill(0);\n    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {\n      const item = measurements[endIndex];\n      endPerLane[item.lane] = item.end;\n      endIndex++;\n    }\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex];\n      startPerLane[item.lane] = item.start;\n      startIndex--;\n    }\n    startIndex = Math.max(0, startIndex - startIndex % lanes);\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n  }\n  return { startIndex, endIndex };\n}\nexport {\n  Virtualizer,\n  approxEqual,\n  debounce,\n  defaultKeyExtractor,\n  defaultRangeExtractor,\n  elementScroll,\n  measureElement,\n  memo,\n  notUndefined,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll\n};\n//# sourceMappingURL=index.js.map\n","import * as React from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { Virtualizer, elementScroll, observeElementOffset, observeElementRect, windowScroll, observeWindowOffset, observeWindowRect } from \"@tanstack/virtual-core\";\nexport * from \"@tanstack/virtual-core\";\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction useVirtualizerBase({\n  useFlushSync = true,\n  ...options\n}) {\n  const rerender = React.useReducer(() => ({}), {})[1];\n  const resolvedOptions = {\n    ...options,\n    onChange: (instance2, sync) => {\n      var _a;\n      if (useFlushSync && sync) {\n        flushSync(rerender);\n      } else {\n        rerender();\n      }\n      (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n    }\n  };\n  const [instance] = React.useState(\n    () => new Virtualizer(resolvedOptions)\n  );\n  instance.setOptions(resolvedOptions);\n  useIsomorphicLayoutEffect(() => {\n    return instance._didMount();\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate();\n  });\n  return instance;\n}\nfunction useVirtualizer(options) {\n  return useVirtualizerBase({\n    observeElementRect,\n    observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options\n  });\n}\nfunction useWindowVirtualizer(options) {\n  return useVirtualizerBase({\n    getScrollElement: () => typeof document !== \"undefined\" ? window : null,\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    initialOffset: () => typeof document !== \"undefined\" ? window.scrollY : 0,\n    ...options\n  });\n}\nexport {\n  useVirtualizer,\n  useWindowVirtualizer\n};\n//# sourceMappingURL=index.js.map\n"],"mappings":"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"}