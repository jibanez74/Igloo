{"version":3,"file":"route-hmr-statement.cjs","sources":["../../../src/core/route-hmr-statement.ts"],"sourcesContent":["import * as template from '@babel/template'\nimport type { AnyRoute, AnyRouteMatch, AnyRouter } from '@tanstack/router-core'\n\ntype AnyRouteWithPrivateProps = AnyRoute & {\n  _path: string\n  _id: string\n  _fullPath: string\n  _to: string\n}\n\nfunction handleRouteUpdate(\n  oldRoute: AnyRouteWithPrivateProps,\n  newRoute: AnyRouteWithPrivateProps,\n) {\n  newRoute._path = oldRoute._path\n  newRoute._id = oldRoute._id\n  newRoute._fullPath = oldRoute._fullPath\n  newRoute._to = oldRoute._to\n  newRoute.children = oldRoute.children\n  newRoute.parentRoute = oldRoute.parentRoute\n\n  const router = window.__TSR_ROUTER__!\n  router.routesById[newRoute.id] = newRoute\n  router.routesByPath[newRoute.fullPath] = newRoute\n  router.processedTree.matchCache.clear()\n  router.processedTree.flatCache?.clear()\n  router.processedTree.singleCache.clear()\n  router.resolvePathCache.clear()\n  // TODO: how to rebuild the tree if we add a new route?\n  walkReplaceSegmentTree(newRoute, router.processedTree.segmentTree)\n  const filter = (m: AnyRouteMatch) => m.routeId === oldRoute.id\n  if (\n    router.state.matches.find(filter) ||\n    router.state.pendingMatches?.find(filter)\n  ) {\n    router.invalidate({ filter })\n  }\n  function walkReplaceSegmentTree(\n    route: AnyRouteWithPrivateProps,\n    node: AnyRouter['processedTree']['segmentTree'],\n  ) {\n    if (node.route?.id === route.id) node.route = route\n    if (node.index) walkReplaceSegmentTree(route, node.index)\n    node.static?.forEach((child) => walkReplaceSegmentTree(route, child))\n    node.staticInsensitive?.forEach((child) =>\n      walkReplaceSegmentTree(route, child),\n    )\n    node.dynamic?.forEach((child) => walkReplaceSegmentTree(route, child))\n    node.optional?.forEach((child) => walkReplaceSegmentTree(route, child))\n    node.wildcard?.forEach((child) => walkReplaceSegmentTree(route, child))\n  }\n}\n\nexport const routeHmrStatement = template.statement(\n  `\nif (import.meta.hot) {\n  import.meta.hot.accept((newModule) => {\n    if (Route && newModule && newModule.Route) {\n      (${handleRouteUpdate.toString()})(Route, newModule.Route)\n    }\n   })\n}\n`,\n  // Disable placeholder parsing so identifiers like __TSR_ROUTER__ are treated as normal identifiers instead of template placeholders\n  { placeholderPattern: false },\n)()\n"],"names":["template"],"mappings":";;;;;;;;;;;;;;;;;;;;AAUA,SAAS,kBACP,UACA,UACA;AACA,WAAS,QAAQ,SAAS;AAC1B,WAAS,MAAM,SAAS;AACxB,WAAS,YAAY,SAAS;AAC9B,WAAS,MAAM,SAAS;AACxB,WAAS,WAAW,SAAS;AAC7B,WAAS,cAAc,SAAS;AAEhC,QAAM,SAAS,OAAO;AACtB,SAAO,WAAW,SAAS,EAAE,IAAI;AACjC,SAAO,aAAa,SAAS,QAAQ,IAAI;AACzC,SAAO,cAAc,WAAW,MAAA;AAChC,SAAO,cAAc,WAAW,MAAA;AAChC,SAAO,cAAc,YAAY,MAAA;AACjC,SAAO,iBAAiB,MAAA;AAExB,yBAAuB,UAAU,OAAO,cAAc,WAAW;AACjE,QAAM,SAAS,CAAC,MAAqB,EAAE,YAAY,SAAS;AAC5D,MACE,OAAO,MAAM,QAAQ,KAAK,MAAM,KAChC,OAAO,MAAM,gBAAgB,KAAK,MAAM,GACxC;AACA,WAAO,WAAW,EAAE,QAAQ;AAAA,EAC9B;AACA,WAAS,uBACP,OACA,MACA;AACA,QAAI,KAAK,OAAO,OAAO,MAAM,SAAS,QAAQ;AAC9C,QAAI,KAAK,MAAO,wBAAuB,OAAO,KAAK,KAAK;AACxD,SAAK,QAAQ,QAAQ,CAAC,UAAU,uBAAuB,OAAO,KAAK,CAAC;AACpE,SAAK,mBAAmB;AAAA,MAAQ,CAAC,UAC/B,uBAAuB,OAAO,KAAK;AAAA,IAAA;AAErC,SAAK,SAAS,QAAQ,CAAC,UAAU,uBAAuB,OAAO,KAAK,CAAC;AACrE,SAAK,UAAU,QAAQ,CAAC,UAAU,uBAAuB,OAAO,KAAK,CAAC;AACtE,SAAK,UAAU,QAAQ,CAAC,UAAU,uBAAuB,OAAO,KAAK,CAAC;AAAA,EACxE;AACF;AAEO,MAAM,oBAAoBA,oBAAS;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,SAIO,kBAAkB,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMnC,EAAE,oBAAoB,MAAA;AACxB,EAAA;;"}