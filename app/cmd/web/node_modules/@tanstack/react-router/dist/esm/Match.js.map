{"version":3,"file":"Match.js","sources":["../../src/Match.tsx"],"sourcesContent":["import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport {\n  createControlledPromise,\n  getLocationChangeInfo,\n  isNotFound,\n  isRedirect,\n  rootRouteId,\n} from '@tanstack/router-core'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { CatchNotFound } from './not-found'\nimport { matchContext } from './matchContext'\nimport { SafeFragment } from './SafeFragment'\nimport { renderRouteNotFound } from './renderRouteNotFound'\nimport { ScrollRestoration } from './scroll-restoration'\nimport { ClientOnly } from './ClientOnly'\nimport type {\n  AnyRoute,\n  ParsedLocation,\n  RootRouteOptions,\n} from '@tanstack/router-core'\n\nexport const Match = React.memo(function MatchImpl({\n  matchId,\n}: {\n  matchId: string\n}) {\n  const router = useRouter()\n  const matchState = useRouterState({\n    select: (s) => {\n      const match = s.matches.find((d) => d.id === matchId)\n      invariant(\n        match,\n        `Could not find match for matchId \"${matchId}\". Please file an issue!`,\n      )\n      return {\n        routeId: match.routeId,\n        ssr: match.ssr,\n        _displayPending: match._displayPending,\n      }\n    },\n    structuralSharing: true as any,\n  })\n\n  const route: AnyRoute = router.routesById[matchState.routeId]\n\n  const PendingComponent =\n    route.options.pendingComponent ?? router.options.defaultPendingComponent\n\n  const pendingElement = PendingComponent ? <PendingComponent /> : null\n\n  const routeErrorComponent =\n    route.options.errorComponent ?? router.options.defaultErrorComponent\n\n  const routeOnCatch = route.options.onCatch ?? router.options.defaultOnCatch\n\n  const routeNotFoundComponent = route.isRoot\n    ? // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component\n      (route.options.notFoundComponent ??\n      router.options.notFoundRoute?.options.component)\n    : route.options.notFoundComponent\n\n  const resolvedNoSsr =\n    matchState.ssr === false || matchState.ssr === 'data-only'\n  const ResolvedSuspenseBoundary =\n    // If we're on the root route, allow forcefully wrapping in suspense\n    (!route.isRoot || route.options.wrapInSuspense || resolvedNoSsr) &&\n    (route.options.wrapInSuspense ??\n      PendingComponent ??\n      ((route.options.errorComponent as any)?.preload || resolvedNoSsr))\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = routeErrorComponent\n    ? CatchBoundary\n    : SafeFragment\n\n  const ResolvedNotFoundBoundary = routeNotFoundComponent\n    ? CatchNotFound\n    : SafeFragment\n\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt,\n  })\n\n  const parentRouteId = useRouterState({\n    select: (s) => {\n      const index = s.matches.findIndex((d) => d.id === matchId)\n      return s.matches[index - 1]?.routeId as string\n    },\n  })\n\n  const ShellComponent = route.isRoot\n    ? ((route.options as RootRouteOptions).shellComponent ?? SafeFragment)\n    : SafeFragment\n  return (\n    <ShellComponent>\n      <matchContext.Provider value={matchId}>\n        <ResolvedSuspenseBoundary fallback={pendingElement}>\n          <ResolvedCatchBoundary\n            getResetKey={() => resetKey}\n            errorComponent={routeErrorComponent || ErrorComponent}\n            onCatch={(error, errorInfo) => {\n              // Forward not found errors (we don't want to show the error component for these)\n              if (isNotFound(error)) throw error\n              warning(false, `Error in route match: ${matchId}`)\n              routeOnCatch?.(error, errorInfo)\n            }}\n          >\n            <ResolvedNotFoundBoundary\n              fallback={(error) => {\n                // If the current not found handler doesn't exist or it has a\n                // route ID which doesn't match the current route, rethrow the error\n                if (\n                  !routeNotFoundComponent ||\n                  (error.routeId && error.routeId !== matchState.routeId) ||\n                  (!error.routeId && !route.isRoot)\n                )\n                  throw error\n\n                return React.createElement(routeNotFoundComponent, error as any)\n              }}\n            >\n              {resolvedNoSsr || matchState._displayPending ? (\n                <ClientOnly fallback={pendingElement}>\n                  <MatchInner matchId={matchId} />\n                </ClientOnly>\n              ) : (\n                <MatchInner matchId={matchId} />\n              )}\n            </ResolvedNotFoundBoundary>\n          </ResolvedCatchBoundary>\n        </ResolvedSuspenseBoundary>\n      </matchContext.Provider>\n      {parentRouteId === rootRouteId && router.options.scrollRestoration ? (\n        <>\n          <OnRendered />\n          <ScrollRestoration />\n        </>\n      ) : null}\n    </ShellComponent>\n  )\n})\n\n// On Rendered can't happen above the root layout because it actually\n// renders a dummy dom element to track the rendered state of the app.\n// We render a script tag with a key that changes based on the current\n// location state.__TSR_key. Also, because it's below the root layout, it\n// allows us to fire onRendered events even after a hydration mismatch\n// error that occurred above the root layout (like bad head/link tags,\n// which is common).\nfunction OnRendered() {\n  const router = useRouter()\n\n  const prevLocationRef = React.useRef<undefined | ParsedLocation<{}>>(\n    undefined,\n  )\n\n  return (\n    <script\n      key={router.latestLocation.state.__TSR_key}\n      suppressHydrationWarning\n      ref={(el) => {\n        if (\n          el &&\n          (prevLocationRef.current === undefined ||\n            prevLocationRef.current.href !== router.latestLocation.href)\n        ) {\n          router.emit({\n            type: 'onRendered',\n            ...getLocationChangeInfo(router.state),\n          })\n          prevLocationRef.current = router.latestLocation\n        }\n      }}\n    />\n  )\n}\n\nexport const MatchInner = React.memo(function MatchInnerImpl({\n  matchId,\n}: {\n  matchId: string\n}): any {\n  const router = useRouter()\n\n  const { match, key, routeId } = useRouterState({\n    select: (s) => {\n      const match = s.matches.find((d) => d.id === matchId)!\n      const routeId = match.routeId as string\n\n      const remountFn =\n        (router.routesById[routeId] as AnyRoute).options.remountDeps ??\n        router.options.defaultRemountDeps\n      const remountDeps = remountFn?.({\n        routeId,\n        loaderDeps: match.loaderDeps,\n        params: match._strictParams,\n        search: match._strictSearch,\n      })\n      const key = remountDeps ? JSON.stringify(remountDeps) : undefined\n\n      return {\n        key,\n        routeId,\n        match: {\n          id: match.id,\n          status: match.status,\n          error: match.error,\n          invalid: match.invalid,\n          _forcePending: match._forcePending,\n          _displayPending: match._displayPending,\n        },\n      }\n    },\n    structuralSharing: true as any,\n  })\n\n  const route = router.routesById[routeId] as AnyRoute\n\n  const out = React.useMemo(() => {\n    const Comp = route.options.component ?? router.options.defaultComponent\n    if (Comp) {\n      return <Comp key={key} />\n    }\n    return <Outlet />\n  }, [key, route.options.component, router.options.defaultComponent])\n\n  if (match._displayPending) {\n    throw router.getMatch(match.id)?._nonReactive.displayPendingPromise\n  }\n\n  if (match._forcePending) {\n    throw router.getMatch(match.id)?._nonReactive.minPendingPromise\n  }\n\n  // see also hydrate() in packages/router-core/src/ssr/ssr-client.ts\n  if (match.status === 'pending') {\n    // We're pending, and if we have a minPendingMs, we need to wait for it\n    const pendingMinMs =\n      route.options.pendingMinMs ?? router.options.defaultPendingMinMs\n    if (pendingMinMs) {\n      const routerMatch = router.getMatch(match.id)\n      if (routerMatch && !routerMatch._nonReactive.minPendingPromise) {\n        // Create a promise that will resolve after the minPendingMs\n        if (!router.isServer) {\n          const minPendingPromise = createControlledPromise<void>()\n\n          routerMatch._nonReactive.minPendingPromise = minPendingPromise\n\n          setTimeout(() => {\n            minPendingPromise.resolve()\n            // We've handled the minPendingPromise, so we can delete it\n            routerMatch._nonReactive.minPendingPromise = undefined\n          }, pendingMinMs)\n        }\n      }\n    }\n    throw router.getMatch(match.id)?._nonReactive.loadPromise\n  }\n\n  if (match.status === 'notFound') {\n    invariant(isNotFound(match.error), 'Expected a notFound error')\n    return renderRouteNotFound(router, route, match.error)\n  }\n\n  if (match.status === 'redirected') {\n    // Redirects should be handled by the router transition. If we happen to\n    // encounter a redirect here, it's a bug. Let's warn, but render nothing.\n    invariant(isRedirect(match.error), 'Expected a redirect error')\n\n    // warning(\n    //   false,\n    //   'Tried to render a redirected route match! This is a weird circumstance, please file an issue!',\n    // )\n    throw router.getMatch(match.id)?._nonReactive.loadPromise\n  }\n\n  if (match.status === 'error') {\n    // If we're on the server, we need to use React's new and super\n    // wonky api for throwing errors from a server side render inside\n    // of a suspense boundary. This is the only way to get\n    // renderToPipeableStream to not hang indefinitely.\n    // We'll serialize the error and rethrow it on the client.\n    if (router.isServer) {\n      const RouteErrorComponent =\n        (route.options.errorComponent ??\n          router.options.defaultErrorComponent) ||\n        ErrorComponent\n      return (\n        <RouteErrorComponent\n          error={match.error as any}\n          reset={undefined as any}\n          info={{\n            componentStack: '',\n          }}\n        />\n      )\n    }\n\n    throw match.error\n  }\n\n  return out\n})\n\n/**\n * Render the next child match in the route tree. Typically used inside\n * a route component to render nested routes.\n *\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/outletComponent\n */\nexport const Outlet = React.memo(function OutletImpl() {\n  const router = useRouter()\n  const matchId = React.useContext(matchContext)\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const parentGlobalNotFound = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const parentMatch = matches.find((d) => d.id === matchId)\n      invariant(\n        parentMatch,\n        `Could not find parent match for matchId \"${matchId}\"`,\n      )\n      return parentMatch.globalNotFound\n    },\n  })\n\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const index = matches.findIndex((d) => d.id === matchId)\n      return matches[index + 1]?.id\n    },\n  })\n\n  const pendingElement = router.options.defaultPendingComponent ? (\n    <router.options.defaultPendingComponent />\n  ) : null\n\n  if (parentGlobalNotFound) {\n    return renderRouteNotFound(router, route, undefined)\n  }\n\n  if (!childMatchId) {\n    return null\n  }\n\n  const nextMatch = <Match matchId={childMatchId} />\n\n  if (routeId === rootRouteId) {\n    return (\n      <React.Suspense fallback={pendingElement}>{nextMatch}</React.Suspense>\n    )\n  }\n\n  return nextMatch\n})\n"],"names":["match","routeId","key"],"mappings":";;;;;;;;;;;;;;AAyBO,MAAM,QAAQ,MAAM,KAAK,SAAS,UAAU;AAAA,EACjD;AACF,GAEG;AACD,QAAM,SAAS,UAAA;AACf,QAAM,aAAa,eAAe;AAAA,IAChC,QAAQ,CAAC,MAAM;AACb,YAAM,QAAQ,EAAE,QAAQ,KAAK,CAAC,MAAM,EAAE,OAAO,OAAO;AACpD;AAAA,QACE;AAAA,QACA,qCAAqC,OAAO;AAAA,MAAA;AAE9C,aAAO;AAAA,QACL,SAAS,MAAM;AAAA,QACf,KAAK,MAAM;AAAA,QACX,iBAAiB,MAAM;AAAA,MAAA;AAAA,IAE3B;AAAA,IACA,mBAAmB;AAAA,EAAA,CACpB;AAED,QAAM,QAAkB,OAAO,WAAW,WAAW,OAAO;AAE5D,QAAM,mBACJ,MAAM,QAAQ,oBAAoB,OAAO,QAAQ;AAEnD,QAAM,iBAAiB,mBAAmB,oBAAC,kBAAA,CAAA,CAAiB,IAAK;AAEjE,QAAM,sBACJ,MAAM,QAAQ,kBAAkB,OAAO,QAAQ;AAEjD,QAAM,eAAe,MAAM,QAAQ,WAAW,OAAO,QAAQ;AAE7D,QAAM,yBAAyB,MAAM;AAAA;AAAA,IAEhC,MAAM,QAAQ,qBACf,OAAO,QAAQ,eAAe,QAAQ;AAAA,MACtC,MAAM,QAAQ;AAElB,QAAM,gBACJ,WAAW,QAAQ,SAAS,WAAW,QAAQ;AACjD,QAAM;AAAA;AAAA,KAEH,CAAC,MAAM,UAAU,MAAM,QAAQ,kBAAkB,mBACjD,MAAM,QAAQ,kBACb,qBACE,MAAM,QAAQ,gBAAwB,WAAW,kBACjD,MAAM,WACN;AAAA;AAEN,QAAM,wBAAwB,sBAC1B,gBACA;AAEJ,QAAM,2BAA2B,yBAC7B,gBACA;AAEJ,QAAM,WAAW,eAAe;AAAA,IAC9B,QAAQ,CAAC,MAAM,EAAE;AAAA,EAAA,CAClB;AAED,QAAM,gBAAgB,eAAe;AAAA,IACnC,QAAQ,CAAC,MAAM;AACb,YAAM,QAAQ,EAAE,QAAQ,UAAU,CAAC,MAAM,EAAE,OAAO,OAAO;AACzD,aAAO,EAAE,QAAQ,QAAQ,CAAC,GAAG;AAAA,IAC/B;AAAA,EAAA,CACD;AAED,QAAM,iBAAiB,MAAM,SACvB,MAAM,QAA6B,kBAAkB,eACvD;AACJ,8BACG,gBAAA,EACC,UAAA;AAAA,IAAA,oBAAC,aAAa,UAAb,EAAsB,OAAO,SAC5B,UAAA,oBAAC,0BAAA,EAAyB,UAAU,gBAClC,UAAA;AAAA,MAAC;AAAA,MAAA;AAAA,QACC,aAAa,MAAM;AAAA,QACnB,gBAAgB,uBAAuB;AAAA,QACvC,SAAS,CAAC,OAAO,cAAc;AAE7B,cAAI,WAAW,KAAK,EAAG,OAAM;AAC7B,kBAAQ,OAAO,yBAAyB,OAAO,EAAE;AACjD,yBAAe,OAAO,SAAS;AAAA,QACjC;AAAA,QAEA,UAAA;AAAA,UAAC;AAAA,UAAA;AAAA,YACC,UAAU,CAAC,UAAU;AAGnB,kBACE,CAAC,0BACA,MAAM,WAAW,MAAM,YAAY,WAAW,WAC9C,CAAC,MAAM,WAAW,CAAC,MAAM;AAE1B,sBAAM;AAER,qBAAO,MAAM,cAAc,wBAAwB,KAAY;AAAA,YACjE;AAAA,YAEC,UAAA,iBAAiB,WAAW,kBAC3B,oBAAC,cAAW,UAAU,gBACpB,UAAA,oBAAC,YAAA,EAAW,SAAkB,EAAA,CAChC,IAEA,oBAAC,cAAW,QAAA,CAAkB;AAAA,UAAA;AAAA,QAAA;AAAA,MAElC;AAAA,IAAA,GAEJ,EAAA,CACF;AAAA,IACC,kBAAkB,eAAe,OAAO,QAAQ,oBAC/C,qBAAA,UAAA,EACE,UAAA;AAAA,MAAA,oBAAC,YAAA,EAAW;AAAA,0BACX,mBAAA,CAAA,CAAkB;AAAA,IAAA,EAAA,CACrB,IACE;AAAA,EAAA,GACN;AAEJ,CAAC;AASD,SAAS,aAAa;AACpB,QAAM,SAAS,UAAA;AAEf,QAAM,kBAAkB,MAAM;AAAA,IAC5B;AAAA,EAAA;AAGF,SACE;AAAA,IAAC;AAAA,IAAA;AAAA,MAEC,0BAAwB;AAAA,MACxB,KAAK,CAAC,OAAO;AACX,YACE,OACC,gBAAgB,YAAY,UAC3B,gBAAgB,QAAQ,SAAS,OAAO,eAAe,OACzD;AACA,iBAAO,KAAK;AAAA,YACV,MAAM;AAAA,YACN,GAAG,sBAAsB,OAAO,KAAK;AAAA,UAAA,CACtC;AACD,0BAAgB,UAAU,OAAO;AAAA,QACnC;AAAA,MACF;AAAA,IAAA;AAAA,IAdK,OAAO,eAAe,MAAM;AAAA,EAAA;AAiBvC;AAEO,MAAM,aAAa,MAAM,KAAK,SAAS,eAAe;AAAA,EAC3D;AACF,GAEQ;AACN,QAAM,SAAS,UAAA;AAEf,QAAM,EAAE,OAAO,KAAK,QAAA,IAAY,eAAe;AAAA,IAC7C,QAAQ,CAAC,MAAM;AACb,YAAMA,SAAQ,EAAE,QAAQ,KAAK,CAAC,MAAM,EAAE,OAAO,OAAO;AACpD,YAAMC,WAAUD,OAAM;AAEtB,YAAM,YACH,OAAO,WAAWC,QAAO,EAAe,QAAQ,eACjD,OAAO,QAAQ;AACjB,YAAM,cAAc,YAAY;AAAA,QAC9B,SAAAA;AAAAA,QACA,YAAYD,OAAM;AAAA,QAClB,QAAQA,OAAM;AAAA,QACd,QAAQA,OAAM;AAAA,MAAA,CACf;AACD,YAAME,OAAM,cAAc,KAAK,UAAU,WAAW,IAAI;AAExD,aAAO;AAAA,QACL,KAAAA;AAAAA,QACA,SAAAD;AAAAA,QACA,OAAO;AAAA,UACL,IAAID,OAAM;AAAA,UACV,QAAQA,OAAM;AAAA,UACd,OAAOA,OAAM;AAAA,UACb,SAASA,OAAM;AAAA,UACf,eAAeA,OAAM;AAAA,UACrB,iBAAiBA,OAAM;AAAA,QAAA;AAAA,MACzB;AAAA,IAEJ;AAAA,IACA,mBAAmB;AAAA,EAAA,CACpB;AAED,QAAM,QAAQ,OAAO,WAAW,OAAO;AAEvC,QAAM,MAAM,MAAM,QAAQ,MAAM;AAC9B,UAAM,OAAO,MAAM,QAAQ,aAAa,OAAO,QAAQ;AACvD,QAAI,MAAM;AACR,aAAO,oBAAC,UAAU,GAAK;AAAA,IACzB;AACA,+BAAQ,QAAA,EAAO;AAAA,EACjB,GAAG,CAAC,KAAK,MAAM,QAAQ,WAAW,OAAO,QAAQ,gBAAgB,CAAC;AAElE,MAAI,MAAM,iBAAiB;AACzB,UAAM,OAAO,SAAS,MAAM,EAAE,GAAG,aAAa;AAAA,EAChD;AAEA,MAAI,MAAM,eAAe;AACvB,UAAM,OAAO,SAAS,MAAM,EAAE,GAAG,aAAa;AAAA,EAChD;AAGA,MAAI,MAAM,WAAW,WAAW;AAE9B,UAAM,eACJ,MAAM,QAAQ,gBAAgB,OAAO,QAAQ;AAC/C,QAAI,cAAc;AAChB,YAAM,cAAc,OAAO,SAAS,MAAM,EAAE;AAC5C,UAAI,eAAe,CAAC,YAAY,aAAa,mBAAmB;AAE9D,YAAI,CAAC,OAAO,UAAU;AACpB,gBAAM,oBAAoB,wBAAA;AAE1B,sBAAY,aAAa,oBAAoB;AAE7C,qBAAW,MAAM;AACf,8BAAkB,QAAA;AAElB,wBAAY,aAAa,oBAAoB;AAAA,UAC/C,GAAG,YAAY;AAAA,QACjB;AAAA,MACF;AAAA,IACF;AACA,UAAM,OAAO,SAAS,MAAM,EAAE,GAAG,aAAa;AAAA,EAChD;AAEA,MAAI,MAAM,WAAW,YAAY;AAC/B,cAAU,WAAW,MAAM,KAAK,GAAG,2BAA2B;AAC9D,WAAO,oBAAoB,QAAQ,OAAO,MAAM,KAAK;AAAA,EACvD;AAEA,MAAI,MAAM,WAAW,cAAc;AAGjC,cAAU,WAAW,MAAM,KAAK,GAAG,2BAA2B;AAM9D,UAAM,OAAO,SAAS,MAAM,EAAE,GAAG,aAAa;AAAA,EAChD;AAEA,MAAI,MAAM,WAAW,SAAS;AAM5B,QAAI,OAAO,UAAU;AACnB,YAAM,uBACH,MAAM,QAAQ,kBACb,OAAO,QAAQ,0BACjB;AACF,aACE;AAAA,QAAC;AAAA,QAAA;AAAA,UACC,OAAO,MAAM;AAAA,UACb,OAAO;AAAA,UACP,MAAM;AAAA,YACJ,gBAAgB;AAAA,UAAA;AAAA,QAClB;AAAA,MAAA;AAAA,IAGN;AAEA,UAAM,MAAM;AAAA,EACd;AAEA,SAAO;AACT,CAAC;AAQM,MAAM,SAAS,MAAM,KAAK,SAAS,aAAa;AACrD,QAAM,SAAS,UAAA;AACf,QAAM,UAAU,MAAM,WAAW,YAAY;AAC7C,QAAM,UAAU,eAAe;AAAA,IAC7B,QAAQ,CAAC,MAAM,EAAE,QAAQ,KAAK,CAAC,MAAM,EAAE,OAAO,OAAO,GAAG;AAAA,EAAA,CACzD;AAED,QAAM,QAAQ,OAAO,WAAW,OAAO;AAEvC,QAAM,uBAAuB,eAAe;AAAA,IAC1C,QAAQ,CAAC,MAAM;AACb,YAAM,UAAU,EAAE;AAClB,YAAM,cAAc,QAAQ,KAAK,CAAC,MAAM,EAAE,OAAO,OAAO;AACxD;AAAA,QACE;AAAA,QACA,4CAA4C,OAAO;AAAA,MAAA;AAErD,aAAO,YAAY;AAAA,IACrB;AAAA,EAAA,CACD;AAED,QAAM,eAAe,eAAe;AAAA,IAClC,QAAQ,CAAC,MAAM;AACb,YAAM,UAAU,EAAE;AAClB,YAAM,QAAQ,QAAQ,UAAU,CAAC,MAAM,EAAE,OAAO,OAAO;AACvD,aAAO,QAAQ,QAAQ,CAAC,GAAG;AAAA,IAC7B;AAAA,EAAA,CACD;AAED,QAAM,iBAAiB,OAAO,QAAQ,8CACnC,OAAO,QAAQ,yBAAf,CAAA,CAAuC,IACtC;AAEJ,MAAI,sBAAsB;AACxB,WAAO,oBAAoB,QAAQ,OAAO,MAAS;AAAA,EACrD;AAEA,MAAI,CAAC,cAAc;AACjB,WAAO;AAAA,EACT;AAEA,QAAM,YAAY,oBAAC,OAAA,EAAM,SAAS,aAAA,CAAc;AAEhD,MAAI,YAAY,aAAa;AAC3B,+BACG,MAAM,UAAN,EAAe,UAAU,gBAAiB,UAAA,WAAU;AAAA,EAEzD;AAEA,SAAO;AACT,CAAC;"}