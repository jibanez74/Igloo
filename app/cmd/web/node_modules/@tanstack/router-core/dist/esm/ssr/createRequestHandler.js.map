{"version":3,"file":"createRequestHandler.js","sources":["../../../src/ssr/createRequestHandler.ts"],"sourcesContent":["import { createMemoryHistory } from '@tanstack/history'\nimport { mergeHeaders } from './headers'\nimport {\n  attachRouterServerSsrUtils,\n  getNormalizedURL,\n  getOrigin,\n} from './ssr-server'\nimport type { HandlerCallback } from './handlerCallback'\nimport type { AnyRouter } from '../router'\nimport type { Manifest } from '../manifest'\n\nexport type RequestHandler<TRouter extends AnyRouter> = (\n  cb: HandlerCallback<TRouter>,\n) => Promise<Response>\n\nexport function createRequestHandler<TRouter extends AnyRouter>({\n  createRouter,\n  request,\n  getRouterManifest,\n}: {\n  createRouter: () => TRouter\n  request: Request\n  getRouterManifest?: () => Manifest | Promise<Manifest>\n}): RequestHandler<TRouter> {\n  return async (cb) => {\n    const router = createRouter()\n    // Track whether the callback will handle cleanup\n    let cbWillCleanup = false\n\n    try {\n      attachRouterServerSsrUtils({\n        router,\n        manifest: await getRouterManifest?.(),\n      })\n\n      // normalizing and sanitizing the pathname here for server, so we always deal with the same format during SSR.\n      const url = getNormalizedURL(request.url, 'http://localhost')\n      const origin = getOrigin(request)\n      const href = url.href.replace(url.origin, '')\n\n      // Create a history for the router\n      const history = createMemoryHistory({\n        initialEntries: [href],\n      })\n\n      // Update the router with the history and context\n      router.update({\n        history,\n        origin: router.options.origin ?? origin,\n      })\n\n      await router.load()\n\n      await router.serverSsr?.dehydrate()\n\n      const responseHeaders = getRequestHeaders({\n        router,\n      })\n\n      // Mark that the callback will handle cleanup\n      cbWillCleanup = true\n      return cb({\n        request,\n        router,\n        responseHeaders,\n      } as any)\n    } finally {\n      if (!cbWillCleanup) {\n        // Clean up router SSR state if the callback won't handle it\n        // (e.g., if an error occurred before the callback was invoked).\n        // When the callback runs, it handles cleanup (either via transformStreamWithRouter\n        // for streaming, or directly in renderRouterToString for non-streaming).\n        router.serverSsr?.cleanup()\n      }\n    }\n  }\n}\n\nfunction getRequestHeaders(opts: { router: AnyRouter }): Headers {\n  let headers = mergeHeaders(\n    {\n      'Content-Type': 'text/html; charset=UTF-8',\n    },\n    ...opts.router.state.matches.map((match) => {\n      return match.headers\n    }),\n  )\n\n  // Handle Redirects\n  const { redirect } = opts.router.state\n\n  if (redirect) {\n    headers = mergeHeaders(headers, redirect.headers)\n  }\n\n  return headers\n}\n"],"names":[],"mappings":";;;AAeO,SAAS,qBAAgD;AAAA,EAC9D;AAAA,EACA;AAAA,EACA;AACF,GAI4B;AAC1B,SAAO,OAAO,OAAO;AACnB,UAAM,SAAS,aAAA;AAEf,QAAI,gBAAgB;AAEpB,QAAI;AACF,iCAA2B;AAAA,QACzB;AAAA,QACA,UAAU,MAAM,oBAAA;AAAA,MAAoB,CACrC;AAGD,YAAM,MAAM,iBAAiB,QAAQ,KAAK,kBAAkB;AAC5D,YAAM,SAAS,UAAU,OAAO;AAChC,YAAM,OAAO,IAAI,KAAK,QAAQ,IAAI,QAAQ,EAAE;AAG5C,YAAM,UAAU,oBAAoB;AAAA,QAClC,gBAAgB,CAAC,IAAI;AAAA,MAAA,CACtB;AAGD,aAAO,OAAO;AAAA,QACZ;AAAA,QACA,QAAQ,OAAO,QAAQ,UAAU;AAAA,MAAA,CAClC;AAED,YAAM,OAAO,KAAA;AAEb,YAAM,OAAO,WAAW,UAAA;AAExB,YAAM,kBAAkB,kBAAkB;AAAA,QACxC;AAAA,MAAA,CACD;AAGD,sBAAgB;AAChB,aAAO,GAAG;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MAAA,CACM;AAAA,IACV,UAAA;AACE,UAAI,CAAC,eAAe;AAKlB,eAAO,WAAW,QAAA;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,kBAAkB,MAAsC;AAC/D,MAAI,UAAU;AAAA,IACZ;AAAA,MACE,gBAAgB;AAAA,IAAA;AAAA,IAElB,GAAG,KAAK,OAAO,MAAM,QAAQ,IAAI,CAAC,UAAU;AAC1C,aAAO,MAAM;AAAA,IACf,CAAC;AAAA,EAAA;AAIH,QAAM,EAAE,SAAA,IAAa,KAAK,OAAO;AAEjC,MAAI,UAAU;AACZ,cAAU,aAAa,SAAS,SAAS,OAAO;AAAA,EAClD;AAEA,SAAO;AACT;"}