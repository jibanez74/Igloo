{"version":3,"file":"transformer.js","sources":["../../../../src/ssr/serializer/transformer.ts"],"sourcesContent":["import { createPlugin } from 'seroval'\nimport { GLOBAL_TSR } from '../constants'\nimport type { Plugin, SerovalNode } from 'seroval'\nimport type {\n  RegisteredConfigType,\n  RegisteredSsr,\n  SSROption,\n} from '../../router'\nimport type { LooseReturnType } from '../../utils'\nimport type { AnyRoute, ResolveAllSSR } from '../../route'\nimport type { RawStream } from './RawStream'\n\ndeclare const TSR_SERIALIZABLE: unique symbol\nexport type TSR_SERIALIZABLE = typeof TSR_SERIALIZABLE\n\nexport type TsrSerializable = { [TSR_SERIALIZABLE]: true }\nexport interface DefaultSerializable {\n  number: number\n  string: string\n  boolean: boolean\n  null: null\n  undefined: undefined\n  bigint: bigint\n  Date: Date\n  Uint8Array: Uint8Array\n  RawStream: RawStream\n  TsrSerializable: TsrSerializable\n}\n\nexport interface SerializableExtensions extends DefaultSerializable {}\n\nexport type Serializable = SerializableExtensions[keyof SerializableExtensions]\n\nexport type UnionizeSerializationAdaptersInput<\n  TAdapters extends ReadonlyArray<AnySerializationAdapter>,\n> = TAdapters[number]['~types']['input']\n\n/**\n * Create a strongly-typed serialization adapter for SSR hydration.\n * Use to register custom types with the router serializer.\n */\nexport function createSerializationAdapter<\n  TInput = unknown,\n  TOutput = unknown,\n  const TExtendsAdapters extends\n    | ReadonlyArray<AnySerializationAdapter>\n    | never = never,\n>(\n  opts: CreateSerializationAdapterOptions<TInput, TOutput, TExtendsAdapters>,\n): SerializationAdapter<TInput, TOutput, TExtendsAdapters> {\n  return opts as unknown as SerializationAdapter<\n    TInput,\n    TOutput,\n    TExtendsAdapters\n  >\n}\n\nexport interface CreateSerializationAdapterOptions<\n  TInput,\n  TOutput,\n  TExtendsAdapters extends ReadonlyArray<AnySerializationAdapter> | never,\n> {\n  key: string\n  extends?: TExtendsAdapters\n  test: (value: unknown) => value is TInput\n  toSerializable: (\n    value: TInput,\n  ) => ValidateSerializable<\n    TOutput,\n    Serializable | UnionizeSerializationAdaptersInput<TExtendsAdapters>\n  >\n  fromSerializable: (value: TOutput) => TInput\n}\n\nexport type ValidateSerializable<T, TSerializable> =\n  T extends ReadonlyArray<unknown>\n    ? ResolveArrayShape<T, TSerializable, 'input'>\n    : T extends TSerializable\n      ? T\n      : T extends (...args: Array<any>) => any\n        ? 'Function is not serializable'\n        : T extends Promise<any>\n          ? ValidateSerializablePromise<T, TSerializable>\n          : T extends ReadableStream<any>\n            ? ValidateReadableStream<T, TSerializable>\n            : T extends Set<any>\n              ? ValidateSerializableSet<T, TSerializable>\n              : T extends Map<any, any>\n                ? ValidateSerializableMap<T, TSerializable>\n                : T extends AsyncGenerator<any, any>\n                  ? ValidateSerializableAsyncGenerator<T, TSerializable>\n                  : {\n                      [K in keyof T]: ValidateSerializable<T[K], TSerializable>\n                    }\n\nexport type ValidateSerializableAsyncGenerator<T, TSerializable> =\n  T extends AsyncGenerator<infer T, infer TReturn, infer TNext>\n    ? AsyncGenerator<\n        ValidateSerializable<T, TSerializable>,\n        ValidateSerializable<TReturn, TSerializable>,\n        TNext\n      >\n    : never\n\nexport type ValidateSerializablePromise<T, TSerializable> =\n  T extends Promise<infer TAwaited>\n    ? Promise<ValidateSerializable<TAwaited, TSerializable>>\n    : never\n\nexport type ValidateReadableStream<T, TSerializable> =\n  T extends ReadableStream<infer TStreamed>\n    ? ReadableStream<ValidateSerializable<TStreamed, TSerializable>>\n    : never\n\nexport type ValidateSerializableSet<T, TSerializable> =\n  T extends Set<infer TItem>\n    ? Set<ValidateSerializable<TItem, TSerializable>>\n    : never\n\nexport type ValidateSerializableMap<T, TSerializable> =\n  T extends Map<infer TKey, infer TValue>\n    ? Map<\n        ValidateSerializable<TKey, TSerializable>,\n        ValidateSerializable<TValue, TSerializable>\n      >\n    : never\n\nexport type RegisteredReadableStream =\n  unknown extends SerializerExtensions['ReadableStream']\n    ? never\n    : SerializerExtensions['ReadableStream']\n\nexport interface DefaultSerializerExtensions {\n  ReadableStream: unknown\n}\n\nexport interface SerializerExtensions extends DefaultSerializerExtensions {}\n\nexport interface SerializationAdapter<\n  TInput,\n  TOutput,\n  TExtendsAdapters extends ReadonlyArray<AnySerializationAdapter>,\n> {\n  '~types': SerializationAdapterTypes<TInput, TOutput, TExtendsAdapters>\n  key: string\n  extends?: TExtendsAdapters\n  test: (value: unknown) => value is TInput\n  toSerializable: (value: TInput) => TOutput\n  fromSerializable: (value: TOutput) => TInput\n}\n\nexport interface SerializationAdapterTypes<\n  TInput,\n  TOutput,\n  TExtendsAdapters extends ReadonlyArray<AnySerializationAdapter>,\n> {\n  input: TInput | UnionizeSerializationAdaptersInput<TExtendsAdapters>\n  output: TOutput\n  extends: TExtendsAdapters\n}\n\nexport type AnySerializationAdapter = SerializationAdapter<any, any, any>\n\n/** Create a Seroval plugin for server-side serialization only. */\nexport function makeSsrSerovalPlugin(\n  serializationAdapter: AnySerializationAdapter,\n  options: { didRun: boolean },\n): Plugin<any, SerovalNode> {\n  return createPlugin<any, SerovalNode>({\n    tag: '$TSR/t/' + serializationAdapter.key,\n    test: serializationAdapter.test,\n    parse: {\n      stream(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value))\n      },\n    },\n    serialize(node, ctx) {\n      options.didRun = true\n      return (\n        GLOBAL_TSR +\n        '.t.get(\"' +\n        serializationAdapter.key +\n        '\")(' +\n        ctx.serialize(node) +\n        ')'\n      )\n    },\n    // we never deserialize on the server during SSR\n    deserialize: undefined as never,\n  })\n}\n\n/** Create a Seroval plugin for client/server symmetric (de)serialization. */\nexport function makeSerovalPlugin(\n  serializationAdapter: AnySerializationAdapter,\n): Plugin<any, SerovalNode> {\n  return createPlugin<any, SerovalNode>({\n    tag: '$TSR/t/' + serializationAdapter.key,\n    test: serializationAdapter.test,\n    parse: {\n      sync(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value))\n      },\n      async async(value, ctx) {\n        return await ctx.parse(serializationAdapter.toSerializable(value))\n      },\n      stream(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value))\n      },\n    },\n    // we don't generate JS code outside of SSR (for now)\n    serialize: undefined as never,\n    deserialize(node, ctx) {\n      return serializationAdapter.fromSerializable(ctx.deserialize(node))\n    },\n  })\n}\n\nexport type ValidateSerializableInput<TRegister, T> = ValidateSerializable<\n  T,\n  RegisteredSerializableInput<TRegister>\n>\n\nexport type RegisteredSerializableInput<TRegister> =\n  | (unknown extends RegisteredSerializationAdapters<TRegister>\n      ? never\n      : RegisteredSerializationAdapters<TRegister> extends ReadonlyArray<AnySerializationAdapter>\n        ? RegisteredSerializationAdapters<TRegister>[number]['~types']['input']\n        : never)\n  | Serializable\n\nexport type RegisteredSerializationAdapters<TRegister> = RegisteredConfigType<\n  TRegister,\n  'serializationAdapters'\n>\n\nexport type ValidateSerializableInputResult<TRegister, T> =\n  ValidateSerializableResult<T, RegisteredSerializableInput<TRegister>>\n\nexport type ValidateSerializableResult<T, TSerializable> =\n  T extends ReadonlyArray<unknown>\n    ? ResolveArrayShape<T, TSerializable, 'result'>\n    : T extends TSerializable\n      ? T\n      : unknown extends SerializerExtensions['ReadableStream']\n        ? { [K in keyof T]: ValidateSerializableResult<T[K], TSerializable> }\n        : T extends SerializerExtensions['ReadableStream']\n          ? ReadableStream\n          : { [K in keyof T]: ValidateSerializableResult<T[K], TSerializable> }\n\nexport type RegisteredSSROption<TRegister> =\n  unknown extends RegisteredConfigType<TRegister, 'defaultSsr'>\n    ? SSROption\n    : RegisteredConfigType<TRegister, 'defaultSsr'>\n\nexport type ValidateSerializableLifecycleResult<\n  TRegister,\n  TParentRoute extends AnyRoute,\n  TSSR,\n  TFn,\n> =\n  false extends RegisteredSsr<TRegister>\n    ? any\n    : ValidateSerializableLifecycleResultSSR<\n          TRegister,\n          TParentRoute,\n          TSSR,\n          TFn\n        > extends infer TInput\n      ? TInput\n      : never\n\nexport type ValidateSerializableLifecycleResultSSR<\n  TRegister,\n  TParentRoute extends AnyRoute,\n  TSSR,\n  TFn,\n> =\n  ResolveAllSSR<TParentRoute, TSSR> extends false\n    ? any\n    : RegisteredSSROption<TRegister> extends false\n      ? any\n      : ValidateSerializableInput<TRegister, LooseReturnType<TFn>>\n\ntype ResolveArrayShape<\n  T extends ReadonlyArray<unknown>,\n  TSerializable,\n  TMode extends 'input' | 'result',\n> = number extends T['length']\n  ? T extends Array<infer U>\n    ? Array<ArrayModeResult<TMode, U, TSerializable>>\n    : ReadonlyArray<ArrayModeResult<TMode, T[number], TSerializable>>\n  : ResolveTupleShape<T, TSerializable, TMode>\n\ntype ResolveTupleShape<\n  T extends ReadonlyArray<unknown>,\n  TSerializable,\n  TMode extends 'input' | 'result',\n> = T extends readonly [infer THead, ...infer TTail]\n  ? readonly [\n      ArrayModeResult<TMode, THead, TSerializable>,\n      ...ResolveTupleShape<Readonly<TTail>, TSerializable, TMode>,\n    ]\n  : T\n\ntype ArrayModeResult<\n  TMode extends 'input' | 'result',\n  TValue,\n  TSerializable,\n> = TMode extends 'input'\n  ? ValidateSerializable<TValue, TSerializable>\n  : ValidateSerializableResult<TValue, TSerializable>\n"],"names":[],"mappings":";;AAyCO,SAAS,2BAOd,MACyD;AACzD,SAAO;AAKT;AA6GO,SAAS,qBACd,sBACA,SAC0B;AAC1B,SAAO,aAA+B;AAAA,IACpC,KAAK,YAAY,qBAAqB;AAAA,IACtC,MAAM,qBAAqB;AAAA,IAC3B,OAAO;AAAA,MACL,OAAO,OAAO,KAAK;AACjB,eAAO,IAAI,MAAM,qBAAqB,eAAe,KAAK,CAAC;AAAA,MAC7D;AAAA,IAAA;AAAA,IAEF,UAAU,MAAM,KAAK;AACnB,cAAQ,SAAS;AACjB,aACE,aACA,aACA,qBAAqB,MACrB,QACA,IAAI,UAAU,IAAI,IAClB;AAAA,IAEJ;AAAA;AAAA,IAEA,aAAa;AAAA,EAAA,CACd;AACH;AAGO,SAAS,kBACd,sBAC0B;AAC1B,SAAO,aAA+B;AAAA,IACpC,KAAK,YAAY,qBAAqB;AAAA,IACtC,MAAM,qBAAqB;AAAA,IAC3B,OAAO;AAAA,MACL,KAAK,OAAO,KAAK;AACf,eAAO,IAAI,MAAM,qBAAqB,eAAe,KAAK,CAAC;AAAA,MAC7D;AAAA,MACA,MAAM,MAAM,OAAO,KAAK;AACtB,eAAO,MAAM,IAAI,MAAM,qBAAqB,eAAe,KAAK,CAAC;AAAA,MACnE;AAAA,MACA,OAAO,OAAO,KAAK;AACjB,eAAO,IAAI,MAAM,qBAAqB,eAAe,KAAK,CAAC;AAAA,MAC7D;AAAA,IAAA;AAAA;AAAA,IAGF,WAAW;AAAA,IACX,YAAY,MAAM,KAAK;AACrB,aAAO,qBAAqB,iBAAiB,IAAI,YAAY,IAAI,CAAC;AAAA,IACpE;AAAA,EAAA,CACD;AACH;"}