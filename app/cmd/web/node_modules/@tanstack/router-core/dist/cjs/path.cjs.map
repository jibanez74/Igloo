{"version":3,"file":"path.cjs","sources":["../../src/path.ts"],"sourcesContent":["import { last } from './utils'\nimport {\n  SEGMENT_TYPE_OPTIONAL_PARAM,\n  SEGMENT_TYPE_PARAM,\n  SEGMENT_TYPE_PATHNAME,\n  SEGMENT_TYPE_WILDCARD,\n  parseSegment,\n} from './new-process-route-tree'\nimport type { LRUCache } from './lru-cache'\n\n/** Join path segments, cleaning duplicate slashes between parts. */\nexport function joinPaths(paths: Array<string | undefined>) {\n  return cleanPath(\n    paths\n      .filter((val) => {\n        return val !== undefined\n      })\n      .join('/'),\n  )\n}\n\n/** Remove repeated slashes from a path string. */\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\n/** Trim leading slashes (except preserving root '/'). */\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\n/** Trim trailing slashes (except preserving root '/'). */\nexport function trimPathRight(path: string) {\n  const len = path.length\n  return len > 1 && path[len - 1] === '/' ? path.replace(/\\/{1,}$/, '') : path\n}\n\n/** Trim both leading and trailing slashes. */\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\n/** Remove a trailing slash from value when appropriate for comparisons. */\nexport function removeTrailingSlash(value: string, basepath: string): string {\n  if (value?.endsWith('/') && value !== '/' && value !== `${basepath}/`) {\n    return value.slice(0, -1)\n  }\n  return value\n}\n\n// intended to only compare path name\n// see the usage in the isActive under useLinkProps\n// /sample/path1 = /sample/path1/\n// /sample/path1/some <> /sample/path1\n/**\n * Compare two pathnames for exact equality after normalizing trailing slashes\n * relative to the provided `basepath`.\n */\nexport function exactPathTest(\n  pathName1: string,\n  pathName2: string,\n  basepath: string,\n): boolean {\n  return (\n    removeTrailingSlash(pathName1, basepath) ===\n    removeTrailingSlash(pathName2, basepath)\n  )\n}\n\n// When resolving relative paths, we treat all paths as if they are trailing slash\n// documents. All trailing slashes are removed after the path is resolved.\n// Here are a few examples:\n//\n// /a/b/c + ./d = /a/b/c/d\n// /a/b/c + ../d = /a/b/d\n// /a/b/c + ./d/ = /a/b/c/d\n// /a/b/c + ../d/ = /a/b/d\n// /a/b/c + ./ = /a/b/c\n//\n// Absolute paths that start with `/` short circuit the resolution process to the root\n// path.\n//\n// Here are some examples:\n//\n// /a/b/c + /d = /d\n// /a/b/c + /d/ = /d\n// /a/b/c + / = /\n//\n// Non-.-prefixed paths are still treated as relative paths, resolved like `./`\n//\n// Here are some examples:\n//\n// /a/b/c + d = /a/b/c/d\n// /a/b/c + d/ = /a/b/c/d\n// /a/b/c + d/e = /a/b/c/d/e\ninterface ResolvePathOptions {\n  base: string\n  to: string\n  trailingSlash?: 'always' | 'never' | 'preserve'\n  cache?: LRUCache<string, string>\n}\n\n/**\n * Resolve a destination path against a base, honoring trailing-slash policy\n * and supporting relative segments (`.`/`..`) and absolute `to` values.\n */\nexport function resolvePath({\n  base,\n  to,\n  trailingSlash = 'never',\n  cache,\n}: ResolvePathOptions) {\n  const isAbsolute = to.startsWith('/')\n  const isBase = !isAbsolute && to === '.'\n\n  let key\n  if (cache) {\n    // `trailingSlash` is static per router, so it doesn't need to be part of the cache key\n    key = isAbsolute ? to : isBase ? base : base + '\\0' + to\n    const cached = cache.get(key)\n    if (cached) return cached\n  }\n\n  let baseSegments: Array<string>\n  if (isBase) {\n    baseSegments = base.split('/')\n  } else if (isAbsolute) {\n    baseSegments = to.split('/')\n  } else {\n    baseSegments = base.split('/')\n    while (baseSegments.length > 1 && last(baseSegments) === '') {\n      baseSegments.pop()\n    }\n\n    const toSegments = to.split('/')\n    for (let index = 0, length = toSegments.length; index < length; index++) {\n      const value = toSegments[index]!\n      if (value === '') {\n        if (!index) {\n          // Leading slash\n          baseSegments = [value]\n        } else if (index === length - 1) {\n          // Trailing Slash\n          baseSegments.push(value)\n        } else {\n          // ignore inter-slashes\n        }\n      } else if (value === '..') {\n        baseSegments.pop()\n      } else if (value === '.') {\n        // ignore\n      } else {\n        baseSegments.push(value)\n      }\n    }\n  }\n\n  if (baseSegments.length > 1) {\n    if (last(baseSegments) === '') {\n      if (trailingSlash === 'never') {\n        baseSegments.pop()\n      }\n    } else if (trailingSlash === 'always') {\n      baseSegments.push('')\n    }\n  }\n\n  let segment\n  let joined = ''\n  for (let i = 0; i < baseSegments.length; i++) {\n    if (i > 0) joined += '/'\n    const part = baseSegments[i]!\n    if (!part) continue\n    segment = parseSegment(part, 0, segment)\n    const kind = segment[0]\n    if (kind === SEGMENT_TYPE_PATHNAME) {\n      joined += part\n      continue\n    }\n    const end = segment[5]\n    const prefix = part.substring(0, segment[1])\n    const suffix = part.substring(segment[4], end)\n    const value = part.substring(segment[2], segment[3])\n    if (kind === SEGMENT_TYPE_PARAM) {\n      joined += prefix || suffix ? `${prefix}{$${value}}${suffix}` : `$${value}`\n    } else if (kind === SEGMENT_TYPE_WILDCARD) {\n      joined += prefix || suffix ? `${prefix}{$}${suffix}` : '$'\n    } else {\n      // SEGMENT_TYPE_OPTIONAL_PARAM\n      joined += `${prefix}{-$${value}}${suffix}`\n    }\n  }\n  joined = cleanPath(joined)\n  const result = joined || '/'\n  if (key && cache) cache.set(key, result)\n  return result\n}\n\ninterface InterpolatePathOptions {\n  path?: string\n  params: Record<string, unknown>\n  // Map of encoded chars to decoded chars (e.g. '%40' -> '@') that should remain decoded in path params\n  decodeCharMap?: Map<string, string>\n}\n\ntype InterPolatePathResult = {\n  interpolatedPath: string\n  usedParams: Record<string, unknown>\n  isMissingParams: boolean // true if any params were not available when being looked up in the params object\n}\n\nfunction encodeParam(\n  key: string,\n  params: InterpolatePathOptions['params'],\n  decodeCharMap: InterpolatePathOptions['decodeCharMap'],\n): any {\n  const value = params[key]\n  if (typeof value !== 'string') return value\n\n  if (key === '_splat') {\n    // the splat/catch-all routes shouldn't have the '/' encoded out\n    return encodeURI(value)\n  } else {\n    return encodePathParam(value, decodeCharMap)\n  }\n}\n\n/**\n * Interpolate params and wildcards into a route path template.\n *\n * - Encodes params safely (configurable allowed characters)\n * - Supports `{-$optional}` segments, `{prefix{$id}suffix}` and `{$}` wildcards\n */\nexport function interpolatePath({\n  path,\n  params,\n  decodeCharMap,\n}: InterpolatePathOptions): InterPolatePathResult {\n  // Tracking if any params are missing in the `params` object\n  // when interpolating the path\n  let isMissingParams = false\n  const usedParams: Record<string, unknown> = {}\n\n  if (!path || path === '/')\n    return { interpolatedPath: '/', usedParams, isMissingParams }\n  if (!path.includes('$'))\n    return { interpolatedPath: path, usedParams, isMissingParams }\n\n  const length = path.length\n  let cursor = 0\n  let segment\n  let joined = ''\n  while (cursor < length) {\n    const start = cursor\n    segment = parseSegment(path, start, segment)\n    const end = segment[5]\n    cursor = end + 1\n\n    if (start === end) continue\n\n    const kind = segment[0]\n\n    if (kind === SEGMENT_TYPE_PATHNAME) {\n      joined += '/' + path.substring(start, end)\n      continue\n    }\n\n    if (kind === SEGMENT_TYPE_WILDCARD) {\n      const splat = params._splat\n      usedParams._splat = splat\n      // TODO: Deprecate *\n      usedParams['*'] = splat\n\n      const prefix = path.substring(start, segment[1])\n      const suffix = path.substring(segment[4], end)\n\n      // Check if _splat parameter is missing. _splat could be missing if undefined or an empty string or some other falsy value.\n      if (!splat) {\n        isMissingParams = true\n        // For missing splat parameters, just return the prefix and suffix without the wildcard\n        // If there is a prefix or suffix, return them joined, otherwise omit the segment\n        if (prefix || suffix) {\n          joined += '/' + prefix + suffix\n        }\n        continue\n      }\n\n      const value = encodeParam('_splat', params, decodeCharMap)\n      joined += '/' + prefix + value + suffix\n      continue\n    }\n\n    if (kind === SEGMENT_TYPE_PARAM) {\n      const key = path.substring(segment[2], segment[3])\n      if (!isMissingParams && !(key in params)) {\n        isMissingParams = true\n      }\n      usedParams[key] = params[key]\n\n      const prefix = path.substring(start, segment[1])\n      const suffix = path.substring(segment[4], end)\n      const value = encodeParam(key, params, decodeCharMap) ?? 'undefined'\n      joined += '/' + prefix + value + suffix\n      continue\n    }\n\n    if (kind === SEGMENT_TYPE_OPTIONAL_PARAM) {\n      const key = path.substring(segment[2], segment[3])\n      const valueRaw = params[key]\n\n      // Check if optional parameter is missing or undefined\n      if (valueRaw == null) continue\n\n      usedParams[key] = valueRaw\n\n      const prefix = path.substring(start, segment[1])\n      const suffix = path.substring(segment[4], end)\n      const value = encodeParam(key, params, decodeCharMap) ?? ''\n      joined += '/' + prefix + value + suffix\n      continue\n    }\n  }\n\n  if (path.endsWith('/')) joined += '/'\n\n  const interpolatedPath = joined || '/'\n\n  return { usedParams, interpolatedPath, isMissingParams }\n}\n\nfunction encodePathParam(value: string, decodeCharMap?: Map<string, string>) {\n  let encoded = encodeURIComponent(value)\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char)\n    }\n  }\n  return encoded\n}\n"],"names":["last","parseSegment","SEGMENT_TYPE_PATHNAME","SEGMENT_TYPE_PARAM","SEGMENT_TYPE_WILDCARD","SEGMENT_TYPE_OPTIONAL_PARAM"],"mappings":"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"}