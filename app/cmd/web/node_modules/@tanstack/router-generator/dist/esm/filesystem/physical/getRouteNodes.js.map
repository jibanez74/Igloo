{"version":3,"file":"getRouteNodes.js","sources":["../../../../src/filesystem/physical/getRouteNodes.ts"],"sourcesContent":["import path from 'node:path'\nimport * as fsp from 'node:fs/promises'\nimport {\n  determineInitialRoutePath,\n  hasEscapedLeadingUnderscore,\n  removeExt,\n  replaceBackslash,\n  routePathToVariable,\n  unwrapBracketWrappedSegment,\n} from '../../utils'\nimport { getRouteNodes as getRouteNodesVirtual } from '../virtual/getRouteNodes'\nimport { loadConfigFile } from '../virtual/loadConfigFile'\nimport { logging } from '../../logger'\nimport { rootPathId } from './rootPathId'\nimport type {\n  VirtualRootRoute,\n  VirtualRouteSubtreeConfig,\n} from '@tanstack/virtual-file-routes'\nimport type { FsRouteType, GetRouteNodesResult, RouteNode } from '../../types'\nimport type { Config } from '../../config'\n\n/**\n * Pre-compiled segment regexes for matching token patterns against route segments.\n * These are created once (in Generator constructor) and passed through to avoid\n * repeated regex compilation during route crawling.\n */\nexport interface TokenRegexBundle {\n  indexTokenSegmentRegex: RegExp\n  routeTokenSegmentRegex: RegExp\n}\n\nconst disallowedRouteGroupConfiguration = /\\(([^)]+)\\).(ts|js|tsx|jsx|vue)/\n\nconst virtualConfigFileRegExp = /__virtual\\.[mc]?[jt]s$/\nexport function isVirtualConfigFile(fileName: string): boolean {\n  return virtualConfigFileRegExp.test(fileName)\n}\n\nexport async function getRouteNodes(\n  config: Pick<\n    Config,\n    | 'routesDirectory'\n    | 'routeFilePrefix'\n    | 'routeFileIgnorePrefix'\n    | 'routeFileIgnorePattern'\n    | 'disableLogging'\n    | 'routeToken'\n    | 'indexToken'\n  >,\n  root: string,\n  tokenRegexes: TokenRegexBundle,\n): Promise<GetRouteNodesResult> {\n  const { routeFilePrefix, routeFileIgnorePrefix, routeFileIgnorePattern } =\n    config\n\n  const logger = logging({ disabled: config.disableLogging })\n  const routeFileIgnoreRegExp = new RegExp(routeFileIgnorePattern ?? '', 'g')\n\n  const routeNodes: Array<RouteNode> = []\n  const allPhysicalDirectories: Array<string> = []\n\n  async function recurse(dir: string) {\n    const fullDir = path.resolve(config.routesDirectory, dir)\n    let dirList = await fsp.readdir(fullDir, { withFileTypes: true })\n\n    dirList = dirList.filter((d) => {\n      if (\n        d.name.startsWith('.') ||\n        (routeFileIgnorePrefix && d.name.startsWith(routeFileIgnorePrefix))\n      ) {\n        return false\n      }\n\n      if (routeFilePrefix) {\n        if (routeFileIgnorePattern) {\n          return (\n            d.name.startsWith(routeFilePrefix) &&\n            !d.name.match(routeFileIgnoreRegExp)\n          )\n        }\n\n        return d.name.startsWith(routeFilePrefix)\n      }\n\n      if (routeFileIgnorePattern) {\n        return !d.name.match(routeFileIgnoreRegExp)\n      }\n\n      return true\n    })\n\n    const virtualConfigFile = dirList.find((dirent) => {\n      return dirent.isFile() && isVirtualConfigFile(dirent.name)\n    })\n\n    if (virtualConfigFile !== undefined) {\n      const virtualRouteConfigExport = await loadConfigFile(\n        path.resolve(fullDir, virtualConfigFile.name),\n      )\n      let virtualRouteSubtreeConfig: VirtualRouteSubtreeConfig\n      if (typeof virtualRouteConfigExport.default === 'function') {\n        virtualRouteSubtreeConfig = await virtualRouteConfigExport.default()\n      } else {\n        virtualRouteSubtreeConfig = virtualRouteConfigExport.default\n      }\n      const dummyRoot: VirtualRootRoute = {\n        type: 'root',\n        file: '',\n        children: virtualRouteSubtreeConfig,\n      }\n      const { routeNodes: virtualRouteNodes, physicalDirectories } =\n        await getRouteNodesVirtual(\n          {\n            ...config,\n            routesDirectory: fullDir,\n            virtualRouteConfig: dummyRoot,\n          },\n          root,\n          tokenRegexes,\n        )\n      allPhysicalDirectories.push(...physicalDirectories)\n      virtualRouteNodes.forEach((node) => {\n        const filePath = replaceBackslash(path.join(dir, node.filePath))\n        const routePath = `/${dir}${node.routePath}`\n\n        node.variableName = routePathToVariable(\n          `${dir}/${removeExt(node.filePath)}`,\n        )\n        node.routePath = routePath\n        // Keep originalRoutePath aligned with routePath for escape detection\n        if (node.originalRoutePath) {\n          node.originalRoutePath = `/${dir}${node.originalRoutePath}`\n        }\n        node.filePath = filePath\n      })\n\n      routeNodes.push(...virtualRouteNodes)\n\n      return\n    }\n\n    await Promise.all(\n      dirList.map(async (dirent) => {\n        const fullPath = replaceBackslash(path.join(fullDir, dirent.name))\n        const relativePath = path.posix.join(dir, dirent.name)\n\n        if (dirent.isDirectory()) {\n          await recurse(relativePath)\n        } else if (fullPath.match(/\\.(tsx|ts|jsx|js|vue)$/)) {\n          const filePath = replaceBackslash(path.join(dir, dirent.name))\n          const filePathNoExt = removeExt(filePath)\n          const {\n            routePath: initialRoutePath,\n            originalRoutePath: initialOriginalRoutePath,\n          } = determineInitialRoutePath(filePathNoExt)\n\n          let routePath = initialRoutePath\n          let originalRoutePath = initialOriginalRoutePath\n\n          if (routeFilePrefix) {\n            routePath = routePath.replaceAll(routeFilePrefix, '')\n            originalRoutePath = originalRoutePath.replaceAll(\n              routeFilePrefix,\n              '',\n            )\n          }\n\n          if (disallowedRouteGroupConfiguration.test(dirent.name)) {\n            const errorMessage = `A route configuration for a route group was found at \\`${filePath}\\`. This is not supported. Did you mean to use a layout/pathless route instead?`\n            logger.error(`ERROR: ${errorMessage}`)\n            throw new Error(errorMessage)\n          }\n\n          const meta = getRouteMeta(routePath, originalRoutePath, tokenRegexes)\n          const variableName = meta.variableName\n          let routeType: FsRouteType = meta.fsRouteType\n\n          if (routeType === 'lazy') {\n            routePath = routePath.replace(/\\/lazy$/, '')\n            originalRoutePath = originalRoutePath.replace(/\\/lazy$/, '')\n          }\n\n          // this check needs to happen after the lazy route has been cleaned up\n          // since the routePath is used to determine if a route is pathless\n          if (\n            isValidPathlessLayoutRoute(\n              routePath,\n              originalRoutePath,\n              routeType,\n              tokenRegexes,\n            )\n          ) {\n            routeType = 'pathless_layout'\n          }\n\n          // Only show deprecation warning for .tsx/.ts files, not .vue files\n          // Vue files using .component.vue is the Vue-native way\n          const isVueFile = filePath.endsWith('.vue')\n          if (!isVueFile) {\n            ;(\n              [\n                ['component', 'component'],\n                ['errorComponent', 'errorComponent'],\n                ['notFoundComponent', 'notFoundComponent'],\n                ['pendingComponent', 'pendingComponent'],\n                ['loader', 'loader'],\n              ] satisfies Array<[FsRouteType, string]>\n            ).forEach(([matcher, type]) => {\n              if (routeType === matcher) {\n                logger.warn(\n                  `WARNING: The \\`.${type}.tsx\\` suffix used for the ${filePath} file is deprecated. Use the new \\`.lazy.tsx\\` suffix instead.`,\n                )\n              }\n            })\n          }\n\n          // Get the last segment of originalRoutePath to check for escaping\n          const originalSegments = originalRoutePath.split('/').filter(Boolean)\n          const lastOriginalSegmentForSuffix =\n            originalSegments[originalSegments.length - 1] || ''\n\n          const { routeTokenSegmentRegex, indexTokenSegmentRegex } =\n            tokenRegexes\n\n          // List of special suffixes that can be escaped\n          const specialSuffixes = [\n            'component',\n            'errorComponent',\n            'notFoundComponent',\n            'pendingComponent',\n            'loader',\n            'lazy',\n          ]\n\n          const routePathSegments = routePath.split('/').filter(Boolean)\n          const lastRouteSegment =\n            routePathSegments[routePathSegments.length - 1] || ''\n\n          const suffixToStrip = specialSuffixes.find((suffix) => {\n            const endsWithSuffix = routePath.endsWith(`/${suffix}`)\n            // A suffix is escaped if wrapped in brackets in the original: [lazy] means literal \"lazy\"\n            const isEscaped =\n              lastOriginalSegmentForSuffix.startsWith('[') &&\n              lastOriginalSegmentForSuffix.endsWith(']') &&\n              unwrapBracketWrappedSegment(lastOriginalSegmentForSuffix) ===\n                suffix\n            return endsWithSuffix && !isEscaped\n          })\n\n          const routeTokenCandidate = unwrapBracketWrappedSegment(\n            lastOriginalSegmentForSuffix,\n          )\n          const isRouteTokenEscaped =\n            lastOriginalSegmentForSuffix !== routeTokenCandidate &&\n            routeTokenSegmentRegex.test(routeTokenCandidate)\n\n          const shouldStripRouteToken =\n            routeTokenSegmentRegex.test(lastRouteSegment) &&\n            !isRouteTokenEscaped\n\n          if (suffixToStrip || shouldStripRouteToken) {\n            const stripSegment = suffixToStrip ?? lastRouteSegment\n            routePath = routePath.replace(new RegExp(`/${stripSegment}$`), '')\n            originalRoutePath = originalRoutePath.replace(\n              new RegExp(`/${stripSegment}$`),\n              '',\n            )\n          }\n\n          // Check if the index token should be treated specially or as a literal path\n          // Escaping stays literal-only: if the last original segment is bracket-wrapped,\n          // treat it as literal even if it matches the token regex.\n          const lastOriginalSegment =\n            originalRoutePath.split('/').filter(Boolean).pop() || ''\n\n          const indexTokenCandidate =\n            unwrapBracketWrappedSegment(lastOriginalSegment)\n          const isIndexEscaped =\n            lastOriginalSegment !== indexTokenCandidate &&\n            indexTokenSegmentRegex.test(indexTokenCandidate)\n\n          if (!isIndexEscaped) {\n            const updatedRouteSegments = routePath.split('/').filter(Boolean)\n            const updatedLastRouteSegment =\n              updatedRouteSegments[updatedRouteSegments.length - 1] || ''\n\n            if (indexTokenSegmentRegex.test(updatedLastRouteSegment)) {\n              if (routePathSegments.length === 1) {\n                routePath = '/'\n              }\n\n              if (lastOriginalSegment === updatedLastRouteSegment) {\n                originalRoutePath = '/'\n              }\n\n              // For layout routes, don't use '/' fallback - an empty path means\n              // \"layout for the parent path\" which is important for physical() mounts\n              // where route.tsx at root should have empty path, not '/'\n              const isLayoutRoute = routeType === 'layout'\n\n              routePath =\n                routePath.replace(\n                  new RegExp(`/${updatedLastRouteSegment}$`),\n                  '/',\n                ) || (isLayoutRoute ? '' : '/')\n\n              originalRoutePath =\n                originalRoutePath.replace(\n                  new RegExp(`/${indexTokenCandidate}$`),\n                  '/',\n                ) || (isLayoutRoute ? '' : '/')\n            }\n          }\n\n          routeNodes.push({\n            filePath,\n            fullPath,\n            routePath,\n            variableName,\n            _fsRouteType: routeType,\n            originalRoutePath,\n          })\n        }\n      }),\n    )\n\n    return routeNodes\n  }\n\n  await recurse('./')\n\n  // Find the root route node - prefer the actual route file over component/loader files\n  const rootRouteNode =\n    routeNodes.find(\n      (d) =>\n        d.routePath === `/${rootPathId}` &&\n        ![\n          'component',\n          'errorComponent',\n          'notFoundComponent',\n          'pendingComponent',\n          'loader',\n          'lazy',\n        ].includes(d._fsRouteType),\n    ) ?? routeNodes.find((d) => d.routePath === `/${rootPathId}`)\n  if (rootRouteNode) {\n    rootRouteNode._fsRouteType = '__root'\n    rootRouteNode.variableName = 'root'\n  }\n\n  return {\n    rootRouteNode,\n    routeNodes,\n    physicalDirectories: allPhysicalDirectories,\n  }\n}\n\n/**\n * Determines the metadata for a given route path based on the provided configuration.\n *\n * @param routePath - The determined initial routePath (with brackets removed).\n * @param originalRoutePath - The original route path (may contain brackets for escaped content).\n * @param tokenRegexes - Pre-compiled token regexes for matching.\n * @returns An object containing the type of the route and the variable name derived from the route path.\n */\nexport function getRouteMeta(\n  routePath: string,\n  originalRoutePath: string,\n  tokenRegexes: TokenRegexBundle,\n): {\n  // `__root` is can be more easily determined by filtering down to routePath === /${rootPathId}\n  // `pathless` is needs to determined after `lazy` has been cleaned up from the routePath\n  fsRouteType: Extract<\n    FsRouteType,\n    | 'static'\n    | 'layout'\n    | 'api'\n    | 'lazy'\n    | 'loader'\n    | 'component'\n    | 'pendingComponent'\n    | 'errorComponent'\n    | 'notFoundComponent'\n  >\n  variableName: string\n} {\n  let fsRouteType: FsRouteType = 'static'\n\n  // Get the last segment from the original path to check for escaping\n  const originalSegments = originalRoutePath.split('/').filter(Boolean)\n  const lastOriginalSegment =\n    originalSegments[originalSegments.length - 1] || ''\n\n  const { routeTokenSegmentRegex } = tokenRegexes\n\n  // Helper to check if a specific suffix is escaped (literal-only)\n  // A suffix is escaped if the original segment is wrapped in brackets: [lazy] means literal \"lazy\"\n  const isSuffixEscaped = (suffix: string): boolean => {\n    return (\n      lastOriginalSegment.startsWith('[') &&\n      lastOriginalSegment.endsWith(']') &&\n      unwrapBracketWrappedSegment(lastOriginalSegment) === suffix\n    )\n  }\n\n  const routeSegments = routePath.split('/').filter(Boolean)\n  const lastRouteSegment = routeSegments[routeSegments.length - 1] || ''\n\n  const routeTokenCandidate = unwrapBracketWrappedSegment(lastOriginalSegment)\n  const isRouteTokenEscaped =\n    lastOriginalSegment !== routeTokenCandidate &&\n    routeTokenSegmentRegex.test(routeTokenCandidate)\n\n  if (routeTokenSegmentRegex.test(lastRouteSegment) && !isRouteTokenEscaped) {\n    // layout routes, i.e `/foo/route.tsx` or `/foo/_layout/route.tsx`\n    fsRouteType = 'layout'\n  } else if (routePath.endsWith('/lazy') && !isSuffixEscaped('lazy')) {\n    // lazy routes, i.e. `/foo.lazy.tsx`\n    fsRouteType = 'lazy'\n  } else if (routePath.endsWith('/loader') && !isSuffixEscaped('loader')) {\n    // loader routes, i.e. `/foo.loader.tsx`\n    fsRouteType = 'loader'\n  } else if (\n    routePath.endsWith('/component') &&\n    !isSuffixEscaped('component')\n  ) {\n    // component routes, i.e. `/foo.component.tsx`\n    fsRouteType = 'component'\n  } else if (\n    routePath.endsWith('/pendingComponent') &&\n    !isSuffixEscaped('pendingComponent')\n  ) {\n    // pending component routes, i.e. `/foo.pendingComponent.tsx`\n    fsRouteType = 'pendingComponent'\n  } else if (\n    routePath.endsWith('/errorComponent') &&\n    !isSuffixEscaped('errorComponent')\n  ) {\n    // error component routes, i.e. `/foo.errorComponent.tsx`\n    fsRouteType = 'errorComponent'\n  } else if (\n    routePath.endsWith('/notFoundComponent') &&\n    !isSuffixEscaped('notFoundComponent')\n  ) {\n    // not found component routes, i.e. `/foo.notFoundComponent.tsx`\n    fsRouteType = 'notFoundComponent'\n  }\n\n  const variableName = routePathToVariable(routePath)\n\n  return { fsRouteType, variableName }\n}\n\n/**\n * Used to validate if a route is a pathless layout route\n * @param normalizedRoutePath Normalized route path, i.e `/foo/_layout/route.tsx` and `/foo._layout.route.tsx` to `/foo/_layout/route`\n * @param originalRoutePath Original route path with brackets for escaped content\n * @param routeType The route type determined from file extension\n * @param tokenRegexes Pre-compiled token regexes for matching\n * @returns Boolean indicating if the route is a pathless layout route\n */\nfunction isValidPathlessLayoutRoute(\n  normalizedRoutePath: string,\n  originalRoutePath: string,\n  routeType: FsRouteType,\n  tokenRegexes: TokenRegexBundle,\n): boolean {\n  if (routeType === 'lazy') {\n    return false\n  }\n\n  const segments = normalizedRoutePath.split('/').filter(Boolean)\n  const originalSegments = originalRoutePath.split('/').filter(Boolean)\n\n  if (segments.length === 0) {\n    return false\n  }\n\n  const lastRouteSegment = segments[segments.length - 1]!\n  const lastOriginalSegment =\n    originalSegments[originalSegments.length - 1] || ''\n  const secondToLastRouteSegment = segments[segments.length - 2]\n  const secondToLastOriginalSegment =\n    originalSegments[originalSegments.length - 2]\n\n  // If segment === __root, then exit as false\n  if (lastRouteSegment === rootPathId) {\n    return false\n  }\n\n  const { routeTokenSegmentRegex, indexTokenSegmentRegex } = tokenRegexes\n\n  // If segment matches routeToken and secondToLastSegment is a string that starts with _, then exit as true\n  // Since the route is actually a configuration route for a layout/pathless route\n  // i.e. /foo/_layout/route.tsx === /foo/_layout.tsx\n  // But if the underscore is escaped, it's not a pathless layout\n  if (\n    routeTokenSegmentRegex.test(lastRouteSegment) &&\n    typeof secondToLastRouteSegment === 'string' &&\n    typeof secondToLastOriginalSegment === 'string'\n  ) {\n    // Check if the underscore is escaped\n    if (hasEscapedLeadingUnderscore(secondToLastOriginalSegment)) {\n      return false\n    }\n    return secondToLastRouteSegment.startsWith('_')\n  }\n\n  // Segment starts with _ but check if it's escaped\n  // If the original segment has [_] at the start, the underscore is escaped and it's not a pathless layout\n  if (hasEscapedLeadingUnderscore(lastOriginalSegment)) {\n    return false\n  }\n\n  return (\n    !indexTokenSegmentRegex.test(lastRouteSegment) &&\n    !routeTokenSegmentRegex.test(lastRouteSegment) &&\n    lastRouteSegment.startsWith('_')\n  )\n}\n"],"names":["getRouteNodesVirtual"],"mappings":"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"}