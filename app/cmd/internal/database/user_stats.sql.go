// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_stats.sql

package database

import (
	"context"
	"database/sql"
)

const getUserListeningHistoryByPeriod = `-- name: GetUserListeningHistoryByPeriod :many
SELECT
    DATE(uph.played_at) AS play_date,
    COUNT(*) AS play_count,
    SUM(uph.duration_played) AS total_duration
FROM user_play_history uph
WHERE uph.user_id = ?
  AND uph.played_at >= ?
  AND uph.played_at <= ?
GROUP BY DATE(uph.played_at)
ORDER BY play_date ASC
`

type GetUserListeningHistoryByPeriodParams struct {
	UserID     int64  `json:"user_id"`
	PlayedAt   string `json:"played_at"`
	PlayedAt_2 string `json:"played_at_2"`
}

type GetUserListeningHistoryByPeriodRow struct {
	PlayDate      interface{}     `json:"play_date"`
	PlayCount     int64           `json:"play_count"`
	TotalDuration sql.NullFloat64 `json:"total_duration"`
}

// Returns listening stats grouped by date for charts
func (q *Queries) GetUserListeningHistoryByPeriod(ctx context.Context, arg GetUserListeningHistoryByPeriodParams) ([]GetUserListeningHistoryByPeriodRow, error) {
	rows, err := q.query(ctx, q.getUserListeningHistoryByPeriodStmt, getUserListeningHistoryByPeriod, arg.UserID, arg.PlayedAt, arg.PlayedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserListeningHistoryByPeriodRow{}
	for rows.Next() {
		var i GetUserListeningHistoryByPeriodRow
		if err := rows.Scan(&i.PlayDate, &i.PlayCount, &i.TotalDuration); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserListeningStats = `-- name: GetUserListeningStats :one
SELECT
    COALESCE(SUM(uts.play_count), 0) AS total_plays,
    COALESCE(SUM(uts.total_time_played), 0) AS total_time_listened,
    COUNT(DISTINCT uts.track_id) AS unique_tracks_played,
    (SELECT COUNT(*) FROM user_liked_tracks ult WHERE ult.user_id = ?) AS liked_tracks_count
FROM user_track_stats uts
WHERE uts.user_id = ?
`

type GetUserListeningStatsParams struct {
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

type GetUserListeningStatsRow struct {
	TotalPlays         interface{} `json:"total_plays"`
	TotalTimeListened  interface{} `json:"total_time_listened"`
	UniqueTracksPlayed int64       `json:"unique_tracks_played"`
	LikedTracksCount   int64       `json:"liked_tracks_count"`
}

// Returns overall listening statistics for a user
func (q *Queries) GetUserListeningStats(ctx context.Context, arg GetUserListeningStatsParams) (GetUserListeningStatsRow, error) {
	row := q.queryRow(ctx, q.getUserListeningStatsStmt, getUserListeningStats, arg.UserID, arg.UserID_2)
	var i GetUserListeningStatsRow
	err := row.Scan(
		&i.TotalPlays,
		&i.TotalTimeListened,
		&i.UniqueTracksPlayed,
		&i.LikedTracksCount,
	)
	return i, err
}

const getUserRecentlyPlayed = `-- name: GetUserRecentlyPlayed :many
SELECT
    uph.played_at,
    uph.duration_played,
    t.id,
    t.title,
    t.duration,
    t.file_path,
    a.id AS album_id,
    a.title AS album_title,
    a.cover AS album_cover,
    m.id AS musician_id,
    m.name AS musician_name
FROM user_play_history uph
INNER JOIN tracks t ON uph.track_id = t.id
LEFT JOIN albums a ON t.album_id = a.id
LEFT JOIN musicians m ON t.musician_id = m.id
WHERE uph.user_id = ?
ORDER BY uph.played_at DESC
LIMIT ? OFFSET ?
`

type GetUserRecentlyPlayedParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetUserRecentlyPlayedRow struct {
	PlayedAt       string         `json:"played_at"`
	DurationPlayed int64          `json:"duration_played"`
	ID             int64          `json:"id"`
	Title          string         `json:"title"`
	Duration       int64          `json:"duration"`
	FilePath       string         `json:"file_path"`
	AlbumID        sql.NullInt64  `json:"album_id"`
	AlbumTitle     sql.NullString `json:"album_title"`
	AlbumCover     sql.NullString `json:"album_cover"`
	MusicianID     sql.NullInt64  `json:"musician_id"`
	MusicianName   sql.NullString `json:"musician_name"`
}

// Returns the user's recently played tracks
func (q *Queries) GetUserRecentlyPlayed(ctx context.Context, arg GetUserRecentlyPlayedParams) ([]GetUserRecentlyPlayedRow, error) {
	rows, err := q.query(ctx, q.getUserRecentlyPlayedStmt, getUserRecentlyPlayed, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserRecentlyPlayedRow{}
	for rows.Next() {
		var i GetUserRecentlyPlayedRow
		if err := rows.Scan(
			&i.PlayedAt,
			&i.DurationPlayed,
			&i.ID,
			&i.Title,
			&i.Duration,
			&i.FilePath,
			&i.AlbumID,
			&i.AlbumTitle,
			&i.AlbumCover,
			&i.MusicianID,
			&i.MusicianName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTopAlbums = `-- name: GetUserTopAlbums :many
SELECT
    a.id,
    a.title,
    a.cover,
    a.musician,
    a.year,
    SUM(uts.play_count) AS total_play_count,
    SUM(uts.total_time_played) AS total_time_listened,
    COUNT(DISTINCT t.id) AS unique_tracks_played
FROM user_track_stats uts
INNER JOIN tracks t ON uts.track_id = t.id
INNER JOIN albums a ON t.album_id = a.id
WHERE uts.user_id = ?
GROUP BY a.id, a.title, a.cover, a.musician, a.year
ORDER BY total_play_count DESC
LIMIT ? OFFSET ?
`

type GetUserTopAlbumsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetUserTopAlbumsRow struct {
	ID                 int64           `json:"id"`
	Title              string          `json:"title"`
	Cover              sql.NullString  `json:"cover"`
	Musician           sql.NullString  `json:"musician"`
	Year               sql.NullInt64   `json:"year"`
	TotalPlayCount     sql.NullFloat64 `json:"total_play_count"`
	TotalTimeListened  sql.NullFloat64 `json:"total_time_listened"`
	UniqueTracksPlayed int64           `json:"unique_tracks_played"`
}

// Returns the user's most listened albums
func (q *Queries) GetUserTopAlbums(ctx context.Context, arg GetUserTopAlbumsParams) ([]GetUserTopAlbumsRow, error) {
	rows, err := q.query(ctx, q.getUserTopAlbumsStmt, getUserTopAlbums, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserTopAlbumsRow{}
	for rows.Next() {
		var i GetUserTopAlbumsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Cover,
			&i.Musician,
			&i.Year,
			&i.TotalPlayCount,
			&i.TotalTimeListened,
			&i.UniqueTracksPlayed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTopGenres = `-- name: GetUserTopGenres :many
SELECT
    g.id,
    g.tag,
    SUM(uts.play_count) AS total_play_count,
    SUM(uts.total_time_played) AS total_time_listened,
    COUNT(DISTINCT t.id) AS unique_tracks_played
FROM user_track_stats uts
INNER JOIN tracks t ON uts.track_id = t.id
INNER JOIN track_genres tg ON t.id = tg.track_id
INNER JOIN genres g ON tg.genre_id = g.id
WHERE uts.user_id = ? AND g.genre_type = 'music'
GROUP BY g.id, g.tag
ORDER BY total_play_count DESC
LIMIT ?
`

type GetUserTopGenresParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
}

type GetUserTopGenresRow struct {
	ID                 int64           `json:"id"`
	Tag                string          `json:"tag"`
	TotalPlayCount     sql.NullFloat64 `json:"total_play_count"`
	TotalTimeListened  sql.NullFloat64 `json:"total_time_listened"`
	UniqueTracksPlayed int64           `json:"unique_tracks_played"`
}

// Returns the user's most listened genres
func (q *Queries) GetUserTopGenres(ctx context.Context, arg GetUserTopGenresParams) ([]GetUserTopGenresRow, error) {
	rows, err := q.query(ctx, q.getUserTopGenresStmt, getUserTopGenres, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserTopGenresRow{}
	for rows.Next() {
		var i GetUserTopGenresRow
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.TotalPlayCount,
			&i.TotalTimeListened,
			&i.UniqueTracksPlayed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTopMusicians = `-- name: GetUserTopMusicians :many
SELECT
    m.id,
    m.name,
    m.thumb,
    SUM(uts.play_count) AS total_play_count,
    SUM(uts.total_time_played) AS total_time_listened,
    COUNT(DISTINCT t.id) AS unique_tracks_played
FROM user_track_stats uts
INNER JOIN tracks t ON uts.track_id = t.id
INNER JOIN musicians m ON t.musician_id = m.id
WHERE uts.user_id = ?
GROUP BY m.id, m.name, m.thumb
ORDER BY total_play_count DESC
LIMIT ? OFFSET ?
`

type GetUserTopMusiciansParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetUserTopMusiciansRow struct {
	ID                 int64           `json:"id"`
	Name               string          `json:"name"`
	Thumb              sql.NullString  `json:"thumb"`
	TotalPlayCount     sql.NullFloat64 `json:"total_play_count"`
	TotalTimeListened  sql.NullFloat64 `json:"total_time_listened"`
	UniqueTracksPlayed int64           `json:"unique_tracks_played"`
}

// Returns the user's most listened musicians by total play count
func (q *Queries) GetUserTopMusicians(ctx context.Context, arg GetUserTopMusiciansParams) ([]GetUserTopMusiciansRow, error) {
	rows, err := q.query(ctx, q.getUserTopMusiciansStmt, getUserTopMusicians, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserTopMusiciansRow{}
	for rows.Next() {
		var i GetUserTopMusiciansRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Thumb,
			&i.TotalPlayCount,
			&i.TotalTimeListened,
			&i.UniqueTracksPlayed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTopTracks = `-- name: GetUserTopTracks :many

SELECT
    uts.play_count,
    uts.total_time_played,
    uts.last_played_at,
    t.id,
    t.title,
    t.duration,
    t.file_path,
    a.id AS album_id,
    a.title AS album_title,
    a.cover AS album_cover,
    m.id AS musician_id,
    m.name AS musician_name
FROM user_track_stats uts
INNER JOIN tracks t ON uts.track_id = t.id
LEFT JOIN albums a ON t.album_id = a.id
LEFT JOIN musicians m ON t.musician_id = m.id
WHERE uts.user_id = ?
ORDER BY uts.play_count DESC
LIMIT ? OFFSET ?
`

type GetUserTopTracksParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetUserTopTracksRow struct {
	PlayCount       int64          `json:"play_count"`
	TotalTimePlayed int64          `json:"total_time_played"`
	LastPlayedAt    sql.NullString `json:"last_played_at"`
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	Duration        int64          `json:"duration"`
	FilePath        string         `json:"file_path"`
	AlbumID         sql.NullInt64  `json:"album_id"`
	AlbumTitle      sql.NullString `json:"album_title"`
	AlbumCover      sql.NullString `json:"album_cover"`
	MusicianID      sql.NullInt64  `json:"musician_id"`
	MusicianName    sql.NullString `json:"musician_name"`
}

// ============================================================================
// USER STATISTICS QUERIES
// ============================================================================
// Returns the user's most played tracks
func (q *Queries) GetUserTopTracks(ctx context.Context, arg GetUserTopTracksParams) ([]GetUserTopTracksRow, error) {
	rows, err := q.query(ctx, q.getUserTopTracksStmt, getUserTopTracks, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserTopTracksRow{}
	for rows.Next() {
		var i GetUserTopTracksRow
		if err := rows.Scan(
			&i.PlayCount,
			&i.TotalTimePlayed,
			&i.LastPlayedAt,
			&i.ID,
			&i.Title,
			&i.Duration,
			&i.FilePath,
			&i.AlbumID,
			&i.AlbumTitle,
			&i.AlbumCover,
			&i.MusicianID,
			&i.MusicianName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTrackPlayCount = `-- name: GetUserTrackPlayCount :one
SELECT play_count
FROM user_track_stats
WHERE user_id = ? AND track_id = ?
`

type GetUserTrackPlayCountParams struct {
	UserID  int64 `json:"user_id"`
	TrackID int64 `json:"track_id"`
}

// Returns the play count for a specific track
func (q *Queries) GetUserTrackPlayCount(ctx context.Context, arg GetUserTrackPlayCountParams) (int64, error) {
	row := q.queryRow(ctx, q.getUserTrackPlayCountStmt, getUserTrackPlayCount, arg.UserID, arg.TrackID)
	var play_count int64
	err := row.Scan(&play_count)
	return play_count, err
}

const recordPlayEvent = `-- name: RecordPlayEvent :exec

INSERT INTO user_play_history (user_id, track_id, duration_played, completed)
VALUES (?, ?, ?, ?)
`

type RecordPlayEventParams struct {
	UserID         int64 `json:"user_id"`
	TrackID        int64 `json:"track_id"`
	DurationPlayed int64 `json:"duration_played"`
	Completed      bool  `json:"completed"`
}

// ============================================================================
// PLAY HISTORY RECORDING
// ============================================================================
// Records a new play event when a track is played
func (q *Queries) RecordPlayEvent(ctx context.Context, arg RecordPlayEventParams) error {
	_, err := q.exec(ctx, q.recordPlayEventStmt, recordPlayEvent,
		arg.UserID,
		arg.TrackID,
		arg.DurationPlayed,
		arg.Completed,
	)
	return err
}

const upsertUserTrackStats = `-- name: UpsertUserTrackStats :exec
INSERT INTO user_track_stats (user_id, track_id, play_count, total_time_played, last_played_at, first_played_at)
VALUES (?, ?, 1, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT (user_id, track_id) DO UPDATE SET
    play_count = user_track_stats.play_count + 1,
    total_time_played = user_track_stats.total_time_played + excluded.total_time_played,
    last_played_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertUserTrackStatsParams struct {
	UserID          int64 `json:"user_id"`
	TrackID         int64 `json:"track_id"`
	TotalTimePlayed int64 `json:"total_time_played"`
}

// Updates aggregated stats when a play event is recorded
func (q *Queries) UpsertUserTrackStats(ctx context.Context, arg UpsertUserTrackStatsParams) error {
	_, err := q.exec(ctx, q.upsertUserTrackStatsStmt, upsertUserTrackStats, arg.UserID, arg.TrackID, arg.TotalTimePlayed)
	return err
}
