// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_liked_tracks.sql

package database

import (
	"context"
	"database/sql"
)

const getLikedTrackIDsByUserID = `-- name: GetLikedTrackIDsByUserID :many
SELECT track_id
FROM user_liked_tracks
WHERE user_id = ?
`

func (q *Queries) GetLikedTrackIDsByUserID(ctx context.Context, userID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.getLikedTrackIDsByUserIDStmt, getLikedTrackIDsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var track_id int64
		if err := rows.Scan(&track_id); err != nil {
			return nil, err
		}
		items = append(items, track_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikedTracksByUserID = `-- name: GetLikedTracksByUserID :many
SELECT
  t.id,
  t.title,
  t.sort_title,
  t.duration,
  t.codec,
  t.bit_rate,
  t.file_path,
  t.track_index,
  t.disc,
  a.id as album_id,
  a.title as album_title,
  a.cover as album_cover,
  m.id as musician_id,
  m.name as musician_name,
  ult.created_at as liked_at
FROM user_liked_tracks ult
INNER JOIN tracks t ON ult.track_id = t.id
LEFT JOIN albums a ON t.album_id = a.id
LEFT JOIN musicians m ON t.musician_id = m.id
WHERE ult.user_id = ?
ORDER BY ult.created_at DESC
`

type GetLikedTracksByUserIDRow struct {
	ID           int64          `json:"id"`
	Title        string         `json:"title"`
	SortTitle    string         `json:"sort_title"`
	Duration     int64          `json:"duration"`
	Codec        string         `json:"codec"`
	BitRate      int64          `json:"bit_rate"`
	FilePath     string         `json:"file_path"`
	TrackIndex   int64          `json:"track_index"`
	Disc         int64          `json:"disc"`
	AlbumID      sql.NullInt64  `json:"album_id"`
	AlbumTitle   sql.NullString `json:"album_title"`
	AlbumCover   sql.NullString `json:"album_cover"`
	MusicianID   sql.NullInt64  `json:"musician_id"`
	MusicianName sql.NullString `json:"musician_name"`
	LikedAt      string         `json:"liked_at"`
}

func (q *Queries) GetLikedTracksByUserID(ctx context.Context, userID int64) ([]GetLikedTracksByUserIDRow, error) {
	rows, err := q.query(ctx, q.getLikedTracksByUserIDStmt, getLikedTracksByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLikedTracksByUserIDRow{}
	for rows.Next() {
		var i GetLikedTracksByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Duration,
			&i.Codec,
			&i.BitRate,
			&i.FilePath,
			&i.TrackIndex,
			&i.Disc,
			&i.AlbumID,
			&i.AlbumTitle,
			&i.AlbumCover,
			&i.MusicianID,
			&i.MusicianName,
			&i.LikedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isTrackLiked = `-- name: IsTrackLiked :one
SELECT COUNT(*) > 0 as is_liked
FROM user_liked_tracks
WHERE user_id = ? AND track_id = ?
`

type IsTrackLikedParams struct {
	UserID  int64 `json:"user_id"`
	TrackID int64 `json:"track_id"`
}

func (q *Queries) IsTrackLiked(ctx context.Context, arg IsTrackLikedParams) (bool, error) {
	row := q.queryRow(ctx, q.isTrackLikedStmt, isTrackLiked, arg.UserID, arg.TrackID)
	var is_liked bool
	err := row.Scan(&is_liked)
	return is_liked, err
}

const likeTrack = `-- name: LikeTrack :exec
INSERT INTO user_liked_tracks (user_id, track_id)
VALUES (?, ?)
ON CONFLICT (user_id, track_id) DO NOTHING
`

type LikeTrackParams struct {
	UserID  int64 `json:"user_id"`
	TrackID int64 `json:"track_id"`
}

func (q *Queries) LikeTrack(ctx context.Context, arg LikeTrackParams) error {
	_, err := q.exec(ctx, q.likeTrackStmt, likeTrack, arg.UserID, arg.TrackID)
	return err
}

const unlikeTrack = `-- name: UnlikeTrack :exec
DELETE FROM user_liked_tracks
WHERE user_id = ? AND track_id = ?
`

type UnlikeTrackParams struct {
	UserID  int64 `json:"user_id"`
	TrackID int64 `json:"track_id"`
}

func (q *Queries) UnlikeTrack(ctx context.Context, arg UnlikeTrackParams) error {
	_, err := q.exec(ctx, q.unlikeTrackStmt, unlikeTrack, arg.UserID, arg.TrackID)
	return err
}
