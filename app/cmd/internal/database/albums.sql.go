// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: albums.sql

package database

import (
	"context"
	"database/sql"
)

const deleteAlbum = `-- name: DeleteAlbum :exec
DELETE FROM albums WHERE id = ?
`

// Deleting an album will cascade delete all associated tracks
func (q *Queries) DeleteAlbum(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteAlbumStmt, deleteAlbum, id)
	return err
}

const getAlbumByID = `-- name: GetAlbumByID :one
SELECT
  id, title, sort_title, musician, spotify_id, spotify_popularity, release_date, year, total_tracks, cover, created_at, updated_at
FROM
  albums
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetAlbumByID(ctx context.Context, id int64) (Album, error) {
	row := q.queryRow(ctx, q.getAlbumByIDStmt, getAlbumByID, id)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Musician,
		&i.SpotifyID,
		&i.SpotifyPopularity,
		&i.ReleaseDate,
		&i.Year,
		&i.TotalTracks,
		&i.Cover,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAlbumBySpotifyID = `-- name: GetAlbumBySpotifyID :one
SELECT
  id, title, sort_title, musician, spotify_id, spotify_popularity, release_date, year, total_tracks, cover, created_at, updated_at
FROM
  albums
WHERE
  spotify_id = ?
LIMIT
  1
`

func (q *Queries) GetAlbumBySpotifyID(ctx context.Context, spotifyID sql.NullString) (Album, error) {
	row := q.queryRow(ctx, q.getAlbumBySpotifyIDStmt, getAlbumBySpotifyID, spotifyID)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Musician,
		&i.SpotifyID,
		&i.SpotifyPopularity,
		&i.ReleaseDate,
		&i.Year,
		&i.TotalTracks,
		&i.Cover,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAlbumsAlphabetical = `-- name: GetAlbumsAlphabetical :many
SELECT
  id,
  title,
  cover,
  musician,
  year
FROM
  albums
ORDER BY
  CASE
    WHEN UPPER(SUBSTR(title, 1, 1)) BETWEEN 'A' AND 'Z'
    THEN UPPER(SUBSTR(title, 1, 1))
    ELSE '#'
  END,
  UPPER(title)
LIMIT ? OFFSET ?
`

type GetAlbumsAlphabeticalParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetAlbumsAlphabeticalRow struct {
	ID       int64          `json:"id"`
	Title    string         `json:"title"`
	Cover    sql.NullString `json:"cover"`
	Musician sql.NullString `json:"musician"`
	Year     sql.NullInt64  `json:"year"`
}

// Returns albums sorted alphabetically by title with pagination.
// Non-alphabetic titles (numbers, symbols) are grouped under '#' and sorted first.
func (q *Queries) GetAlbumsAlphabetical(ctx context.Context, arg GetAlbumsAlphabeticalParams) ([]GetAlbumsAlphabeticalRow, error) {
	rows, err := q.query(ctx, q.getAlbumsAlphabeticalStmt, getAlbumsAlphabetical, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAlbumsAlphabeticalRow{}
	for rows.Next() {
		var i GetAlbumsAlphabeticalRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Cover,
			&i.Musician,
			&i.Year,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestAlbums = `-- name: GetLatestAlbums :many
SELECT
  id,
  title,
  cover,
  musician,
  year
FROM
  albums
ORDER BY
  created_at DESC
LIMIT
  12
`

type GetLatestAlbumsRow struct {
	ID       int64          `json:"id"`
	Title    string         `json:"title"`
	Cover    sql.NullString `json:"cover"`
	Musician sql.NullString `json:"musician"`
	Year     sql.NullInt64  `json:"year"`
}

func (q *Queries) GetLatestAlbums(ctx context.Context) ([]GetLatestAlbumsRow, error) {
	rows, err := q.query(ctx, q.getLatestAlbumsStmt, getLatestAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLatestAlbumsRow{}
	for rows.Next() {
		var i GetLatestAlbumsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Cover,
			&i.Musician,
			&i.Year,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAlbum = `-- name: UpsertAlbum :one
INSERT INTO
  albums (
    title,
    sort_title,
    musician,
    spotify_id,
    spotify_popularity,
    release_date,
    year,
    total_tracks,
    cover
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT (title, musician) DO
UPDATE
SET
  sort_title = excluded.sort_title,
  spotify_id = COALESCE(excluded.spotify_id, albums.spotify_id),
  spotify_popularity = COALESCE(
    excluded.spotify_popularity,
    albums.spotify_popularity
  ),
  release_date = COALESCE(excluded.release_date, albums.release_date),
  year = COALESCE(excluded.year, albums.year),
  total_tracks = COALESCE(excluded.total_tracks, albums.total_tracks),
  cover = COALESCE(excluded.cover, albums.cover),
  updated_at = CURRENT_TIMESTAMP RETURNING id, title, sort_title, musician, spotify_id, spotify_popularity, release_date, year, total_tracks, cover, created_at, updated_at
`

type UpsertAlbumParams struct {
	Title             string          `json:"title"`
	SortTitle         string          `json:"sort_title"`
	Musician          sql.NullString  `json:"musician"`
	SpotifyID         sql.NullString  `json:"spotify_id"`
	SpotifyPopularity sql.NullFloat64 `json:"spotify_popularity"`
	ReleaseDate       sql.NullString  `json:"release_date"`
	Year              sql.NullInt64   `json:"year"`
	TotalTracks       sql.NullInt64   `json:"total_tracks"`
	Cover             sql.NullString  `json:"cover"`
}

func (q *Queries) UpsertAlbum(ctx context.Context, arg UpsertAlbumParams) (Album, error) {
	row := q.queryRow(ctx, q.upsertAlbumStmt, upsertAlbum,
		arg.Title,
		arg.SortTitle,
		arg.Musician,
		arg.SpotifyID,
		arg.SpotifyPopularity,
		arg.ReleaseDate,
		arg.Year,
		arg.TotalTracks,
		arg.Cover,
	)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Musician,
		&i.SpotifyID,
		&i.SpotifyPopularity,
		&i.ReleaseDate,
		&i.Year,
		&i.TotalTracks,
		&i.Cover,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
