// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: playlists.sql

package database

import (
	"context"
	"database/sql"
)

const countPlaylistsByUserId = `-- name: CountPlaylistsByUserId :one
SELECT COUNT(*) as count FROM playlists WHERE user_id = ?
`

func (q *Queries) CountPlaylistsByUserId(ctx context.Context, userID int64) (int64, error) {
	row := q.queryRow(ctx, q.countPlaylistsByUserIdStmt, countPlaylistsByUserId, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPlaylist = `-- name: CreatePlaylist :one
INSERT INTO playlists (user_id, name, description, cover_image, is_public)
VALUES (?, ?, ?, ?, ?)
RETURNING id, user_id, name, description, cover_image, is_public, folder_id, created_at, updated_at
`

type CreatePlaylistParams struct {
	UserID      int64          `json:"user_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	CoverImage  sql.NullString `json:"cover_image"`
	IsPublic    bool           `json:"is_public"`
}

func (q *Queries) CreatePlaylist(ctx context.Context, arg CreatePlaylistParams) (Playlist, error) {
	row := q.queryRow(ctx, q.createPlaylistStmt, createPlaylist,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.CoverImage,
		arg.IsPublic,
	)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CoverImage,
		&i.IsPublic,
		&i.FolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePlaylist = `-- name: DeletePlaylist :exec
DELETE FROM playlists WHERE id = ? AND user_id = ?
`

type DeletePlaylistParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeletePlaylist(ctx context.Context, arg DeletePlaylistParams) error {
	_, err := q.exec(ctx, q.deletePlaylistStmt, deletePlaylist, arg.ID, arg.UserID)
	return err
}

const getPlaylistById = `-- name: GetPlaylistById :one
SELECT id, user_id, name, description, cover_image, is_public, folder_id, created_at, updated_at FROM playlists WHERE id = ?
`

func (q *Queries) GetPlaylistById(ctx context.Context, id int64) (Playlist, error) {
	row := q.queryRow(ctx, q.getPlaylistByIdStmt, getPlaylistById, id)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CoverImage,
		&i.IsPublic,
		&i.FolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlaylistsByUserId = `-- name: GetPlaylistsByUserId :many
SELECT 
    p.id, p.user_id, p.name, p.description, p.cover_image, p.is_public, p.folder_id, p.created_at, p.updated_at,
    (SELECT COUNT(*) FROM playlist_tracks pt WHERE pt.playlist_id = p.id) as track_count,
    (SELECT COALESCE(SUM(t.duration), 0) FROM playlist_tracks pt JOIN tracks t ON pt.track_id = t.id WHERE pt.playlist_id = p.id) as total_duration
FROM playlists p
WHERE p.user_id = ? 
ORDER BY p.updated_at DESC
`

type GetPlaylistsByUserIdRow struct {
	ID            int64          `json:"id"`
	UserID        int64          `json:"user_id"`
	Name          string         `json:"name"`
	Description   sql.NullString `json:"description"`
	CoverImage    sql.NullString `json:"cover_image"`
	IsPublic      bool           `json:"is_public"`
	FolderID      sql.NullInt64  `json:"folder_id"`
	CreatedAt     string         `json:"created_at"`
	UpdatedAt     string         `json:"updated_at"`
	TrackCount    int64          `json:"track_count"`
	TotalDuration interface{}    `json:"total_duration"`
}

func (q *Queries) GetPlaylistsByUserId(ctx context.Context, userID int64) ([]GetPlaylistsByUserIdRow, error) {
	rows, err := q.query(ctx, q.getPlaylistsByUserIdStmt, getPlaylistsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlaylistsByUserIdRow{}
	for rows.Next() {
		var i GetPlaylistsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.CoverImage,
			&i.IsPublic,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrackCount,
			&i.TotalDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistsWithCollaboratorAccess = `-- name: GetPlaylistsWithCollaboratorAccess :many
SELECT 
    p.id, p.user_id, p.name, p.description, p.cover_image, p.is_public, p.folder_id, p.created_at, p.updated_at,
    (SELECT COUNT(*) FROM playlist_tracks pt WHERE pt.playlist_id = p.id) as track_count,
    (SELECT COALESCE(SUM(t.duration), 0) FROM playlist_tracks pt JOIN tracks t ON pt.track_id = t.id WHERE pt.playlist_id = p.id) as total_duration
FROM playlists p
LEFT JOIN playlist_collaborators pc ON p.id = pc.playlist_id
WHERE p.user_id = ? OR pc.user_id = ?
GROUP BY p.id
ORDER BY p.updated_at DESC
`

type GetPlaylistsWithCollaboratorAccessParams struct {
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

type GetPlaylistsWithCollaboratorAccessRow struct {
	ID            int64          `json:"id"`
	UserID        int64          `json:"user_id"`
	Name          string         `json:"name"`
	Description   sql.NullString `json:"description"`
	CoverImage    sql.NullString `json:"cover_image"`
	IsPublic      bool           `json:"is_public"`
	FolderID      sql.NullInt64  `json:"folder_id"`
	CreatedAt     string         `json:"created_at"`
	UpdatedAt     string         `json:"updated_at"`
	TrackCount    int64          `json:"track_count"`
	TotalDuration interface{}    `json:"total_duration"`
}

func (q *Queries) GetPlaylistsWithCollaboratorAccess(ctx context.Context, arg GetPlaylistsWithCollaboratorAccessParams) ([]GetPlaylistsWithCollaboratorAccessRow, error) {
	rows, err := q.query(ctx, q.getPlaylistsWithCollaboratorAccessStmt, getPlaylistsWithCollaboratorAccess, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlaylistsWithCollaboratorAccessRow{}
	for rows.Next() {
		var i GetPlaylistsWithCollaboratorAccessRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.CoverImage,
			&i.IsPublic,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrackCount,
			&i.TotalDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlaylist = `-- name: UpdatePlaylist :one
UPDATE playlists 
SET name = ?, description = ?, cover_image = ?, is_public = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, user_id, name, description, cover_image, is_public, folder_id, created_at, updated_at
`

type UpdatePlaylistParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	CoverImage  sql.NullString `json:"cover_image"`
	IsPublic    bool           `json:"is_public"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdatePlaylist(ctx context.Context, arg UpdatePlaylistParams) (Playlist, error) {
	row := q.queryRow(ctx, q.updatePlaylistStmt, updatePlaylist,
		arg.Name,
		arg.Description,
		arg.CoverImage,
		arg.IsPublic,
		arg.ID,
	)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CoverImage,
		&i.IsPublic,
		&i.FolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePlaylistTimestamp = `-- name: UpdatePlaylistTimestamp :exec
UPDATE playlists SET updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) UpdatePlaylistTimestamp(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.updatePlaylistTimestampStmt, updatePlaylistTimestamp, id)
	return err
}
