// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tracks.sql

package database

import (
	"context"
	"database/sql"
)

const checkTrackUnchanged = `-- name: CheckTrackUnchanged :one
SELECT 1 FROM tracks WHERE file_path = ? AND size = ? LIMIT 1
`

type CheckTrackUnchangedParams struct {
	FilePath string `json:"file_path"`
	Size     int64  `json:"size"`
}

// Quick check if track exists with same path and size (likely unchanged)
func (q *Queries) CheckTrackUnchanged(ctx context.Context, arg CheckTrackUnchangedParams) (int64, error) {
	row := q.queryRow(ctx, q.checkTrackUnchangedStmt, checkTrackUnchanged, arg.FilePath, arg.Size)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getAlbumsCount = `-- name: GetAlbumsCount :one
SELECT COUNT(*) FROM albums
`

func (q *Queries) GetAlbumsCount(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.getAlbumsCountStmt, getAlbumsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMusiciansCount = `-- name: GetMusiciansCount :one
SELECT COUNT(*) FROM musicians
`

func (q *Queries) GetMusiciansCount(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.getMusiciansCountStmt, getMusiciansCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTrack = `-- name: GetTrack :one
SELECT id, title, sort_title, file_path, file_name, container, mime_type, codec, size, track_index, duration, disc, channels, channel_layout, bit_rate, profile, release_date, year, composer, copyright, language, album_id, musician_id, created_at, updated_at FROM tracks WHERE id = ? LIMIT 1
`

func (q *Queries) GetTrack(ctx context.Context, id int64) (Track, error) {
	row := q.queryRow(ctx, q.getTrackStmt, getTrack, id)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.FilePath,
		&i.FileName,
		&i.Container,
		&i.MimeType,
		&i.Codec,
		&i.Size,
		&i.TrackIndex,
		&i.Duration,
		&i.Disc,
		&i.Channels,
		&i.ChannelLayout,
		&i.BitRate,
		&i.Profile,
		&i.ReleaseDate,
		&i.Year,
		&i.Composer,
		&i.Copyright,
		&i.Language,
		&i.AlbumID,
		&i.MusicianID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTracksAlphabetical = `-- name: GetTracksAlphabetical :many
SELECT
  t.id,
  t.title,
  t.duration,
  t.codec,
  t.bit_rate,
  t.file_path,
  a.id as album_id,
  a.title as album_title,
  m.id as musician_id,
  m.name as musician_name
FROM tracks t
LEFT JOIN albums a ON t.album_id = a.id
LEFT JOIN musicians m ON t.musician_id = m.id
ORDER BY
  CASE
    WHEN UPPER(SUBSTR(t.title, 1, 1)) BETWEEN 'A' AND 'Z'
    THEN UPPER(SUBSTR(t.title, 1, 1))
    ELSE '#'
  END,
  UPPER(t.title)
LIMIT ? OFFSET ?
`

type GetTracksAlphabeticalParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetTracksAlphabeticalRow struct {
	ID           int64          `json:"id"`
	Title        string         `json:"title"`
	Duration     int64          `json:"duration"`
	Codec        string         `json:"codec"`
	BitRate      int64          `json:"bit_rate"`
	FilePath     string         `json:"file_path"`
	AlbumID      sql.NullInt64  `json:"album_id"`
	AlbumTitle   sql.NullString `json:"album_title"`
	MusicianID   sql.NullInt64  `json:"musician_id"`
	MusicianName sql.NullString `json:"musician_name"`
}

func (q *Queries) GetTracksAlphabetical(ctx context.Context, arg GetTracksAlphabeticalParams) ([]GetTracksAlphabeticalRow, error) {
	rows, err := q.query(ctx, q.getTracksAlphabeticalStmt, getTracksAlphabetical, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTracksAlphabeticalRow{}
	for rows.Next() {
		var i GetTracksAlphabeticalRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Duration,
			&i.Codec,
			&i.BitRate,
			&i.FilePath,
			&i.AlbumID,
			&i.AlbumTitle,
			&i.MusicianID,
			&i.MusicianName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTracksByAlbumID = `-- name: GetTracksByAlbumID :many
SELECT
  id, title, sort_title, file_path, file_name, container, mime_type, codec, size, track_index, duration, disc, channels, channel_layout, bit_rate, profile, release_date, year, composer, copyright, language, album_id, musician_id, created_at, updated_at
FROM
  tracks
WHERE
  album_id = ?
ORDER BY
  disc ASC,
  track_index ASC
`

func (q *Queries) GetTracksByAlbumID(ctx context.Context, albumID sql.NullInt64) ([]Track, error) {
	rows, err := q.query(ctx, q.getTracksByAlbumIDStmt, getTracksByAlbumID, albumID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Track{}
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.FilePath,
			&i.FileName,
			&i.Container,
			&i.MimeType,
			&i.Codec,
			&i.Size,
			&i.TrackIndex,
			&i.Duration,
			&i.Disc,
			&i.Channels,
			&i.ChannelLayout,
			&i.BitRate,
			&i.Profile,
			&i.ReleaseDate,
			&i.Year,
			&i.Composer,
			&i.Copyright,
			&i.Language,
			&i.AlbumID,
			&i.MusicianID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTracksCount = `-- name: GetTracksCount :one
SELECT COUNT(*) FROM tracks
`

func (q *Queries) GetTracksCount(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.getTracksCountStmt, getTracksCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const upsertTrack = `-- name: UpsertTrack :one
INSERT INTO tracks (
  title, sort_title, file_path, file_name, container, mime_type, codec, size,
  track_index, duration, disc, channels, channel_layout, bit_rate, profile,
  release_date, year, composer, copyright, language, album_id, musician_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT (file_path) DO UPDATE SET
  title = excluded.title,
  sort_title = excluded.sort_title,
  file_name = excluded.file_name,
  container = excluded.container,
  mime_type = excluded.mime_type,
  codec = excluded.codec,
  size = excluded.size,
  track_index = excluded.track_index,
  duration = excluded.duration,
  disc = excluded.disc,
  channels = excluded.channels,
  channel_layout = excluded.channel_layout,
  bit_rate = excluded.bit_rate,
  profile = excluded.profile,
  release_date = COALESCE(excluded.release_date, tracks.release_date),
  year = COALESCE(excluded.year, tracks.year),
  composer = COALESCE(excluded.composer, tracks.composer),
  copyright = COALESCE(excluded.copyright, tracks.copyright),
  language = COALESCE(excluded.language, tracks.language),
  album_id = COALESCE(excluded.album_id, tracks.album_id),
  musician_id = COALESCE(excluded.musician_id, tracks.musician_id),
  updated_at = CURRENT_TIMESTAMP
RETURNING id, title, sort_title, file_path, file_name, container, mime_type, codec, size, track_index, duration, disc, channels, channel_layout, bit_rate, profile, release_date, year, composer, copyright, language, album_id, musician_id, created_at, updated_at
`

type UpsertTrackParams struct {
	Title         string         `json:"title"`
	SortTitle     string         `json:"sort_title"`
	FilePath      string         `json:"file_path"`
	FileName      string         `json:"file_name"`
	Container     string         `json:"container"`
	MimeType      string         `json:"mime_type"`
	Codec         string         `json:"codec"`
	Size          int64          `json:"size"`
	TrackIndex    int64          `json:"track_index"`
	Duration      int64          `json:"duration"`
	Disc          int64          `json:"disc"`
	Channels      string         `json:"channels"`
	ChannelLayout string         `json:"channel_layout"`
	BitRate       int64          `json:"bit_rate"`
	Profile       string         `json:"profile"`
	ReleaseDate   sql.NullString `json:"release_date"`
	Year          sql.NullInt64  `json:"year"`
	Composer      sql.NullString `json:"composer"`
	Copyright     sql.NullString `json:"copyright"`
	Language      sql.NullString `json:"language"`
	AlbumID       sql.NullInt64  `json:"album_id"`
	MusicianID    sql.NullInt64  `json:"musician_id"`
}

func (q *Queries) UpsertTrack(ctx context.Context, arg UpsertTrackParams) (Track, error) {
	row := q.queryRow(ctx, q.upsertTrackStmt, upsertTrack,
		arg.Title,
		arg.SortTitle,
		arg.FilePath,
		arg.FileName,
		arg.Container,
		arg.MimeType,
		arg.Codec,
		arg.Size,
		arg.TrackIndex,
		arg.Duration,
		arg.Disc,
		arg.Channels,
		arg.ChannelLayout,
		arg.BitRate,
		arg.Profile,
		arg.ReleaseDate,
		arg.Year,
		arg.Composer,
		arg.Copyright,
		arg.Language,
		arg.AlbumID,
		arg.MusicianID,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.FilePath,
		&i.FileName,
		&i.Container,
		&i.MimeType,
		&i.Codec,
		&i.Size,
		&i.TrackIndex,
		&i.Duration,
		&i.Disc,
		&i.Channels,
		&i.ChannelLayout,
		&i.BitRate,
		&i.Profile,
		&i.ReleaseDate,
		&i.Year,
		&i.Composer,
		&i.Copyright,
		&i.Language,
		&i.AlbumID,
		&i.MusicianID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
