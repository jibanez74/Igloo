// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tracks.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkTrackExistByFilePath = `-- name: CheckTrackExistByFilePath :one
SELECT EXISTS(
    SELECT 1 FROM tracks WHERE file_path = $1
) as exists
`

func (q *Queries) CheckTrackExistByFilePath(ctx context.Context, filePath string) (bool, error) {
	row := q.db.QueryRow(ctx, checkTrackExistByFilePath, filePath)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createTrack = `-- name: CreateTrack :one
INSERT INTO tracks (
    title, sort_title, track_index, duration, composer, release_date, file_path, container, codec, bit_rate, channel_layout, copyright, size, file_name, disc, album_id, language, profile, sample_rate, musician_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
) RETURNING id, created_at, updated_at, title, sort_title, disc, track_index, duration, composer, release_date, year, file_path, file_name, container, codec, bit_rate, channel_layout, copyright, language, size, profile, sample_rate, album_id, musician_id
`

type CreateTrackParams struct {
	Title         string         `json:"title"`
	SortTitle     string         `json:"sort_title"`
	TrackIndex    int32          `json:"track_index"`
	Duration      pgtype.Numeric `json:"duration"`
	Composer      pgtype.Text    `json:"composer"`
	ReleaseDate   pgtype.Date    `json:"release_date"`
	FilePath      string         `json:"file_path"`
	Container     string         `json:"container"`
	Codec         string         `json:"codec"`
	BitRate       pgtype.Int4    `json:"bit_rate"`
	ChannelLayout string         `json:"channel_layout"`
	Copyright     pgtype.Text    `json:"copyright"`
	Size          int64          `json:"size"`
	FileName      string         `json:"file_name"`
	Disc          int32          `json:"disc"`
	AlbumID       pgtype.Int4    `json:"album_id"`
	Language      pgtype.Text    `json:"language"`
	Profile       pgtype.Text    `json:"profile"`
	SampleRate    pgtype.Int4    `json:"sample_rate"`
	MusicianID    pgtype.Int4    `json:"musician_id"`
}

func (q *Queries) CreateTrack(ctx context.Context, arg CreateTrackParams) (Track, error) {
	row := q.db.QueryRow(ctx, createTrack,
		arg.Title,
		arg.SortTitle,
		arg.TrackIndex,
		arg.Duration,
		arg.Composer,
		arg.ReleaseDate,
		arg.FilePath,
		arg.Container,
		arg.Codec,
		arg.BitRate,
		arg.ChannelLayout,
		arg.Copyright,
		arg.Size,
		arg.FileName,
		arg.Disc,
		arg.AlbumID,
		arg.Language,
		arg.Profile,
		arg.SampleRate,
		arg.MusicianID,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.SortTitle,
		&i.Disc,
		&i.TrackIndex,
		&i.Duration,
		&i.Composer,
		&i.ReleaseDate,
		&i.Year,
		&i.FilePath,
		&i.FileName,
		&i.Container,
		&i.Codec,
		&i.BitRate,
		&i.ChannelLayout,
		&i.Copyright,
		&i.Language,
		&i.Size,
		&i.Profile,
		&i.SampleRate,
		&i.AlbumID,
		&i.MusicianID,
	)
	return i, err
}

const getTrackCount = `-- name: GetTrackCount :one
SELECT COUNT(*) FROM tracks
`

func (q *Queries) GetTrackCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTrackCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}
