// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movies.sql

package database

import (
	"context"
	"database/sql"
)

const checkMovieUnchanged = `-- name: CheckMovieUnchanged :one
SELECT
  1
FROM
  movies
WHERE
  file_path = ?
  AND size = ?
LIMIT
  1
`

type CheckMovieUnchangedParams struct {
	FilePath string `json:"file_path"`
	Size     int64  `json:"size"`
}

// Quick check if movie exists with same path and size (likely unchanged)
func (q *Queries) CheckMovieUnchanged(ctx context.Context, arg CheckMovieUnchangedParams) (int64, error) {
	row := q.queryRow(ctx, q.checkMovieUnchangedStmt, checkMovieUnchanged, arg.FilePath, arg.Size)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createMovieExtraVideo = `-- name: CreateMovieExtraVideo :exec
INSERT INTO
  movie_extra_videos (movie_id, extra_video_id)
VALUES
  (?, ?) ON CONFLICT (movie_id, extra_video_id) DO NOTHING
`

type CreateMovieExtraVideoParams struct {
	MovieID      int64 `json:"movie_id"`
	ExtraVideoID int64 `json:"extra_video_id"`
}

// Link a movie to an extra video (trailer/special feature). Idempotent.
func (q *Queries) CreateMovieExtraVideo(ctx context.Context, arg CreateMovieExtraVideoParams) error {
	_, err := q.exec(ctx, q.createMovieExtraVideoStmt, createMovieExtraVideo, arg.MovieID, arg.ExtraVideoID)
	return err
}

const createMovieGenre = `-- name: CreateMovieGenre :exec
INSERT INTO
  movie_genres (movie_id, genre_id)
VALUES
  (?, ?) ON CONFLICT (movie_id, genre_id) DO NOTHING
`

type CreateMovieGenreParams struct {
	MovieID int64 `json:"movie_id"`
	GenreID int64 `json:"genre_id"`
}

// Link movie to genre via junction table
func (q *Queries) CreateMovieGenre(ctx context.Context, arg CreateMovieGenreParams) error {
	_, err := q.exec(ctx, q.createMovieGenreStmt, createMovieGenre, arg.MovieID, arg.GenreID)
	return err
}

const createMovieProductionCompany = `-- name: CreateMovieProductionCompany :exec
INSERT INTO
  movie_production_companies (movie_id, production_company_id)
VALUES
  (?, ?) ON CONFLICT (movie_id, production_company_id) DO NOTHING
`

type CreateMovieProductionCompanyParams struct {
	MovieID             int64 `json:"movie_id"`
	ProductionCompanyID int64 `json:"production_company_id"`
}

// Link movie to production company via junction table
func (q *Queries) CreateMovieProductionCompany(ctx context.Context, arg CreateMovieProductionCompanyParams) error {
	_, err := q.exec(ctx, q.createMovieProductionCompanyStmt, createMovieProductionCompany, arg.MovieID, arg.ProductionCompanyID)
	return err
}

const deleteMovieAudioStreams = `-- name: DeleteMovieAudioStreams :exec
DELETE FROM audio_streams
WHERE
  movie_id = ?
`

// Delete all audio streams for a movie
func (q *Queries) DeleteMovieAudioStreams(ctx context.Context, movieID int64) error {
	_, err := q.exec(ctx, q.deleteMovieAudioStreamsStmt, deleteMovieAudioStreams, movieID)
	return err
}

const deleteMovieChapters = `-- name: DeleteMovieChapters :exec
DELETE FROM chapters
WHERE
  movie_id = ?
`

// Delete all chapters for a movie
func (q *Queries) DeleteMovieChapters(ctx context.Context, movieID sql.NullInt64) error {
	_, err := q.exec(ctx, q.deleteMovieChaptersStmt, deleteMovieChapters, movieID)
	return err
}

const deleteMovieExtraVideos = `-- name: DeleteMovieExtraVideos :exec
DELETE FROM movie_extra_videos
WHERE
  movie_id = ?
`

// Remove all extra-video links for a movie (e.g. before re-scanning).
func (q *Queries) DeleteMovieExtraVideos(ctx context.Context, movieID int64) error {
	_, err := q.exec(ctx, q.deleteMovieExtraVideosStmt, deleteMovieExtraVideos, movieID)
	return err
}

const deleteMovieGenres = `-- name: DeleteMovieGenres :exec
DELETE FROM movie_genres
WHERE
  movie_id = ?
`

// Remove all genre links for a movie
func (q *Queries) DeleteMovieGenres(ctx context.Context, movieID int64) error {
	_, err := q.exec(ctx, q.deleteMovieGenresStmt, deleteMovieGenres, movieID)
	return err
}

const deleteMovieProductionCompanies = `-- name: DeleteMovieProductionCompanies :exec
DELETE FROM movie_production_companies
WHERE
  movie_id = ?
`

// Remove all production company links for a movie
func (q *Queries) DeleteMovieProductionCompanies(ctx context.Context, movieID int64) error {
	_, err := q.exec(ctx, q.deleteMovieProductionCompaniesStmt, deleteMovieProductionCompanies, movieID)
	return err
}

const deleteMovieSubtitles = `-- name: DeleteMovieSubtitles :exec
DELETE FROM subtitles
WHERE
  movie_id = ?
`

// Delete all subtitles for a movie
func (q *Queries) DeleteMovieSubtitles(ctx context.Context, movieID int64) error {
	_, err := q.exec(ctx, q.deleteMovieSubtitlesStmt, deleteMovieSubtitles, movieID)
	return err
}

const deleteMovieVideoStreams = `-- name: DeleteMovieVideoStreams :exec
DELETE FROM video_streams
WHERE
  movie_id = ?
`

// Delete all video streams for a movie
func (q *Queries) DeleteMovieVideoStreams(ctx context.Context, movieID int64) error {
	_, err := q.exec(ctx, q.deleteMovieVideoStreamsStmt, deleteMovieVideoStreams, movieID)
	return err
}

const getCastByMovieID = `-- name: GetCastByMovieID :many
SELECT
  c.id,
  c.movie_id,
  c.artist_id,
  c.character,
  c.cast_order,
  a.name AS artist_name,
  a.profile AS artist_profile
FROM
  cast c
  INNER JOIN artist a ON a.id = c.artist_id
WHERE
  c.movie_id = ?
ORDER BY
  c.cast_order
`

type GetCastByMovieIDRow struct {
	ID            int64          `json:"id"`
	MovieID       int64          `json:"movie_id"`
	ArtistID      int64          `json:"artist_id"`
	Character     string         `json:"character"`
	CastOrder     int64          `json:"cast_order"`
	ArtistName    string         `json:"artist_name"`
	ArtistProfile sql.NullString `json:"artist_profile"`
}

// Cast for a movie with artist name and profile (for details view).
func (q *Queries) GetCastByMovieID(ctx context.Context, movieID int64) ([]GetCastByMovieIDRow, error) {
	rows, err := q.query(ctx, q.getCastByMovieIDStmt, getCastByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCastByMovieIDRow{}
	for rows.Next() {
		var i GetCastByMovieIDRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.ArtistID,
			&i.Character,
			&i.CastOrder,
			&i.ArtistName,
			&i.ArtistProfile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCrewByMovieID = `-- name: GetCrewByMovieID :many
SELECT
  c.id,
  c.movie_id,
  c.artist_id,
  c.job,
  c.department,
  a.name AS artist_name,
  a.profile AS artist_profile
FROM
  crew c
  INNER JOIN artist a ON a.id = c.artist_id
WHERE
  c.movie_id = ?
ORDER BY
  c.department,
  c.job
`

type GetCrewByMovieIDRow struct {
	ID            int64          `json:"id"`
	MovieID       int64          `json:"movie_id"`
	ArtistID      int64          `json:"artist_id"`
	Job           string         `json:"job"`
	Department    string         `json:"department"`
	ArtistName    string         `json:"artist_name"`
	ArtistProfile sql.NullString `json:"artist_profile"`
}

// Crew for a movie with artist name and profile (for details view).
func (q *Queries) GetCrewByMovieID(ctx context.Context, movieID int64) ([]GetCrewByMovieIDRow, error) {
	rows, err := q.query(ctx, q.getCrewByMovieIDStmt, getCrewByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCrewByMovieIDRow{}
	for rows.Next() {
		var i GetCrewByMovieIDRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.ArtistID,
			&i.Job,
			&i.Department,
			&i.ArtistName,
			&i.ArtistProfile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGenresByMovieID = `-- name: GetGenresByMovieID :many
SELECT
  g.id,
  g.tag
FROM
  genres g
  INNER JOIN movie_genres mg ON mg.genre_id = g.id
WHERE
  mg.movie_id = ?
ORDER BY
  g.tag
`

type GetGenresByMovieIDRow struct {
	ID  int64  `json:"id"`
	Tag string `json:"tag"`
}

// Genres linked to a movie (for details view).
func (q *Queries) GetGenresByMovieID(ctx context.Context, movieID int64) ([]GetGenresByMovieIDRow, error) {
	rows, err := q.query(ctx, q.getGenresByMovieIDStmt, getGenresByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGenresByMovieIDRow{}
	for rows.Next() {
		var i GetGenresByMovieIDRow
		if err := rows.Scan(&i.ID, &i.Tag); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMovies = `-- name: GetLatestMovies :many
SELECT
  id,
  title,
  poster_path,
  year,
  certification
FROM
  movies
ORDER BY
  created_at DESC
LIMIT
  12
`

type GetLatestMoviesRow struct {
	ID            int64          `json:"id"`
	Title         string         `json:"title"`
	PosterPath    sql.NullString `json:"poster_path"`
	Year          sql.NullInt64  `json:"year"`
	Certification sql.NullString `json:"certification"`
}

func (q *Queries) GetLatestMovies(ctx context.Context) ([]GetLatestMoviesRow, error) {
	rows, err := q.query(ctx, q.getLatestMoviesStmt, getLatestMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLatestMoviesRow{}
	for rows.Next() {
		var i GetLatestMoviesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.PosterPath,
			&i.Year,
			&i.Certification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieByFilePath = `-- name: GetMovieByFilePath :one
SELECT
  id, title, file_path, file_name, size, container, mime_type, adult, tmdb_id, imdb_id, poster_path, backdrop_path, language, year, release_date, overview, tag_line, certification, critic_rating, audience_rating, revenue, budget, run_time, created_at, updated_at
FROM
  movies
WHERE
  file_path = ?
LIMIT
  1
`

func (q *Queries) GetMovieByFilePath(ctx context.Context, filePath string) (Movie, error) {
	row := q.queryRow(ctx, q.getMovieByFilePathStmt, getMovieByFilePath, filePath)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.FilePath,
		&i.FileName,
		&i.Size,
		&i.Container,
		&i.MimeType,
		&i.Adult,
		&i.TmdbID,
		&i.ImdbID,
		&i.PosterPath,
		&i.BackdropPath,
		&i.Language,
		&i.Year,
		&i.ReleaseDate,
		&i.Overview,
		&i.TagLine,
		&i.Certification,
		&i.CriticRating,
		&i.AudienceRating,
		&i.Revenue,
		&i.Budget,
		&i.RunTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMovieByID = `-- name: GetMovieByID :one
SELECT
  id, title, file_path, file_name, size, container, mime_type, adult, tmdb_id, imdb_id, poster_path, backdrop_path, language, year, release_date, overview, tag_line, certification, critic_rating, audience_rating, revenue, budget, run_time, created_at, updated_at
FROM
  movies
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetMovieByID(ctx context.Context, id int64) (Movie, error) {
	row := q.queryRow(ctx, q.getMovieByIDStmt, getMovieByID, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.FilePath,
		&i.FileName,
		&i.Size,
		&i.Container,
		&i.MimeType,
		&i.Adult,
		&i.TmdbID,
		&i.ImdbID,
		&i.PosterPath,
		&i.BackdropPath,
		&i.Language,
		&i.Year,
		&i.ReleaseDate,
		&i.Overview,
		&i.TagLine,
		&i.Certification,
		&i.CriticRating,
		&i.AudienceRating,
		&i.Revenue,
		&i.Budget,
		&i.RunTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMovieByTmdbID = `-- name: GetMovieByTmdbID :one
SELECT
  id, title, file_path, file_name, size, container, mime_type, adult, tmdb_id, imdb_id, poster_path, backdrop_path, language, year, release_date, overview, tag_line, certification, critic_rating, audience_rating, revenue, budget, run_time, created_at, updated_at
FROM
  movies
WHERE
  tmdb_id = ?
ORDER BY
  id ASC
LIMIT
  1
`

// When multiple rows share the same tmdb_id, returns the one with smallest id.
func (q *Queries) GetMovieByTmdbID(ctx context.Context, tmdbID sql.NullInt64) (Movie, error) {
	row := q.queryRow(ctx, q.getMovieByTmdbIDStmt, getMovieByTmdbID, tmdbID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.FilePath,
		&i.FileName,
		&i.Size,
		&i.Container,
		&i.MimeType,
		&i.Adult,
		&i.TmdbID,
		&i.ImdbID,
		&i.PosterPath,
		&i.BackdropPath,
		&i.Language,
		&i.Year,
		&i.ReleaseDate,
		&i.Overview,
		&i.TagLine,
		&i.Certification,
		&i.CriticRating,
		&i.AudienceRating,
		&i.Revenue,
		&i.Budget,
		&i.RunTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMovieExtraVideos = `-- name: GetMovieExtraVideos :many
SELECT
  extra_videos.id,
  extra_videos.title,
  extra_videos.external_id,
  extra_videos.key,
  extra_videos.type,
  extra_videos.site,
  extra_videos.official,
  extra_videos.created_at,
  extra_videos.updated_at
FROM
  extra_videos
  INNER JOIN movie_extra_videos ON movie_extra_videos.extra_video_id = extra_videos.id
WHERE
  movie_extra_videos.movie_id = ?
ORDER BY
  extra_videos.type,
  extra_videos.title
`

// List all extra videos (trailers, special features) linked to a movie.
func (q *Queries) GetMovieExtraVideos(ctx context.Context, movieID int64) ([]ExtraVideo, error) {
	rows, err := q.query(ctx, q.getMovieExtraVideosStmt, getMovieExtraVideos, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExtraVideo{}
	for rows.Next() {
		var i ExtraVideo
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ExternalID,
			&i.Key,
			&i.Type,
			&i.Site,
			&i.Official,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductionCompaniesByMovieID = `-- name: GetProductionCompaniesByMovieID :many
SELECT
  pc.id,
  pc.name,
  pc.tmdb_id,
  pc.logo,
  pc.country
FROM
  production_companies pc
  INNER JOIN movie_production_companies mpc ON mpc.production_company_id = pc.id
WHERE
  mpc.movie_id = ?
ORDER BY
  pc.name
`

type GetProductionCompaniesByMovieIDRow struct {
	ID      int64          `json:"id"`
	Name    string         `json:"name"`
	TmdbID  int64          `json:"tmdb_id"`
	Logo    sql.NullString `json:"logo"`
	Country sql.NullString `json:"country"`
}

// Production companies linked to a movie (for details view).
func (q *Queries) GetProductionCompaniesByMovieID(ctx context.Context, movieID int64) ([]GetProductionCompaniesByMovieIDRow, error) {
	rows, err := q.query(ctx, q.getProductionCompaniesByMovieIDStmt, getProductionCompaniesByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductionCompaniesByMovieIDRow{}
	for rows.Next() {
		var i GetProductionCompaniesByMovieIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TmdbID,
			&i.Logo,
			&i.Country,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAudioStream = `-- name: InsertAudioStream :one
INSERT INTO
  audio_streams (
    movie_id,
    stream_index,
    codec,
    codec_profile,
    bit_rate,
    sample_rate,
    channels,
    channel_layout,
    language,
    title
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, movie_id, stream_index, codec, codec_profile, bit_rate, sample_rate, channels, channel_layout, language, title, created_at, updated_at
`

type InsertAudioStreamParams struct {
	MovieID       int64          `json:"movie_id"`
	StreamIndex   int64          `json:"stream_index"`
	Codec         string         `json:"codec"`
	CodecProfile  sql.NullString `json:"codec_profile"`
	BitRate       int64          `json:"bit_rate"`
	SampleRate    sql.NullInt64  `json:"sample_rate"`
	Channels      int64          `json:"channels"`
	ChannelLayout sql.NullString `json:"channel_layout"`
	Language      sql.NullString `json:"language"`
	Title         sql.NullString `json:"title"`
}

func (q *Queries) InsertAudioStream(ctx context.Context, arg InsertAudioStreamParams) (AudioStream, error) {
	row := q.queryRow(ctx, q.insertAudioStreamStmt, insertAudioStream,
		arg.MovieID,
		arg.StreamIndex,
		arg.Codec,
		arg.CodecProfile,
		arg.BitRate,
		arg.SampleRate,
		arg.Channels,
		arg.ChannelLayout,
		arg.Language,
		arg.Title,
	)
	var i AudioStream
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.StreamIndex,
		&i.Codec,
		&i.CodecProfile,
		&i.BitRate,
		&i.SampleRate,
		&i.Channels,
		&i.ChannelLayout,
		&i.Language,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertChapter = `-- name: InsertChapter :one
INSERT INTO
  chapters (movie_id, title, start_time, thumb)
VALUES
  (?, ?, ?, ?) RETURNING id, title, start_time, thumb, movie_id
`

type InsertChapterParams struct {
	MovieID   sql.NullInt64  `json:"movie_id"`
	Title     string         `json:"title"`
	StartTime int64          `json:"start_time"`
	Thumb     sql.NullString `json:"thumb"`
}

func (q *Queries) InsertChapter(ctx context.Context, arg InsertChapterParams) (Chapter, error) {
	row := q.queryRow(ctx, q.insertChapterStmt, insertChapter,
		arg.MovieID,
		arg.Title,
		arg.StartTime,
		arg.Thumb,
	)
	var i Chapter
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartTime,
		&i.Thumb,
		&i.MovieID,
	)
	return i, err
}

const insertSubtitle = `-- name: InsertSubtitle :one
INSERT INTO
  subtitles (
    movie_id,
    stream_index,
    codec,
    language,
    title,
    is_forced,
    is_default
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?) RETURNING id, movie_id, stream_index, codec, language, title, is_forced, is_default, created_at, updated_at
`

type InsertSubtitleParams struct {
	MovieID     int64          `json:"movie_id"`
	StreamIndex int64          `json:"stream_index"`
	Codec       string         `json:"codec"`
	Language    sql.NullString `json:"language"`
	Title       sql.NullString `json:"title"`
	IsForced    bool           `json:"is_forced"`
	IsDefault   bool           `json:"is_default"`
}

func (q *Queries) InsertSubtitle(ctx context.Context, arg InsertSubtitleParams) (Subtitle, error) {
	row := q.queryRow(ctx, q.insertSubtitleStmt, insertSubtitle,
		arg.MovieID,
		arg.StreamIndex,
		arg.Codec,
		arg.Language,
		arg.Title,
		arg.IsForced,
		arg.IsDefault,
	)
	var i Subtitle
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.StreamIndex,
		&i.Codec,
		&i.Language,
		&i.Title,
		&i.IsForced,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertVideoStream = `-- name: InsertVideoStream :one
INSERT INTO
  video_streams (
    movie_id,
    stream_index,
    codec,
    codec_profile,
    codec_level,
    bit_rate,
    width,
    height,
    coded_width,
    coded_height,
    aspect_ratio,
    frame_rate,
    avg_frame_rate,
    bit_depth,
    color_range,
    color_space,
    color_primaries,
    color_transfer,
    language,
    title
  )
VALUES
  (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
  ) RETURNING id, movie_id, stream_index, codec, codec_profile, codec_level, bit_rate, width, height, coded_width, coded_height, aspect_ratio, frame_rate, avg_frame_rate, bit_depth, color_range, color_space, color_primaries, color_transfer, language, title, created_at, updated_at
`

type InsertVideoStreamParams struct {
	MovieID        int64          `json:"movie_id"`
	StreamIndex    int64          `json:"stream_index"`
	Codec          string         `json:"codec"`
	CodecProfile   sql.NullString `json:"codec_profile"`
	CodecLevel     sql.NullInt64  `json:"codec_level"`
	BitRate        int64          `json:"bit_rate"`
	Width          int64          `json:"width"`
	Height         int64          `json:"height"`
	CodedWidth     sql.NullInt64  `json:"coded_width"`
	CodedHeight    sql.NullInt64  `json:"coded_height"`
	AspectRatio    sql.NullString `json:"aspect_ratio"`
	FrameRate      float64        `json:"frame_rate"`
	AvgFrameRate   sql.NullString `json:"avg_frame_rate"`
	BitDepth       sql.NullInt64  `json:"bit_depth"`
	ColorRange     sql.NullString `json:"color_range"`
	ColorSpace     sql.NullString `json:"color_space"`
	ColorPrimaries sql.NullString `json:"color_primaries"`
	ColorTransfer  sql.NullString `json:"color_transfer"`
	Language       sql.NullString `json:"language"`
	Title          sql.NullString `json:"title"`
}

func (q *Queries) InsertVideoStream(ctx context.Context, arg InsertVideoStreamParams) (VideoStream, error) {
	row := q.queryRow(ctx, q.insertVideoStreamStmt, insertVideoStream,
		arg.MovieID,
		arg.StreamIndex,
		arg.Codec,
		arg.CodecProfile,
		arg.CodecLevel,
		arg.BitRate,
		arg.Width,
		arg.Height,
		arg.CodedWidth,
		arg.CodedHeight,
		arg.AspectRatio,
		arg.FrameRate,
		arg.AvgFrameRate,
		arg.BitDepth,
		arg.ColorRange,
		arg.ColorSpace,
		arg.ColorPrimaries,
		arg.ColorTransfer,
		arg.Language,
		arg.Title,
	)
	var i VideoStream
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.StreamIndex,
		&i.Codec,
		&i.CodecProfile,
		&i.CodecLevel,
		&i.BitRate,
		&i.Width,
		&i.Height,
		&i.CodedWidth,
		&i.CodedHeight,
		&i.AspectRatio,
		&i.FrameRate,
		&i.AvgFrameRate,
		&i.BitDepth,
		&i.ColorRange,
		&i.ColorSpace,
		&i.ColorPrimaries,
		&i.ColorTransfer,
		&i.Language,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertArtist = `-- name: UpsertArtist :one
INSERT INTO
  artist (name, tmdb_id, profile)
VALUES
  (?, ?, ?) ON CONFLICT (tmdb_id) DO
UPDATE
SET
  name = excluded.name,
  profile = COALESCE(excluded.profile, artist.profile),
  updated_at = CURRENT_TIMESTAMP RETURNING id, name, tmdb_id, profile, created_at, updated_at
`

type UpsertArtistParams struct {
	Name    string         `json:"name"`
	TmdbID  int64          `json:"tmdb_id"`
	Profile sql.NullString `json:"profile"`
}

func (q *Queries) UpsertArtist(ctx context.Context, arg UpsertArtistParams) (Artist, error) {
	row := q.queryRow(ctx, q.upsertArtistStmt, upsertArtist, arg.Name, arg.TmdbID, arg.Profile)
	var i Artist
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TmdbID,
		&i.Profile,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertCast = `-- name: UpsertCast :one
INSERT INTO
  cast(movie_id, artist_id, character, cast_order)
VALUES
  (?, ?, ?, ?) ON CONFLICT (movie_id, artist_id, cast_order) DO
UPDATE
SET
  character = excluded.character,
  updated_at = CURRENT_TIMESTAMP RETURNING id, movie_id, artist_id, character, cast_order, created_at, updated_at
`

type UpsertCastParams struct {
	MovieID   int64  `json:"movie_id"`
	ArtistID  int64  `json:"artist_id"`
	Character string `json:"character"`
	CastOrder int64  `json:"cast_order"`
}

func (q *Queries) UpsertCast(ctx context.Context, arg UpsertCastParams) (Cast, error) {
	row := q.queryRow(ctx, q.upsertCastStmt, upsertCast,
		arg.MovieID,
		arg.ArtistID,
		arg.Character,
		arg.CastOrder,
	)
	var i Cast
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.ArtistID,
		&i.Character,
		&i.CastOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertCrew = `-- name: UpsertCrew :one
INSERT INTO
  crew (movie_id, artist_id, job, department)
VALUES
  (?, ?, ?, ?) ON CONFLICT (movie_id, artist_id, job, department) DO
UPDATE
SET
  updated_at = CURRENT_TIMESTAMP RETURNING id, movie_id, artist_id, job, department, created_at, updated_at
`

type UpsertCrewParams struct {
	MovieID    int64  `json:"movie_id"`
	ArtistID   int64  `json:"artist_id"`
	Job        string `json:"job"`
	Department string `json:"department"`
}

func (q *Queries) UpsertCrew(ctx context.Context, arg UpsertCrewParams) (Crew, error) {
	row := q.queryRow(ctx, q.upsertCrewStmt, upsertCrew,
		arg.MovieID,
		arg.ArtistID,
		arg.Job,
		arg.Department,
	)
	var i Crew
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.ArtistID,
		&i.Job,
		&i.Department,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertExtraVideo = `-- name: UpsertExtraVideo :one
INSERT INTO
  extra_videos (title, external_id, key, type, site, official)
VALUES
  (?, ?, ?, ?, ?, ?) ON CONFLICT (external_id) DO
UPDATE
SET
  title = excluded.title,
  key = excluded.key,
  type = excluded.type,
  site = excluded.site,
  official = excluded.official,
  updated_at = CURRENT_TIMESTAMP RETURNING id, title, external_id, "key", type, site, official, created_at, updated_at
`

type UpsertExtraVideoParams struct {
	Title      string         `json:"title"`
	ExternalID sql.NullString `json:"external_id"`
	Key        string         `json:"key"`
	Type       string         `json:"type"`
	Site       string         `json:"site"`
	Official   bool           `json:"official"`
}

// Insert or update an extra video by external_id (e.g. TMDB video id). Use for trailers/special features.
// Call with a non-null external_id so conflicts are detected; then link via CreateMovieExtraVideo.
func (q *Queries) UpsertExtraVideo(ctx context.Context, arg UpsertExtraVideoParams) (ExtraVideo, error) {
	row := q.queryRow(ctx, q.upsertExtraVideoStmt, upsertExtraVideo,
		arg.Title,
		arg.ExternalID,
		arg.Key,
		arg.Type,
		arg.Site,
		arg.Official,
	)
	var i ExtraVideo
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ExternalID,
		&i.Key,
		&i.Type,
		&i.Site,
		&i.Official,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertMovie = `-- name: UpsertMovie :one
INSERT INTO
  movies (
    title,
    file_path,
    file_name,
    size,
    container,
    mime_type,
    adult,
    tmdb_id,
    imdb_id,
    poster_path,
    backdrop_path,
    language,
    year,
    release_date,
    overview,
    tag_line,
    certification,
    critic_rating,
    audience_rating,
    revenue,
    budget,
    run_time
  )
VALUES
  (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
  ) ON CONFLICT (file_path) DO
UPDATE
SET
  title = excluded.title,
  file_name = excluded.file_name,
  size = excluded.size,
  container = excluded.container,
  mime_type = excluded.mime_type,
  adult = excluded.adult,
  tmdb_id = COALESCE(excluded.tmdb_id, movies.tmdb_id),
  imdb_id = COALESCE(excluded.imdb_id, movies.imdb_id),
  poster_path = COALESCE(excluded.poster_path, movies.poster_path),
  language = COALESCE(excluded.language, movies.language),
  year = COALESCE(excluded.year, movies.year),
  release_date = COALESCE(excluded.release_date, movies.release_date),
  overview = COALESCE(excluded.overview, movies.overview),
  tag_line = COALESCE(excluded.tag_line, movies.tag_line),
  certification = COALESCE(excluded.certification, movies.certification),
  critic_rating = COALESCE(excluded.critic_rating, movies.critic_rating),
  audience_rating = COALESCE(excluded.audience_rating, movies.audience_rating),
  revenue = COALESCE(excluded.revenue, movies.revenue),
  budget = COALESCE(excluded.budget, movies.budget),
  run_time = COALESCE(excluded.run_time, movies.run_time),
  updated_at = CURRENT_TIMESTAMP RETURNING id, title, file_path, file_name, size, container, mime_type, adult, tmdb_id, imdb_id, poster_path, backdrop_path, language, year, release_date, overview, tag_line, certification, critic_rating, audience_rating, revenue, budget, run_time, created_at, updated_at
`

type UpsertMovieParams struct {
	Title          string          `json:"title"`
	FilePath       string          `json:"file_path"`
	FileName       string          `json:"file_name"`
	Size           int64           `json:"size"`
	Container      string          `json:"container"`
	MimeType       string          `json:"mime_type"`
	Adult          bool            `json:"adult"`
	TmdbID         sql.NullInt64   `json:"tmdb_id"`
	ImdbID         sql.NullString  `json:"imdb_id"`
	PosterPath     sql.NullString  `json:"poster_path"`
	BackdropPath   sql.NullString  `json:"backdrop_path"`
	Language       sql.NullString  `json:"language"`
	Year           sql.NullInt64   `json:"year"`
	ReleaseDate    sql.NullString  `json:"release_date"`
	Overview       sql.NullString  `json:"overview"`
	TagLine        sql.NullString  `json:"tag_line"`
	Certification  sql.NullString  `json:"certification"`
	CriticRating   sql.NullFloat64 `json:"critic_rating"`
	AudienceRating sql.NullFloat64 `json:"audience_rating"`
	Revenue        sql.NullFloat64 `json:"revenue"`
	Budget         sql.NullFloat64 `json:"budget"`
	RunTime        sql.NullInt64   `json:"run_time"`
}

func (q *Queries) UpsertMovie(ctx context.Context, arg UpsertMovieParams) (Movie, error) {
	row := q.queryRow(ctx, q.upsertMovieStmt, upsertMovie,
		arg.Title,
		arg.FilePath,
		arg.FileName,
		arg.Size,
		arg.Container,
		arg.MimeType,
		arg.Adult,
		arg.TmdbID,
		arg.ImdbID,
		arg.PosterPath,
		arg.BackdropPath,
		arg.Language,
		arg.Year,
		arg.ReleaseDate,
		arg.Overview,
		arg.TagLine,
		arg.Certification,
		arg.CriticRating,
		arg.AudienceRating,
		arg.Revenue,
		arg.Budget,
		arg.RunTime,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.FilePath,
		&i.FileName,
		&i.Size,
		&i.Container,
		&i.MimeType,
		&i.Adult,
		&i.TmdbID,
		&i.ImdbID,
		&i.PosterPath,
		&i.BackdropPath,
		&i.Language,
		&i.Year,
		&i.ReleaseDate,
		&i.Overview,
		&i.TagLine,
		&i.Certification,
		&i.CriticRating,
		&i.AudienceRating,
		&i.Revenue,
		&i.Budget,
		&i.RunTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertProductionCompany = `-- name: UpsertProductionCompany :one
INSERT INTO
  production_companies (name, tmdb_id, logo, country)
VALUES
  (?, ?, ?, ?) ON CONFLICT (tmdb_id) DO
UPDATE
SET
  name = excluded.name,
  logo = COALESCE(excluded.logo, production_companies.logo),
  country = COALESCE(excluded.country, production_companies.country),
  updated_at = CURRENT_TIMESTAMP RETURNING id, name, tmdb_id, logo, country, created_at, updated_at
`

type UpsertProductionCompanyParams struct {
	Name    string         `json:"name"`
	TmdbID  int64          `json:"tmdb_id"`
	Logo    sql.NullString `json:"logo"`
	Country sql.NullString `json:"country"`
}

func (q *Queries) UpsertProductionCompany(ctx context.Context, arg UpsertProductionCompanyParams) (ProductionCompany, error) {
	row := q.queryRow(ctx, q.upsertProductionCompanyStmt, upsertProductionCompany,
		arg.Name,
		arg.TmdbID,
		arg.Logo,
		arg.Country,
	)
	var i ProductionCompany
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TmdbID,
		&i.Logo,
		&i.Country,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
