# Jellyfin HLS VOD Streaming Implementation

This document provides a comprehensive overview of how Jellyfin implements HTTP Live Streaming (HLS) for Video on Demand (VOD) content.

## Overview

Jellyfin uses HLS (HTTP Live Streaming) for video-on-demand streaming, providing efficient delivery of video content with features like adaptive bitrate streaming, seeking support, and compatibility with a wide range of devices.

## Core Components

### 1. HLS Playlist Generation

The HLS playlist is generated by the `DynamicHlsPlaylistGenerator` class, which creates a VOD playlist with the following structure:

```m3u8
#EXTM3U
#EXT-X-PLAYLIST-TYPE:VOD
#EXT-X-VERSION:7
#EXT-X-TARGETDURATION:<duration>
#EXT-X-MEDIA-SEQUENCE:0
```

### 2. Segment Generation

Segments are generated using FFmpeg with the following key features:

- **Segment Length**: Configurable segment duration (default: 6 seconds)
- **Container Support**: 
  - MP4 (fMP4) segments (HLS version 7)
  - TS segments (HLS version 3)
- **Keyframe Alignment**: Segments are aligned with video keyframes for optimal seeking

### 3. Codec Support

#### Video Codecs:
- H.264/AVC
- HEVC/H.265 (configurable)
- AV1 (configurable)

#### Audio Codecs:
- AAC
- AC3
- MP3
- FLAC (in MP4 container requires FFmpeg 6.0+)

## Client-Server Interaction

### 1. Initial Request Flow

1. **Client Request**
   - Client initiates playback request with parameters:
     ```http
     GET /Videos/{itemId}/main.m3u8
     ```
   - Parameters include:
     - `itemId`: Media item identifier
     - `container`: Output container format
     - `segmentLength`: Duration of each segment
     - `minSegments`: Minimum number of segments to generate
     - Various encoding parameters (codecs, bitrates, etc.)

2. **Server Processing**
   - Server validates request and user permissions
   - Determines optimal streaming method:
     - Direct play (no transcoding)
     - Direct stream (container remuxing)
     - Transcode (full transcoding)

3. **Response Generation**
   - Server generates master playlist for adaptive bitrate streaming
   - Creates VOD playlist with segment information
   - Initiates FFmpeg process for segment generation

### 2. Segment Request Flow

1. **Client Segment Requests**
   ```http
   GET /Videos/{itemId}/hls/{playlistId}/segment.{segmentId}.{container}
   ```

2. **Server Segment Delivery**
   - Server checks segment existence
   - If segment exists: Serves directly
   - If segment missing: Triggers FFmpeg to generate
   - Supports range requests for seeking

3. **Playlist Updates**
   - Server maintains playlist with segment information
   - Updates segment durations and timestamps
   - Handles segment cleanup based on configuration

## FFmpeg Command Generation

### 1. Base Command Structure

```bash
ffmpeg {input_modifier} {input_argument} {map_args} {video_args} {audio_args} -f hls {hls_args} -y {output_path}
```

### 2. Input Parameters

```bash
# Input modifiers
-ss {start_time}          # Start time for seeking
-re                       # Read input at native framerate
-fflags +genpts          # Generate presentation timestamps
-fflags +igndts          # Ignore input DTS
-fflags +ignidx          # Ignore input index
-fflags +discardcorrupt  # Discard corrupt frames
-fflags +fastseek        # Enable fast seeking

# Input arguments
-i {input_file}          # Input file path
```

### 3. Video Encoding Parameters

```bash
# Video codec settings
-c:v {codec}            # Video codec (e.g., libx264, libx265)
-preset {preset}        # Encoder preset (veryfast for VOD)
-crf {value}           # Constant Rate Factor (23 for H.264, 28 for H.265)
-b:v {bitrate}         # Video bitrate
-maxrate {rate}        # Maximum bitrate
-bufsize {size}        # Buffer size
-r {framerate}         # Output framerate

# Keyframe settings
-g {value}             # Keyframe interval
-keyint_min {value}    # Minimum keyframe interval
-sc_threshold {value}  # Scene change threshold

# Hardware acceleration
-hwaccel {type}        # Hardware acceleration type
-hwaccel_device {id}   # Hardware device ID
```

### 4. Audio Encoding Parameters

```bash
# Audio codec settings
-c:a {codec}           # Audio codec (e.g., aac, ac3)
-b:a {bitrate}         # Audio bitrate
-ac {channels}         # Audio channels
-ar {rate}            # Audio sample rate

# Audio filters
-af {filters}         # Audio filters
```

### 5. HLS Output Parameters

```bash
# HLS settings
-f hls                 # HLS output format
-hls_time {seconds}    # Segment duration
-hls_playlist_type vod # VOD playlist type
-hls_segment_type {type} # Segment type (mpegts/fmp4)
-hls_segment_filename {pattern} # Segment filename pattern
-hls_list_size 0      # Keep all segments
-hls_flags {flags}    # HLS flags
```

### 6. Example Command

```bash
ffmpeg -ss 0 -i input.mp4 \
  -c:v libx264 -preset veryfast -crf 23 -maxrate 5000k -bufsize 10000k \
  -c:a aac -b:a 128k -ac 2 -ar 48000 \
  -f hls -hls_time 6 -hls_playlist_type vod \
  -hls_segment_type mpegts -hls_segment_filename "segment_%d.ts" \
  -hls_list_size 0 -y output.m3u8
```

## Configuration Options

### Encoding Settings

```csharp
public class EncodingOptions
{
    // Hardware Acceleration
    public bool EnableHardwareEncoding { get; set; }
    public HardwareAccelerationType HardwareAccelerationType { get; set; }
    
    // Video Quality
    public int H264Crf { get; set; }  // Default: 23
    public int H265Crf { get; set; }  // Default: 28
    
    // Segment Management
    public bool EnableSegmentDeletion { get; set; }
    public int SegmentKeepSeconds { get; set; }  // Default: 720
    
    // Performance
    public int MaxMuxingQueueSize { get; set; }  // Default: 2048
    public int EncodingThreadCount { get; set; }  // Default: -1 (auto)
}
```

### Streaming Parameters

```csharp
public class VideoRequestDto
{
    // Video Settings
    public string VideoCodec { get; set; }
    public int? VideoBitRate { get; set; }
    public int? Width { get; set; }
    public int? Height { get; set; }
    
    // Audio Settings
    public string AudioCodec { get; set; }
    public int? AudioBitRate { get; set; }
    public int? AudioChannels { get; set; }
    
    // Segment Settings
    public string SegmentContainer { get; set; }
    public int SegmentLength { get; set; }
    public int MinSegments { get; set; }
}
```

## Streaming Process

1. **Initial Request**
   - Client requests video playback
   - Server determines optimal streaming method (direct play, direct stream, or transcode)

2. **HLS Playlist Generation**
   - Creates master playlist with available quality levels
   - Generates VOD playlist with segment information
   - Configures segment duration and container format

3. **Segment Generation**
   - FFmpeg processes video into segments
   - Segments are aligned with keyframes
   - Supports both MP4 and TS containers

4. **Delivery**
   - Segments are served via HTTP
   - Supports range requests for seeking
   - Handles adaptive bitrate switching

## Performance Optimizations

1. **Hardware Acceleration**
   - Supports multiple hardware encoders (VAAPI, QSV, VideoToolbox)
   - Configurable per codec
   - Fallback to software encoding when needed

2. **Segment Management**
   - Automatic segment cleanup
   - Configurable segment retention
   - Efficient storage usage

3. **Encoding Optimization**
   - Thread count optimization
   - Hardware-accelerated encoding
   - Adaptive quality settings

## Error Handling

1. **Stream Recovery**
   - Automatic segment regeneration
   - Fallback to lower quality when needed
   - Error reporting to client

2. **Network Issues**
   - Adaptive bitrate switching
   - Buffer management
   - Connection recovery

## Security

1. **Access Control**
   - User authentication
   - Permission-based access
   - Secure segment delivery

2. **Content Protection**
   - HTTPS support
   - Token-based authentication
   - Session management

## Client Compatibility

1. **Browser Support**
   - Native HLS support in modern browsers
   - Fallback to hls.js for older browsers
   - Mobile device optimization

2. **Device Support**
   - iOS/macOS native support
   - Android compatibility
   - Smart TV integration

## Monitoring and Debugging

1. **Logging**
   - Detailed FFmpeg logs
   - Stream state tracking
   - Performance metrics

2. **Diagnostics**
   - Stream health monitoring
   - Quality metrics
   - Error reporting

## Best Practices

1. **Configuration**
   - Use hardware acceleration when available
   - Optimize segment length for content type
   - Configure appropriate bitrate limits

2. **Performance**
   - Enable segment deletion for long-term storage
   - Monitor system resources
   - Regular maintenance of temporary files

3. **Quality**
   - Balance quality vs. bandwidth
   - Use appropriate codec settings
   - Monitor client playback metrics

## Limitations

1. **Known Issues**
   - B-frames in HEVC with fMP4 on iOS
   - Some codec combinations may require transcoding
   - Hardware acceleration limitations

2. **Requirements**
   - FFmpeg 6.0+ for some features
   - Sufficient storage for segments
   - Adequate processing power for transcoding

## Future Improvements

1. **Planned Features**
   - Enhanced adaptive bitrate algorithms
   - Improved hardware acceleration support
   - Better segment management

2. **Optimization Opportunities**
   - Reduced latency
   - Better quality prediction
   - Enhanced error recovery

## Go Implementation Guide with Fiber Framework

### 1. Project Structure

```
hls-streaming/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── config/
│   │   └── config.go
│   ├── handlers/
│   │   ├── hls.go
│   │   └── media.go
│   ├── models/
│   │   ├── request.go
│   │   └── response.go
│   ├── services/
│   │   ├── ffmpeg.go
│   │   ├── playlist.go
│   │   └── storage.go
│   └── middleware/
│       ├── auth.go
│       └── logging.go
├── pkg/
│   ├── ffmpeg/
│   │   └── command.go
│   └── hls/
│       ├── playlist.go
│       └── segment.go
├── go.mod
└── go.sum
```

### 2. Core Components

#### 2.1 Configuration (config/config.go)

```go
type Config struct {
    Server struct {
        Port int    `env:"PORT" envDefault:"8080"`
        Host string `env:"HOST" envDefault:"0.0.0.0"`
    }
    FFmpeg struct {
        Path            string `env:"FFMPEG_PATH" envDefault:"ffmpeg"`
        SegmentLength   int    `env:"SEGMENT_LENGTH" envDefault:"6"`
        MinSegments     int    `env:"MIN_SEGMENTS" envDefault:"3"`
        MaxSegments     int    `env:"MAX_SEGMENTS" envDefault:"100"`
        HardwareAccel   bool   `env:"HARDWARE_ACCEL" envDefault:"true"`
        ThreadCount     int    `env:"THREAD_COUNT" envDefault:"-1"`
    }
    Storage struct {
        TempDir        string `env:"TEMP_DIR" envDefault:"/tmp/hls"`
        CleanupEnabled bool   `env:"CLEANUP_ENABLED" envDefault:"true"`
        KeepSeconds    int    `env:"KEEP_SECONDS" envDefault:"720"`
    }
}
```

#### 2.2 Models (models/request.go)

```go
type VideoRequest struct {
    ItemID          string `json:"itemId" query:"itemId"`
    Container       string `json:"container" query:"container"`
    SegmentLength   int    `json:"segmentLength" query:"segmentLength"`
    MinSegments     int    `json:"minSegments" query:"minSegments"`
    VideoCodec      string `json:"videoCodec" query:"videoCodec"`
    VideoBitRate    int    `json:"videoBitRate" query:"videoBitRate"`
    Width           int    `json:"width" query:"width"`
    Height          int    `json:"height" query:"height"`
    AudioCodec      string `json:"audioCodec" query:"audioCodec"`
    AudioBitRate    int    `json:"audioBitRate" query:"audioBitRate"`
    AudioChannels   int    `json:"audioChannels" query:"audioChannels"`
}

type SegmentRequest struct {
    ItemID      string `json:"itemId" query:"itemId"`
    PlaylistID  string `json:"playlistId" query:"playlistId"`
    SegmentID   int    `json:"segmentId" query:"segmentId"`
    Container   string `json:"container" query:"container"`
}
```

#### 2.3 FFmpeg Service (services/ffmpeg.go)

```go
type FFmpegService struct {
    config *config.Config
    logger *zap.Logger
}

func (s *FFmpegService) GenerateCommand(req *models.VideoRequest) (*exec.Cmd, error) {
    args := []string{
        "-ss", "0",
        "-re",
        "-fflags", "+genpts+igndts+ignidx+discardcorrupt+fastseek",
        "-i", req.InputPath,
    }

    // Add video encoding parameters
    args = append(args, s.getVideoArgs(req)...)
    
    // Add audio encoding parameters
    args = append(args, s.getAudioArgs(req)...)
    
    // Add HLS output parameters
    args = append(args, s.getHLSArgs(req)...)

    return exec.Command(s.config.FFmpeg.Path, args...), nil
}

func (s *FFmpegService) getVideoArgs(req *models.VideoRequest) []string {
    args := []string{
        "-c:v", req.VideoCodec,
        "-preset", "veryfast",
        "-crf", "23",
    }
    
    if req.VideoBitRate > 0 {
        args = append(args, "-b:v", fmt.Sprintf("%dk", req.VideoBitRate))
    }
    
    if s.config.FFmpeg.HardwareAccel {
        args = append(args, "-hwaccel", "auto")
    }
    
    return args
}
```

#### 2.4 Playlist Service (services/playlist.go)

```go
type PlaylistService struct {
    config *config.Config
    logger *zap.Logger
}

func (s *PlaylistService) GenerateVODPlaylist(segments []Segment) string {
    var sb strings.Builder
    
    sb.WriteString("#EXTM3U\n")
    sb.WriteString("#EXT-X-PLAYLIST-TYPE:VOD\n")
    sb.WriteString("#EXT-X-VERSION:7\n")
    sb.WriteString(fmt.Sprintf("#EXT-X-TARGETDURATION:%d\n", s.config.FFmpeg.SegmentLength))
    sb.WriteString("#EXT-X-MEDIA-SEQUENCE:0\n")
    
    for _, segment := range segments {
        sb.WriteString(fmt.Sprintf("#EXTINF:%.3f,\n", segment.Duration))
        sb.WriteString(fmt.Sprintf("segment.%d.%s\n", segment.ID, segment.Container))
    }
    
    sb.WriteString("#EXT-X-ENDLIST\n")
    
    return sb.String()
}
```

#### 2.5 Handlers (handlers/hls.go)

```go
type HLSHandler struct {
    ffmpeg   *services.FFmpegService
    playlist *services.PlaylistService
    storage  *services.StorageService
    logger   *zap.Logger
}

func (h *HLSHandler) GetMasterPlaylist(c *fiber.Ctx) error {
    var req models.VideoRequest
    if err := c.QueryParser(&req); err != nil {
        return fiber.NewError(fiber.StatusBadRequest, "Invalid request parameters")
    }

    // Validate request and permissions
    if err := h.validateRequest(c, &req); err != nil {
        return err
    }

    // Generate master playlist
    playlist := h.playlist.GenerateMasterPlaylist(req)
    
    c.Set("Content-Type", "application/vnd.apple.mpegurl")
    return c.SendString(playlist)
}

func (h *HLSHandler) GetSegment(c *fiber.Ctx) error {
    var req models.SegmentRequest
    if err := c.QueryParser(&req); err != nil {
        return fiber.NewError(fiber.StatusBadRequest, "Invalid request parameters")
    }

    // Check if segment exists
    segment, err := h.storage.GetSegment(req)
    if err != nil {
        // Generate missing segment
        if err := h.generateSegment(c, &req); err != nil {
            return err
        }
    }

    // Serve segment
    return c.SendFile(segment.Path)
}
```

#### 2.6 Main Application (cmd/server/main.go)

```go
func main() {
    // Initialize logger
    logger, _ := zap.NewProduction()
    defer logger.Sync()

    // Load configuration
    cfg := config.Load()

    // Initialize services
    ffmpeg := services.NewFFmpegService(cfg, logger)
    playlist := services.NewPlaylistService(cfg, logger)
    storage := services.NewStorageService(cfg, logger)

    // Initialize handlers
    hls := handlers.NewHLSHandler(ffmpeg, playlist, storage, logger)

    // Create Fiber app
    app := fiber.New(fiber.Config{
        Prefork: true,
    })

    // Middleware
    app.Use(middleware.Logger())
    app.Use(middleware.Recover())
    app.Use(middleware.CORS())

    // Routes
    app.Get("/videos/:itemId/main.m3u8", hls.GetMasterPlaylist)
    app.Get("/videos/:itemId/hls/:playlistId/segment.:segmentId.:container", hls.GetSegment)

    // Start server
    app.Listen(fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port))
}
```

### 3. Implementation Steps

1. **Setup Project Structure**
   - Initialize Go module
   - Create directory structure
   - Set up configuration management

2. **Core Services Implementation**
   - Implement FFmpeg command generation
   - Create playlist generation service
   - Implement segment storage and management

3. **HTTP Handlers**
   - Implement master playlist endpoint
   - Implement segment endpoint
   - Add error handling and logging

4. **Middleware**
   - Add authentication
   - Implement request logging
   - Add CORS support

5. **Testing**
   - Unit tests for services
   - Integration tests for HTTP endpoints
   - Performance testing

### 4. Dependencies

```go
require (
    github.com/gofiber/fiber/v2 v2.52.0
    github.com/joho/godotenv v1.5.1
    go.uber.org/zap v1.26.0
    github.com/stretchr/testify v1.8.4
)
```

### 5. Key Features to Implement

1. **Adaptive Bitrate Streaming**
   - Multiple quality levels
   - Automatic quality switching
   - Bandwidth monitoring

2. **Segment Management**
   - Automatic cleanup
   - Segment caching
   - Concurrent segment generation

3. **Error Handling**
   - Graceful degradation
   - Automatic recovery
   - Detailed error reporting

4. **Performance Optimization**
   - Connection pooling
   - Response caching
   - Efficient segment delivery

### 6. Security Considerations

1. **Authentication**
   - JWT-based authentication
   - Role-based access control
   - Session management

2. **Content Protection**
   - HTTPS enforcement
   - Token validation
   - Rate limiting

### 7. Monitoring and Logging

1. **Metrics**
   - Request latency
   - Segment generation time
   - Error rates
   - Bandwidth usage

2. **Logging**
   - Structured logging
   - Request tracing
   - Error tracking

### 8. Deployment Considerations

1. **Containerization**
   - Docker support
   - Multi-stage builds
   - Environment configuration

2. **Scaling**
   - Horizontal scaling
   - Load balancing
   - Session management

### 9. Future Enhancements

1. **Features**
   - Live streaming support
   - DRM integration
   - Analytics dashboard

2. **Optimizations**
   - Edge caching
   - CDN integration
   - Adaptive bitrate algorithms 